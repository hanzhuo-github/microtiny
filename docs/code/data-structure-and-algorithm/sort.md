---
lang: zh-CN
title: 排序
description:
article: false
date: 2023-08-22
---


|排序算法|时间复杂度|是否基于比较|
|:--|:--|:--:|
|冒泡、插入、选择|$O(n^{2})$|&check;|
|快排|$O(n log n)$|&check;|
|桶、计数、基数|$O(n)$|&cross;|

要考虑的指标：
- 时间复杂度：最好、最坏、平均；时间复杂度的系数、常数、低阶；比较次数和交换（或移动）次数
- 空间复杂度：原地排序（Sorted in place）-> $O(1)$
- 稳定性

## 1. 冒泡、插入、选择

这三种排序算法都是原地排序。

### 1.1 Bubble Sort

对相邻数据做操作，比较 + 交换。

:::details 代码
```cpp
public void bubbleSort(int[] a, int n) {
    if ( n <= 1) return;

    for (int i = 0; i < n; ++i) {
        // 是否有数据交换
        boolean flag = false;
        for (int j = 0; j < n - i - j; ++j) {
            if (a[j] > a[j+1]) {
                int tmp = a[j];
                a[j] = a[j+1];
                a[j+1] = tmp;
                flag = true;    // 有数据交换
            }
        }
        if(!flag) break;
    }
}
```
:::

- 稳定：当相邻元素大小相等时，不做交换。
- 时间复杂度：
    - 最好：已经有序，一次冒泡，$O(n)$
    - 最坏：倒序，n次冒泡，$O(n^{2})$
    - 平均：$O(n^{2})$
        - 有序度 & 逆序度、满序度
        - 分析：冒泡排序有两个原子操作（比较和交换）。每交换一次，有序度加 1。$交换次数 = 逆序度 = \frac{n(n-1)}{2}-初始有序度$。最坏情况下，初始有序度是 0，需要进行 $\frac{n(n-1)}{2}$ 次交换。最好情况下初始有序度是 $\frac{n(n-1)}{2}$，不需要进行交换。平均情况下，取中间值 $\frac{n(n-1)}{4}$。比较操作肯定比交换操作多，复杂度的上限是 $O(n^{2})$，所以平均情况下的时间复杂度是 $O(n^{2})$


### 1.2 Insertion Sort

将数组中的元素分为两个区间：**已排序区间**和**未排序区间**。取未排序区间中的元素，在已排序区间中找到合适的位置将其插入，直到未排序区间为空。其中，初始已排序区间是数组的第一个元素。

比较 + 移动。将未排序区间的一个元素插入已排序空间时，需要与已排序空间的元素依次比较大小，找到合适的位置插入，插入点之后的元素都需要往后移动腾出位置。

移动的次数是固定的，等于逆序度。

:::details 代码
```c
public void insertionSort(int[] a, int n) {
    if (n <= 1) return;

    for (int i = 1; i < n; ++i) {
        int value = a[i];
        int j = i - 1;

        // 查找插入位置
        for (; j >= 0; --j) {
            if (a[j] > value) {
                a[j+1] = a[j];      // 移动数据
            } else {
                break;
            }
        }

        a[j+1] = value;     // 插入数据
    }
}
```
:::

- 稳定：注意将元素插到相同元素的后面。
- 时间复杂度：
    - 最好：有序，每次进行一次比较就可以确定插入位置，没有移动。$O(n)$
    - 最坏：倒序。$O(n^{2})$
    - 平均：$O(n^{2})$
        - 分析：在数组中插入一个元素的时间复杂度是 $O(n)$，循环执行 n 次插入操作，平均时间复杂度是 $O(n^{2})$


### 1.3 Selection Sort

分排序空间和未排序空间。每次从未排序区间中找到最小的元素，将其放到已排序区间的末尾（与插入点位置的元素交换）。

:::details 代码
```c
public void selectionSort(int[] a, int n) {
    if (n <= 1) return;

    for (int i = 0; i < n - 1; ++i) {
        int min = i;
        for (int j = i + 1; j < n; ++j) {
            if (a[j] < a[min]) {
                min = j;
            }
        }

        // 交换
        if (min != i) {
            int tmp = a[min];
            a[min] = a[i];
            a[i] = tmp;
        }
    }
}
```
:::

- 不稳定：找到最小值和目标位置做交换，这个交换的操作决定了它是不稳定的。
- 时间复杂度：最好、最坏、平均都是 $O(n^{2})$。因为需要遍历找到最小元素，找到最小元素的时间复杂度是 $O(n^{2})$。


### 1.4 小结

冒泡和插入排序都是稳定的，选择排序不稳定。

对于冒泡和插入，它们的时间复杂度都是  $O(n^{2})$，都是原地排序，且都可以稳定。但是插入排序更受欢迎。

无论怎么优化，冒泡排序的元素交换次数是固定值，插入排序的元素移动次数也是固定值，数值上等于数组初始状态的逆序度。但是从代码上看，冒泡排序要进行 3 个赋值操作，而插入排序只需要一个。

```c
// 冒泡中元素交换
if (a[j] > a[j+1]) {
    int tmp = a[j];
    a[j] = a[j+1];
    a[j+1] = tmp;
    flag = true;
}

// 插入排序中的元素移动
if (a[j] > value) {
    a[j+1] = a[j];
} else {
    break;
}
```

||原地|稳定|最好|最坏|平均|
|:--|:--:|:--:|:--:|:--:|:--:|
|冒泡排序|&check;|&check;|$O(n)$|$O(n^{2})$|$O(n^{2})$|
|插入排序|&check;|&check;|$O(n)$|$O(n^{2})$|$O(n^{2})$|
|选择排序|&check;|&cross;|$O(n^{2})$|$O(n^{2})$|$O(n^{2})$|


## 2. 归并排序 & 快速排序

归并排序和快速排序都用到了分治思想。

### 2.1 Merge Sort

将数组分成前后两部分，对两部分分别排序，再将排好序的两部分合并在一起，整个数组就有序了。

归并排序使用的是分治思想，将大问题分解成小的子问题，子问题解决了，大问题也就解决了。分治算法一般都用递归来实现。分治是一种处理思想，而递归是一种编程技巧。

先写递推公式：
```
merge_sort(p, r) = merge(merge_sort(p, q), merge_sort(q+1, r))

终止条件：p >= r
```

:::details 代码
```c
void merge_sort(int[] arr, int n) {
    merge_sort_process(arr, 0, n-1)
}

void merge_sort_process(int[] arr, int l, int r) {
    if ( l >= r) return;

    mid = (l + r)/2;
    merge_sort_process(arr, p, mid);
    merge_sort_process(arr, mid+1, r);

    // 将 arr[l..mid] 和 arr[mid+1...r] 合并
    merge(arr, l, mid, r)
}

void merge(int[] arr, l, mid, r) {
    int[] tmp = new int[r-l+1];
    int i = 0;
    int p = l;
    int q = m+1;

    while(p <= mid && q < r) {
        tmp[i++] = arr[p] <= arr[q] ? arr[p++] : arr[q++];
    }

    while(p <= mid) {
        tmp[i++] = arr[p++];
    }
    while(q < r) {
        tmp[i++] = arr[q++];
    }

    for(i = 0; i < r-l+1; ++i) {
        arr[l+i] = tmp[i];
    }
}
```
:::

- 稳定：取决于 `merge` 函数
- 空间复杂度：$O(n)$
- 时间复杂度：任何情况下都是 $O(n log n)$
> 快速排序最差情况下的时间复杂度是 $O(n^{2})$，但是归并排序并没有快排那样应用广泛。主要原因是，归并排序不是原地排序算法。

:::tip 递归代码的时间复杂度分析

将问题 a 分解成子问题 b 和 c。问题 b 和 c 解决了在把二者的结果合并成 a 的结果。

$$
T(a) = T(b) + T(c) + K
$$

其中 K 是将子问题的结果合并成问题 a 的结果所消耗的时间。

对于归并排序，n 个元素所需要的时间是 $T(n)$，分解成两个子数组排序的时间都是 $T(\frac{n}{2})$。`merge()` 合并两个有序子数组的时间复杂度已知是 $O(n)$。

$$
\begin{aligned}
n = 1 时，T(1)    &= C; \\
n > 1 时，T(n)    &= 2 \times T(\frac{n}{2}) + n;\\
        &= 2 \times (2 \times T(\frac{n}{4}) + n/2) + n        = 4 \times T(\frac{n}{4}) + 2 \times n \\
        &= 4 \times (2 \times T(\frac{n}{8}) + n/4) + 2 \times n    = 8 \times T(\frac{n}{8}) + 3 \times n \\
        & ... \\
        &= 2^{k} \times T(\frac{n}{2^{k}}) + k \times n \\
\end{aligned}
$$

当 $k = log_{2}{n}$ 时，$T(\frac{n}{2^{k}}) = T(1)$，带入上式得，$T(n) = Cn + n log_{2}{n}$。用大 O 标记法表示为 $O(n log n)$。

:::


### 2.2 Quick Sort

也是分治。选取要排序数组中的任意一个元素最为 pivot（分区点），遍历数组，将小于 pivot 的放在左边，将大于 pivot 的放在右边。然后，我们分别排序 pivot 左边的数据和 pivot 右边的数据，直到区间缩小为 1。

递推公式：
```
quick_sort(l, r) = quick_sort(l, p-1) + quick_sort(p+1, r)

终止条件：l >= r
```

:::details 代码
```c
void quick_sort(int[] arr, n) {
    quick_sort_process(arr, 0, n-1);
}

void quick_sort_process(int[] arr, l, r) {
    if (l >= r) return;

    // 分区，并返回分区点
    int p = partition(arr, l, r);
    quick_sort_process(arr, l, p-1);
    quick_sort_process(arr, p+1, r);
}

void partition(int[] arr, int l, int r) {
    // 以最后一个元素作为分区的界限
    int pivot = arr[r];

    int i = l;
    for (int j = l; j < r; ++j) {
        if (arr[j] < pivot) {
            swap(arr[i], arr[j]);
            i++;
        }
    }

    swap(arr[i], arr[r]);
    return i;
}
```
对于 `partition()` 函数，i 就是在遍历数组，它表示的是小于 pivot 的下标。每次遇到下雨 pivot 的元素，都会跟 a[i] 交换，即 a[i] 存放小于 pivot 的数据。
:::

- 不稳定
- 空间复杂度：原地，$O(n)$
- 时间复杂度：$O(n log n)$
    - 最好：$O(n log n)$。分区平衡，大概满足 $T(n) = 2 \times T(\frac{n}{2}) + n$
    - 最差：$O(n^{2})$。原数组有序，每次选择最后一个元素作为 pivot，需要进行大概 n 次分区，每次分区平均要扫描约 $\frac{n}{2}$ 个元素。这时快排的时间复杂度就从 $O(n log n)$ 退化到了 $O(n^{2})$。
    - T(n) 在大部分情况下都可以做到 $O(n log n)$，只有在极端情况下，才会退化到 $O(n^{2})$。

### 2.3 比较

归并排序和快速排序用的都是分治思想。它们的区别在于：归并排序的处理过程是由下到上的，先处理子问题，然后再合并；而快排是由上到下的，先分区，然后再处理子问题。

**Q**：利用分治思想解决非排序问题。如何在 $O(n)$ 时间复杂度内查找一个无序数组中的第 K 大元素。

**A**：选取最后一个元素做 pivot，进行原地分区，数组被分为三部分，arr[0...p], arr[p], arr[p+1...n-1]。如果 p+1 == k，那么 arr[p] 就是第 K 大的元素。如果 p+1 < K，那么到 arr[p+1...n-1] 中继续递归查找；如果 p+1 > K，那么到 arr[0...p] 中递归查找。

**时间复杂度分析**：第一次需要遍历 n 个元素进行分区操作。下一次分区时，只需要对 n/2 个元素进行遍历。以此类推，直到区间缩小为 1。$n+\frac{n}{2}+\frac{n}{4}+\frac{n}{8}+...+1 = 2n-1$。即时间复杂度是 $O(n)$。


## 3. 线性排序：桶排序、计数排序、基数排序

### 3.1 Bucket sort

时间复杂度：n 个数据，m 个桶，平均每个桶 k = n/m 个数据。在每个桶中使用快排，在每个桶中的复杂度为 $O(k log k)$。则所有数据的时间复杂度就是 $O(m\times k log k) = n log \frac{n}{m}$。当桶的个数 m 接近数据个数 n 时，$log (\frac{n}{m})$ 就是一个非常小的常量，这时桶排序的时间复杂度接近于 $O(n)$。

使用条件很苛刻：
- 要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。
- 数据在各个桶之间的分布是比较均匀的。极端情况下，如果数据都被划分到一个桶里，那就退化为 $O(n log n)$ 的排序算法了。

桶排序比较适合用在外部排序中。即数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。


### 3.2 Counting sort

计数排序算是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。

:::details 代码
```c
// 数组 a 中都是非负数
public void countingSort(int[] a, int n) {
    if (n <= 1) return;

    // 确定数据范围
    int max = a[0];
    for (int i = 1; i < n; ++i) {
        if (max < a[i]) {
            max = a[i];
        }
    }

    // 申请数组，赋初值 0
    int[] c = new int[max + 1];
    for (int i = 0; i <= max; ++i) {
        c[i] = 0;
    }

    // 遍历数组 a，用 c 记录每个元素的个数
    for (int i = 0; i < n; ++i) {
        c[a[i]]++;
    }

    // 对 c 累加
    for (int i = 1; i <= max; ++i) {
        c[i] = c[i] + c[i - 1];
    }

    // 对 a 数组排序之后的数组
    int[] tmp = new int[n];

    // 从后向前遍历，以保证计数是稳定的
    for (int i = n - 1; i >= 0; --i) {
        int index = c[a[i]] - 1;
        tmp[index] = a[i];
        c[a[i]] --;
    }

    // 将结果拷贝到 a
    for (int i = 0; i < n; ++i) {
        a[i] = tmp[i];
    }
}
```
:::

计数排序只能用在数据范围不大的场景中，如果数据范围 k 要比排序的数据 n 大很多，就不适合用计数排序了。

而且，计数排序只能对非负数进行排序。对于其他类型，要将其转化为非负整数。


### 3.3 Radix sort

根据每一位来排序，可以用桶排序或计数排序，时间复杂度可以做到 $O(n)$。如果要排序的数据有 k 位，那么就需要 k 次桶排序或者计数排序，总的时间复杂度是 $O(kn)$，k 不大时，基数排序的复杂度就近似于 $O(n)$。


## 4. 实现通用、高性能的排序函数

||时间复杂度|稳定|原地|
|:--|:--:|:--:|:--:|
|冒泡排序|$O(n^{2})$|&check;|&check;|
|插入排序|$O(n^{2})$|&check;|&check;|
|选择排序|$O(n^{2})$|&cross;|&check;|
|归并排序|$O(n log n)$|&check;|&cross;|
|快速排序|$O(n log n)$|&cross;|&check;|
|桶排序|$O(n)$|&check;|&cross;|
|计数排序|$O(n+k)$ k 是数据范围|&check;|&cross;|
|基数排序|$O(dn)$ d 是维度|&check;|&cross;|


线性排序的使用场景特殊。小规模数据的排序可以用时间复杂度为 $O(n^{2})$ 的算法。为了兼顾任意规模数据排序，一般都会选择时间复杂度是 $O(n log n)$ 的排序算法。比如 Java 中采用堆排序来实现排序函数，C 语言使用快速排序来实现排序函数。

### 优化排序

快速排序在最坏情况下的时间复杂度是 $O(n^{2})$，我们要尽量避免。最坏情况出现的主要原因是分区点选得不够合理。最理想的分区点应该使得两个分区中的数据数量差不多多。

下面是 2 个常用的比较简单的分区算法：

1. 三数取中法

从区间的首、尾、中分别取出一个数，选择这三个数的中间值作为分区点。这样肯定比只取某一个数据好。如果排序的数组比较大，可能要“五数取中”、“十数取中”。

2. 随机法

每次从要排序的区间中随机选择一个元素作为分区点。虽然不能保证每次分区点都选得很好，但是也不大可能出现每次分区点都选得很差的情况。

