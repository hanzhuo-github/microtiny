---
lang: zh-CN
title: 跳表
description:
article: false
date: 2023-08-28
---

跳表（Skip List）是一种各方面性能都比较优秀的动态数据结构，可以支持快速的插入、删除、查找操作，写起来也不复杂，甚至可以代替红黑树（Red-black Tree）。

## 1. 跳表

跳表类似于在链表中实现二分查找。在链表中进行查找时，只能从头到尾遍历链表，这样的查找效率很低，时间复杂度是 $O(n)$。

<div align=center width=100%>
    <img src="/images/code/ds/skip-list.png" style="width:50%"/>
</div>

如果我们能在链表上建立“索引”，查找起来会快一些。每两个结点提取一个结点到上一级，把抽出来的那一级叫做**索引**或**索引层**。其中 down 指针指向下一级的结点。

## 2. 时间复杂度 $O(log n)$

每两个结点抽出一个结点作为上一级索引的结点。那么第一级索引的结点个数是 $\frac{n}{2}$，第二级 $\frac{n}{4}$，...，$\frac{n}{2^{k}}$。

最高级的索引有 2 个节点，则索引有 $log_{2}{n} - 1$ 级，加上原始链表一共 $log_{2}{n}$ 层。如果每一层都要遍历 m 个结点，则在跳表中查询一个数据的时间复杂度就是 $O(m log n)$。

每一级最多只需要遍历 3 个结点，于是 m=3。所以在跳表中查询任意数据的时间复杂度就是 $O(log n)$

## 3. 空间复杂度 $O(n)$

- 每层的结点数：$\frac{n}{2}, \frac{n}{4}, \frac{n}{8}, ..., 8, 4, 2$。
- 结点的总和：$\frac{n}{2} + \frac{n}{4} + \frac{n}{8} + ... + 8 + 4 + 2 = n - 2$。

我们需要额外接近 n 个结点的存储空间。

如果每 3 个结点取一个索引，那么总的索引数大概是 $\frac{n}{3} + \frac{n}{9} + \frac{n}{27} + ... + 9 + 3 + 1 = \frac{n}{2}$。比每两个结点抽一个结点作为索引要减少了一般的索引结点存储空间。

实际上，在软件开发中，我们不必太在意索引占用的额外空间。在讲数据结构和算法时，我们习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。


## 4. 高效的动态插入和删除（$O(log n)$）

查到对应的位置，进行插入。

<div align=center>
    <img src="/images/code/ds/insert-skip-list.png" style="width:50%;" />
</div>

删除时要注意，如果要删除的结点也在索引中，那么索引中的结点也要跟着删除。

## 5. 跳表索引动态更新

当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。

作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。

跳表是通过随机函数来维护前面提到的“平衡性”。

当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。我们通过一个随机函数，来决定将这个结点插入到哪几级索引中。


