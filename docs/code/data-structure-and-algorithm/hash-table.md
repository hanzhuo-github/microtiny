---
lang: zh-CN
title: 散列表
description:
article: false
date: 2023-09-06
---

我们也称散列表为哈希表或 hash 表。它利用数组支持按照下标随机访问数据的特性，是数组的一种扩展。

键（key）、散列函数（hash 函数、哈希函数）、散列值（hash 值、哈希值）

hash 函数设计的基本要求：
1. hash 函数计算得到的 hash 值是一个非负整数
2. 如果 key1 = key2，那么 hash(key1) = hash(key2)
3. 如果 key1 ≠ key2，那么 hash(key1) ≠ hash(key2)

但是在实际中，无法完全避免散列冲突。

## 1. 解决散列冲突的方法

### 1.1 开放寻址法（open addressing）

核心思想：如果出现了冲突，就重新探测一个空闲位置将元素插入。

如何探测？

#### 1.1.1 线性探测（Linear Probing）

核心思想：经过散列函数得到的散列值对应的位置已经被占用了，那么就从当前位置开始，依次向后查找，直到找到空闲位置。

查找元素时，比较下标为散列值的元素和要查找的元素。如果相等，则说明该元素就是要找的元素；否则就依次往后找。如果遍历到数组中的空闲位置仍然没找到，就说明要查找的元素没有在散列表中。

删除操作时，不能简单地只把要删除的元素设置为空。如果简单地设置为空，那么在下次查找某个元素时，可能查到该位置时，就判定该元素不在散列表里（实际上这个空的位置是我们后来删除的）。我们可以将删除的元素，特殊标记为 `deleted`。当线性探测查找时，遇到标记为 `deleted` 不要停下来，继续向下探测。

线性探测的缺点：当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置越来越少，线性探测的时间就会越来越久。极端情况下需要探测整个散列表，即最坏情况下的时间复杂度为 $O(n)$。

#### 1.1.2 二次探测（Quadratic probing）

二次探测，跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 $hash(key)+0$，$hash(key)+1$，$hash(key)+2$，...。而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 $hash(key)+0$，$hash(key)+1^{2}$，$hash(key)+2^{2}$，...。

#### 1.1.3 双重散列（Double hashing）

使用一组 hash 函数 hash1(key)，hash2(key)，hash3(key), ...。我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。

---
不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用**装载因子**（load factor）来表示空位的多少。

```:no-line-numbers
散列表的装载因子 = 填入表中的元素个数/散列表的长度
```

装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。

### 1.2 链表法（chaining）

更常用的散列冲突解决办法，相比开放寻址法更简单。

如下图，每个“桶”（bucket）或“槽”（slot）都对应一条链表，所有散列值相同的元素都放到相同曹伟对应的链表中。

<div align=center>
    <img src=/images/code/ds/chaining.png width=50%/>
</div>

插入 $O(1)$。查找、删除的时间复杂度跟链表的长度 k 成正比，即 $O(k)$。对于散列表叫均匀的散列函数，理论上来讲 $k=n/m$，n 表示散列中数据的个数，m 表示散列表中“槽”的个数。


## 2. 打造一个工业级水平的散列表

### 2.1 如何设计？

- 散列函数不能太复杂 -> 计算复杂 -> 间接影响散列表的性能
- 散列函数生成的值要尽可能随机且均匀分布 -> 避免或最小化散列冲突。即便出现冲突，散列到每个槽里的数据也会比较平均。

- 动态扩容 & 动态缩容
    - 动态扩容

        当装载因子过大时，也可以进行**动态扩容**，重新申请一个更大的散列表，将数据搬移到新的散列表中。如果每次扩容都申请一个原来散列表大小两倍的空间，原来装载因子为 0.8，则扩容之后的装载因子就下降为原来的一半，变成了 0.4。

        插入一个数据，最好情况下，不需要扩容，最好时间复杂度是 $O(1)$。最坏情况下，散列表装载因子过高，启动扩容，我们需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度是 $O(n)$。用摊还分析法，均摊情况下，时间复杂度接近最好情况，就是 $O(1)$。

    - 动态缩容
        实际上，对于动态散列表，随着数据的删除，散列表中的数据会越来越少，空闲空间会越来越多。如果我们对空间消耗非常敏感，我们可以在装载因子小于某个值之后，启动**动态缩容**。当然，如果我们更加在意执行效率，能够容忍多消耗一点内存空间，那就可以不用费劲来缩容了。

    - “一次性”扩容？
        有时，“一次性”扩容的开销会让用户崩溃，这是我们可以将扩容操作穿插在插入操作的过程中。

- 如何选择冲突解决方法？

    Java 中 LinkedHashMap 采用的是链表法解决冲突，ThreadLocalMap 通过线性探测的开放寻址法来结局冲突。

    - 开放寻址法
        - 优点：
            - 数据都存在数组中，可以有效利用 CPU 缓存加快查询进度。
            - 序列化比较简单。链表法包含指针，序列化起来没那么容易。
        - 缺点：
            - 删除数据时你叫麻烦，需要特殊标记已经删除的数据
            - 由于所有数据都存储在一个数组中，于是相比链表法，其冲突的代价更高 -> 装载因子的上限不能太大 -> 更浪费内存空间
        - 应用：当数据量比较小、装载因子小时，适合采用开放寻址法。

    - 链表法
        - 优点：
            - 对内存的利用率比开放寻址法要高。
            - 对大装载因子的容忍度更高。开放寻址法只适用装载因子小于1的情况。
        - 缺点：
            - 链表要存指针，所以对于比较小的对象的存储，比较消耗内存，还有可能让内存的消耗翻倍。
            - 链表中的结点是零散分布在内存中的（非连续），所以对 CPU 缓存不友好。
        - 应用
            - 实际上，我们对链表法稍加改造，可以实现一个更加高效的散列表。那就是，我们将链表法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树。这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是 O(logn)。这样也就有效避免了前面讲到的散列碰撞攻击。
            - 比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。

### 2.2 工业级散列表

Java 中的 HashMap。

#### 2.2.1 初始大小

HashMap 默认的初始的大小是 16。

这个默认值是可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高 HashMap 的性能。

#### 2.2.2 装在因子和动态扩容

最大装载因子默认是 0.75，当 HashMap 中元素个数超过 0.75 * capacity 时，就会扩容，每次扩容为原来的两倍大小。

#### 2.2.3 散列冲突解决方法

HashMap 底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 HashMap 的性能。

于是，在 JDK1.8 版本中，为了对 HashMap 做进一步优化，我们引入了红黑树。而当链表长度太长（默认超过 8）时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点，提高 HashMap 的性能。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。


#### 2.2.4 散列函数

```java
int hash(Object key) {
    int h = key.hashCode()；
    return (h ^ (h >>> 16)) & (capicity -1); //capicity表示散列表的大小
}
```

其中，hashCode() 返回的是 Java 对象的 hash code。比如 String 类型的对象的 hashCode() 就是下面这样：

```java
public int hashCode() {
  int var1 = this.hash;
  if(var1 == 0 && this.value.length > 0) {
    char[] var2 = this.value;
    for(int var3 = 0; var3 < this.value.length; ++var3) {
      var1 = 31 * var1 + var2[var3];
    }
    this.hash = var1;
  }
  return var1;
}
```




