---
lang: zh-CN
title: 递归
description:
article: false
date: 2023-08-21
---

## 递归需要满足的 3 个条件

- 一个问题的解可以分解为几个子问题的解
- 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
- 存在递归终止条件


## 如何编写递归代码

关键在于**写出递推公式，找到终止条件**。

例题：有 n 个台阶，每次可以跨 1 个或 2 个台阶，请问走 n 个台阶有多少种走法？

分析：可以把第一个的走法分为两类，第一类是第一步走了 1 个台阶，另一类是第一步走了 2 个台阶。所以 n 个台阶的走法就等于先走 1 阶后，n - 1 个台阶的走法，加上先走 2 阶后，n - 2 个台阶的走法：$f(n)=f(n-1)+f(n-2)$。

终止条件：$f(1)=1, f(2)=2$

最终代码：
```c
int f(int n) {
    if (n == 1) return 1;
    if (n == 2) return 2;
    return f(n-1) + f(n-2);
}
```


## 递归代码要警惕堆栈溢出

函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。

我们可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。当递归调用超过一定深度之后，就不再向下递归了，直接返回报错。

```c
// 全局变量，表示递归的深度。
int depth = 0;

int f(int n) { 
    ++depth； 
    if (depth > 1000) throw exception; 
    if (n == 1) return 1; 
    return f(n-1) + 1;
}
```

但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如 10、50，就可以用这种方法，否则这种方法并不是很实用。

## 警惕重复计算

上面爬台阶的例子中，计算 f(5) = f(4) + f(3)，但是在计算 f(4) = f(3) + f(2) 时，也计算了 f(3)。这就是重复计算问题。

为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先去散列表中取，没有对应的值再进行计算。这样就可以避免重复计算的问题了。

```c
public int f(int n) {
    if (n == 1) return 1;
    if (n == 2) return 2;

    if (hasSolvedList.containsKey(n)) {
        return hasSolvedList.get(n)
    }

    int ret = f(n-1) + f(n-2);
    hasSolvedList.put(n, ret);
    return ret;
}
```

:::warning
由于递归需要在内存栈中进行压栈出栈操作，当调用栈比较深时，需要考虑这部分的时间开销。另外，空间上也要考虑压栈出栈的开销。
:::

## 将递归代码改为非递归代码

递归：
- 优点：代码易理解，写起来很简洁。
- 缺点：空间复杂度高，有堆栈溢出的风险，存在重复计算、过多的函数调用会耗时等问题。

所有的递归代码都可以改为迭代循环的非递归写法。实际上是将递归改为了“手动”递归，本质并没有改变。

```c
int f (int n) {
    if (n == 1) return 1;
    if (n == 2) return 2;

    int ret = 0;
    int pre = 2;
    int prepre = 1;
    for (int i = 3; i <= n; ++1) {
        ret = pre + prepre;
        prepre = pre;
        pre = ret;
    }
    return ret;
}
```
