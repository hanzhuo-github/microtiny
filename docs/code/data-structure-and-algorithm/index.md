---
lang: zh-CN
title: introduction
description:
article: false
date: 2023-08-18
---


## 复杂度分析

### 时间复杂度 & 空间复杂度

（渐进）时间复杂度量级：
$T(n) = O(f(n))$，`O` 表示执行时间 T(n) 与 f(n) 成正比

- 多项式量级
    - 常量阶 $O(1)$
    - 对数阶 $O(log n)$
        ```c
        i = 1;
        while (i < n) {
            i = i * 2;
        }
        ```
    - 线性阶 $O(n)$
    - 线性对数阶 $O(n log n)$
        如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 $O(n log n)$ 了。如归并排序、快速排序。
    - 平方阶 $O(n^{2})$、立方阶 $O(n^{3})$、...、 k 次方阶 $O(n^{k})$
- 非多项式量级
    - 指数阶 $O(2^{n})$
    - 阶乘阶 $O(n!)$


（渐进）空间复杂度：常见 $O(1)$、$O(n)$、$O(n^{2})$

### 最好、最坏、平均、均摊时间复杂度

#### 1. 最好情况时间复杂度（best case time complexity）、最坏情况时间复杂度（worst case time complexity）

```cpp
// 在给定数组 array 中找指定元素 x
int find(int[] array, int n, int x) {
    int i = 0;
    int pos = -1;
    for (; i < n; ++i) {
        if (array[i] == x) {
            pos = i;
            break;
        }
    }
    return pos;
}
```

如果我们要找的元素刚好是数组的第一个元素，那么循环只执行 1 步，时间复杂度就是 $O(1)$；如果数组中没有该元素，那么需要将整个数组遍历一遍，时间复杂度就是 $O(n)$。

上面对应的就是最好情况时间复杂度和最坏情况时间复杂度。

#### 2. 平均情况时间复杂度（average case time complexity）

最好情况和最坏情况都是极端情况下的代码复杂度，于是又引入了平均情况时间复杂度，简称平均时间复杂度。

还是上面查找元素在数组中的位置，有 $n+1$ 种情况：在数组中（n 种）以及不在数组中。把每种情况下要遍历的元素的个数累加起来再除以 $n+1$，就可以得到需要遍历元素个数的平均值：
$$
\frac{1+2+3+...+n+n}{n+1} = \frac{n(n+3)}{2(n+1)} ~ O(n)
$$

如果我们从概率的角度分析，假设在数组中的概率和不在数组中的概率都是 $\frac{1}{2}$，那么出现在每个位置的概率为 $\frac{1}{2n}$，计算加权平均（期望）。于是平均时间复杂度的全称是**加权平均时间复杂度**或**期望时间复杂度**。

$$
1\times\frac{1}{2n}+2\times\frac{1}{2n}+3\times\frac{1}{2n}+...+n\times\frac{1}{2n}+n\times\frac{1}{2} = \frac{3n+1}{4}
$$

只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。

#### 3. 均摊时间复杂度（amortized time complexity）

摊还分析：对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。

