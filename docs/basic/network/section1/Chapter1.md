---
lang: zh-CN
title: 第二层到第三层
description:
article: false
date: 2023-08-24
---

## 1. 物理层 & MAC 层

### 1.1 第一层（物理层）

设备：集线器（Hub），广播

### 1.2 第二层（数据链路层）

#### MAC（Medium Access Control，媒体访问控制）

- 解决的是谁先发谁后发的问题，学名是**多路访问**。有很多算法解决这个问题：
    1. 信道划分：分多个道，你走你的，我走我的
    2. 轮流协议：轮着来
    3. 随机接入协议（以太网就用的这种方式）：管他三七二十一，先出门，堵的话就回去
- 判断发给谁，谁接收
    - 链路层地址，即 MAC 地址
    - 第二层的网络包格式：
        |目标 MAC<br>（6 bytes）|源 MAC<br>（6 bytes）|类型<br>（2 bytes）|数据<br>（46-1500 bytes）|CRC<br>（4 bytes）|
        |:-:|:-:|:-:|:-:|:-:|

        - 类型：0800 - IP 数据报，0860 - ARP 请求
        - CRC 循环冗余检测：通过 XOR 异或来计算整个包是否在发送的过程中出现了了错误
    - 有了目标 MAC 地址，数据包在链路上广播，MAC 的网卡发现这个包是给它的，于是把包收进来。接着打开 IP 包，发现 IP 包也是自己的，再打开 TCP 包，发现端口是 80，nginx 就是监听的 80。于是将请求提交给 nginx，nginx 返回一个网页。

#### ARP 协议

问题：如果一个广播网络里面接入了 N 台机器，怎么知道每台机器的 MAC 地址呢？

答案：ARP 协议 - 根据 IP 地址找 MAC 地址的协议。这是一个输出全靠“吼”的阶段。

|目标 MAC<br>（6 bytes）|源 MAC<br>（6 bytes）|类型<br>（2 bytes）|ARP 报文|
|:-:|:-:|:-:|:-:|

过程：要发送数据的机器发送一个广播包，等目的 IP 对应的机器来回应自己。

ARP 报文格式：
|硬件类型<br>（Ethernet）|协议类型<br>（IP）|硬件地址长度<br>（6）|协议地址长度<br>（6）|操作代码<br>（1 request 2 reply）|发送者 MAC|发送者 IP|目标 MAC|目标 IP|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|

ARP 缓存：为了避免每次都用 ARP 请求，机器本地也会进行 ARP 缓存。由于机器会不断上线下线，IP 也可能会变，所以 ARP 的 MAC 地址缓存过一段时间就会过期。

#### 交换机 & 转发表

机器数少的时候，我们可以用集线器组网。集线器是广播的，每个端口不管是否需要该包，都会接收然后发给主机，然后让主机自己判断是否需要。当机器数多的时候，端口什么都接受什么都转发的话，会更容易产生冲突，而且把不需要的包转发出去纯属浪费。

我们需要稍微智能一点的设备，该设备每个口可以解析 MAC 头，检查下目标 MAC 地址，然后根据策略进行转发。即第二层设备：交换机。

交换机如何知道每个口的电脑的 MAC 地址呢？需要交换机会学习，学习的结果就是**转发表**。

电脑 A 向电脑 B 发送一个包，当包到达交换机时，最开始交换机并不知道电脑 B 在哪个口，于是它只能将包发送给除了连接电脑 A 口以外的其他口。交换机聪明之处在于，它会记住，电脑 A（对应的MAC）在哪个口。以后遇到目的地址是电脑 A 的 MAC 地址时，直接发送到对应的口就行。

这样过了一段时间之后，交换机就有了整个网络的结构了，这时基本不用广播了，可以准确转发。


## 2. 交换机与 VLAN


下图是两台交换机连接三个局域网的情况。

<div align=center>
    <img src=/images/basic/network/section1/Lan.png width=50%/>
</div>

当机器 1 向机器 4（已知其 IP）发送包的时候，目的 MAC 还不知道，所以需要先用 ARP 获取目的 MAC。

:::details 简述交换机学习网络拓扑信息的过程
现在两台交换机都不了解网络的任何拓扑信息。

机器 1 发起广播。机器 2 能收到，但是没它啥事。交换机 A 也收到了这个广播，此时它不知道网络的拓扑信息，于是它将该广播包转发给除了广播包来的方向之外的其他所有网口。

机器 3 也收到了信息，但是这和它也没啥关系。交换机 B 同样收到了该广播包，它也不知道网络的拓扑信息，于是它也按照广播策略将包转发到 LAN 3。此时，机器 4 和机器 5 都能收到广播信息。机器 4 主动响应，这是找我的，我的 MAC 是 blabla。于是一个 ARP 请求就完成了。

在上面的过程中，两台交换机都学到了这样的信息：机器 1 是在左边的网口。

下次当机器 2 要访问机器 1 时，先通过 ARP 获取机器 1 的 MAC 地址。知道目的 MAC 后，发送数据包。该消息会到达机器 1，也会到交换机 A。交换机已经知道了机器 1 不在右边的网口，于是这个广播信息不会广播到 LAN 2 和 LAN 3。
:::

### 环路问题 & STP 协议

环路问题会导致 ARP 请求爆炸，且交换机无法学习到网络的拓扑结构。

数据结构中有**最小生成树**，有环的我们常称为**图**。将图中的环破坏了，就生成了**树**。计算机网络中生成树算法是STP（Spanning Tree Protocol）。

<div align=center>
    <img src=/images/basic/network/section1/stp.png width=50%/>
</div>

STP 中的概念：
- Root Bridge，根交换机
- Designated Bridge，指定交换机
- Bridge Protocol Data Unit，BPDU，网桥协议数据单元。“互相比较实例”的协议。只有 Root Bridge 可以发，其他交换机只能转发 Root Bridge 的消息。
- Priority Vector，优先级向量。`[Root Bridge ID, Root Path Cost, Bridge ID, Port ID]`。在 BPDU 中。

#### STP 的工作过程

网络管理员为所有的交换机分配了优先级。交换机通过互相发送 BPDU 来判断谁的优先级更高。

具体过程这里不介绍了。

### 广播问题 & 安全问题

**物理隔离**：使用单独的交换机配置单独的子网

**虚拟隔离**，**虚拟局域网（VLAN）**：一个交换机上会连属于多个局域网的机器。

交换机如何区别某个机器属于哪个局域网呢？在原来的二层的头上加一个 TAG，里面有一个 VLAN ID，一共12位（可以划分 4096 个 VLAN）。这样仍然不够，目前云计算厂商例绝对不止 4096 个用户。当然每个用户需要一个 VLAN，后面章节再讲这个问题。

<div align=center>
    <img src=/images/basic/network/section1/vlan.png width=50%/>
</div>

如果我们使用的交换机是支持 VLAN 的，当交换机把二层的头取下来时就可以识别 VLAN ID。这样，只有相同 VLAN 的包才会互相转发，不同 VLAN 的包是看不到的。

对于支持 VLAN 的交换机，有一种口叫 Trunk 口。它可以转发属于任何 VLAN 的数据，交换机之间可以通过这种口互相连接。

<div align=center>
    <img src=/images/basic/network/section1/trunk.png width=50%/>
</div>



## 3. ICMP 与 ping

### ICMP

ping 基于 ICMP 协议（Internet Control Message Protocol, 互联网控制报文协议）工作。ICMP 用来监测网络通信故障、实现链路追踪，最典型的应用就是 ping 和 traceroute。它要解决 IP 肯呢个出现的不可靠问题，属于 IP 的组成部分。

ICMP 是网络层的协议，所以 ICMP 报文是封装在 IP 包里的。IP包有两部分：IP头 + 正文（这里是 ICMP 报文）。其中 IP 分组头中，协议字段为 1，表示数据部分是 ICMP 报文。

ICMP 报文前 4 格式统一：

|类型<br>（1B）|代码<br>（1B）|校验和<br>（2B）|与类型值相关<br>（4B）|ICMP 数据部分|
|:-:|:-:|:-:|:-:|:-:|


:::details ICMP 报文类型
<table>
    <tr><th>ICMP 报文大类</th><th>类型值</th><th>ICMP 报文类型</th></tr>
    <tr><td rowspan="5">差错报告报文</td><td>3</td><td>目的不可达</td></tr>
    <tr><td>4</td><td>源抑制</td></tr>
    <tr><td>5</td><td>超时</td></tr>
    <tr><td>11</td><td>参数问题</td></tr>
    <tr><td>12</td><td>重定向</td></tr>
    <tr><td rowspan="4">询问报文</td><td>8 或 0</td><td>回送请求和应答</td></tr>
    <tr><td>13 或 14</td><td>时间戳请求和应答</td></tr>
    <tr><td>15 或 16</td><td>路由器询问与通告</td></tr>
    <tr><td>17 或 18</td><td>地址掩码请求和应答</td></tr>
</table>

- 查询报文：

    - 目的不可达报文主要有以下 7 种类型：
        - 网络不可达（network unreachable）：表示路由器寻址出错，下一跳路由器可能存在故障。网络不可达报文只能由路由器产生。代码 0 表示网络不可达。
        - 主机不可达（host unreachable）：表示网络寻址不存在问题，可能是目的主机不工作或不存在。主机不可达报文只能由路由器产生。代码 1 表示主机不可达。
        - 协议不可达（protocol unreachable）：IP 分组携带的数据来自高层协议，例如 UDP、TCP、OSPF 等。如果目的主机接收分组的数据字段来自 TCP，但是目的主机的 TCP 未运行，这时目的主机不能处理 IP 分组携带的 TCP 数据，则主机将产生一个协议不可达报文，通知源主机此次传输失败。代码 2 表示协议不可达。
        - 端口不可达（port unreachable）：表示分组要交付的应用进程没有运行。代码 3 表示端口不可达。
        - 源路由失败（source route failed），表示由源主机路由选项中规定的一个或多个路由器无法通过。代码5表示源路由失败。
        - 目的网络不可知（unknown destination network）：表示路由器根本不知道关于目的网络的信息。代码6表示目的网络不可知。目的网络不可知与网络不可达不同，网络不可达是知道目的网络存在，但是无法将分组送达目的网络.
        - 目的主机不可知（unknown destination host）：表示路由器根本不知道关于目的主机的信息。代码7表示目的主机不可知。

    - 源抑制：让源站放慢发送速度

    - 超时：超过网络包的生存时间仍然没到

    - 重定向：让下次发给另一个路由。

- 差错报告报文：会将出错的 IP 包的 IP 头和 IP 正文前的 8 个字节加到报文里。

:::

### ping

ping 命令执行时，源主机会构建 ICMP 请求数据包。类型为 8，增加顺序号（用于区分连续 ping 时发出的多个包，每发出一个包，顺序号会自动加 1。为了能够计算往返时间 RTT，会在报文的数据部分插入发送时间。

被 ping 的设备构建的应答包中，类型字段为 0，顺序号为接收到的请求数据包中的顺序号。

如果在规定时间内，源主机没有收到 ICMP 应答包，说明目的主机不可达。如果接收到了，源主机会用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。

如果在自己可控范围内遇到网落不通的问题，除了直接 ping 目的 IP 外，还应该有一个清晰的网络拓扑图。并且从理论上来讲，应该要清楚地知道一个网络包从源地址到目标地址都需要经过哪些设备，然后逐个 ping 中间的这些设备或者机器。如果可能的话，在这些关键点，通过 `tcpdump -i eth0 icmp`，查看包有没有到达某个点，回复的包到达了哪个点，可以更加容易推断出错的位置。点此阅读 [tcpdump](https://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html)。

如果不在我们的控制范围内，很多中间设备都是禁止 ping 的，但是 ping 不通不代表网络不通。这个时候就要使用 `telnet`，通过其他协议来测试网络是否通，这个就不在本篇的讲述范围了。


### traceroute: 差错报文的使用

并非只有真正遇到错误才可以收到 ICMP。Traceroute 这个程序利用 ICMP 规则，制造一些能够产生错误的场景。

- 设置 TTL 追踪路由

Traceroute 可以设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。Traceroute 的参数指向某个目的 IP 地址，它会发送一个 UDP 数据包。将 TTL 设置成 1，于是一旦遇到一个路由器，它就嘎了。于是就会返回一个 ICMP 包，也就是网络差错包，类型是超时。

接下来将 TTL 设置成 2。于是就可以知道第二关有多远。如此反复，直到到达主机。于是，Traceroute 就拿到了所有的路由 IP。如果有的路由器设置了不回 ICMP，那么 Traceroute 就看不到这些中间路由。

如何判断主机可达？Traceroute 会选择一个不可能的值作为 UDP 端口号（大于 30,000）。当该数据包到达时，目的主机的 UDP 模块将产生“端口不可达”的 ICMP 报文。如果数据没有达到主机，则可能回复的是超时。

> UDP 是无连接的，不会像 TCP 那样返回 ACK 确认，发出后是没有办法确定有没有收到的。所以要故意出错，让对方返回 ICMP 错误码来确定经过的 route。

- 设置不分片，确定路径的 MTU

设置“不分片”标志。发送的第一个分组的长度正好与出口 MTU 相等。如果中间遇到窄的关口会被卡住，会发送 ICMP 网络差错包。每次收到 ICMP“不能分片”差错时就减小分组的长度，直到到达目标主机。

### 小结

- ICMP 用来检测网络通信故障以及实现链路追踪。ICMP 分两种，差错报告报文、查询报文。
- ping 使用查询报文，Traceroute 使用差错报告报文。

## 4. 网关（一般是路由器）——三层设备

MAC 头和 IP 头

![](/images/basic/network/section1/mac&ip_head.png)


MAC 头中，首先是目标 MAC 和源 MAC，然后是协议类型（0800，IP）说明 MAC 包的数据部分是 IP 协议。

IP 协议中，版本号目前主流还是 IPv4。服务类型 TOS 表示包的优先级（在 [ip addr](/basic/network/index.md#_3-ip-addr-ifconfig) 命令中提到过）。TTL 在上面 ICMP 不分提到过。8 位协议标志表示再上一层协议是 TCP 还是 UDP。接下来就是源 IP 和目的 IP。

任何一台机器在访问另一个 IP 时，都会先判断目标 IP 和源 IP 是否处于同一网段（根据 CIDR 和子网掩码判断）。

如果在同一网段中，就没网关啥事儿了，直接将源 IP、目的 IP 放到 IP 头中。然后通过 ARP 获取目的 MAC，将目的 MAC 和源 MAC 放入 MAC 头中。

如果不在同一网段，就会发到默认网关（Gateway）。网关的地址和源 IP 一定在一个网段。源主机到网关的发送过程和上面同一网段的情况一样。网络包被网关接收后，剩下的就交给网关了。

网关一般是路由器，是一个三层转发的设备。它会把 MAC 头和 IP 头都取下来，根据里面的内容，决定接下来把包转发到哪。

### 4.1 静态路由

静态路由就是在路由器上配置一条一条规则。例如，要访问 A 网站（知道属于哪个网段），从 2 号口出去，下一跳是 IP2；要访问 B 网站（知道属于哪个网段），从 3 号口出去，下一跳是 IP3。

每当要选择从哪个口转发的时候，就一条条地匹配规则，找到符合的，就按照找规则中设置的端口转发过去，找下一跳 IPX。

#### IP 头、MAC 头中的字段哪些会改变

MAC 地址在局域网内才有效。只要过网关，MAC 地址就一定会改变，因为已经换了局域网。到网关的 IP 地址可能变，也可能不变。IP 不变网关被称为**转发网关**，改变 IP 的网关是 **NAT (Network Address Translation) 网关**。

所谓的下一跳就是某个 IP，要查找这个 IP 对应的 MAC 放入 MAC 头。

下面说一下 NAT 网关的转发流程。服务器 A 和 B 的局域网网段是一样的，因为局域网之间并没有做过协商。所以到了外网上，它们必须要使用“国际身份”。B 的“国际身份”是 192.168.56.2。在网关 B 中记下 192.168.56.2 对应局域网内的 192.168.1.101。


![](/images/basic/network/section1/nat.png)

源服务器 A 要访问目标服务器 B，目标地址应该是 192.168.56.2（A 应该只知道 B 的国际身份）。

- 网络包先从服务器 A 发送到网关 A 上（源 MAC：服务器 A 的MAC，目的 MAC：网关 A 的MAC，源 IP：192.168.1.101，目目 IP：192.168.56.2）。

- 网关 A 判断应该从 192.168.56.1 这个口转发，没有下一跳了（因为这个口和目标 IP 在同一网段），这是的源 MAC：192.168.56.1 的 MAC，目标 MAC：192.168.56.2 的 MAC，源 IP：192.168.56.1（服务器 A 的“国际身份”），目标 IP：192.168.56.2。

- 路由器 B 是 NAT 网关，它上面配置了 192.168.56.2 对应的内部 IP 是 192.168.1.101。于是改为访问 192.168.1.101。路由器 B 中配置了静态路由：想访问 192.168.1.0/24 这个网段，要从 192.168.1.1 这个口出去，没有下一跳了。（源 MAC：192.168.1.1 的 MAC 地址，目标 MAC：192.168.1.101 的 MAC 地址，源 IP：192.168.56.1，目标 IP：192.168.1.101）。

> 可以通过 [whatismyip](https://www.whatismyip.com/) 查看自己的出口 IP 地址。


### 4.2 配置路由 & 策略路由

路由器中维护路由表，一张路由表中有多条路由规则，每个规则至少包括三项信息：
- 出口网络：包想去哪
- 出口设备：将包从哪个口扔出去
- 下一跳网关：下一跳路由器的地址

```shell
ip route add 10.176.48.0/20 via 10.173.32.1 dev eth0
```
要去 10.176.48.0/20 这个目标网络，要从 eth0 端口出去，讲经过 10.173.32.1。

除了根据目的 IP 地址配置路由外，还可以根据多个参数来配置路由，即**策略路由**。

- 配置多个路由表（可以根据源 IP 地址、入口设备、TOS 等选择路由表，然后再路由表中查找路由）。

    可以设置：
    ```shell
    ip rule add from 192.168.1.0/24 table 10 
    ip rule add from 192.168.2.0/24 table 20
    ```

    表示从 192.168.1.0/24 这个网段来的使用 table 10 这个路由表。从 192.168.2.0/24 网段来的，使用 table 20 路由表。

- 一条路由规则中，也可以有多条路径

    ```shell
    ip route add default scope global nexthop via 100.100.100.1 weight 1 nexthop via 200.200.200.1 weight 2
    ```

    下一跳可以是 100.100.100.1，权重是 1；也可以是 200.200.200.1，权重是 2。



现在有这样一种情景。房东家里从不同的运营商哪里拉了两根网线，一个带宽大些，一个带宽小些，买了个高级点的路由器（可以接两个外网）。

<div align=center>
    <img src=/images/basic/network/section1/route.png width=50%/>
</div>

路由可以配置成这样：
```shell
$ ip route list table main 
60.190.27.189/30 dev eth3  proto kernel  scope link  src 60.190.27.190
183.134.188.1 dev eth2  proto kernel  scope link  src 183.134.189.34
192.168.1.0/24 dev eth1  proto kernel  scope link  src 192.168.1.1
127.0.0.0/8 dev lo  scope link
default via 183.134.188.1 dev eth2
```

- 如果访问 60.190.27.189/30 这个网络，就走 eth3
- 如果访问 183.134.188.1 这个网络，就走 eth2
- 如果访问内网，就走 eth1
- 如果所有规则都匹配不上，默认走 183.134.188.1 这个快速网络


现在租户 A 不想多付钱。于是我们添加一个 Table 叫 chao

```shell:no-line-numbers
$ echo 200 chao >> /etc/iproute2/rt_tables
```

添加一条规则：

```shell:no-line-numbers
$ ip rule add from 192.168.1.101 table chao
$ ip rule ls
0: from all lookup local 
32765: from 192.168.1.101 lookup chao
32766: from all lookup main 
32767: from all lookup default

```

这样，从 192.168.1.101 来的包都查看新路由表 chao。

- 将本地发起的数据包（即目标是本机的数据包）从本地路由表中查找，用于本机之间的通信。
- 从 IP 地址为 192.168.1.101 的主机发起的数据包将使用 "chao" 路由表。这是刚刚添加的规则。
- 数据包将从主路由表中查找。这是默认的主路由表，如果没有其他规则匹配，数据包将使用此表中的路由规则。

在 chao 表中添加规则

```shell
$ ip route add default via 60.190.27.189 dev eth3 table chao
$ ip route flush cache
```

不想花钱就用慢的网络吧。

### 4.3 动态路由

使用动态路由路由器，可以根据路由协议算法生成动态路由表，随网络运行状况的变化而变化。

#### 动态路由算法

1. 距离矢量路由算法（Distance Vector Routing）—— 基于 Bellman-Ford

这种算法基于节点之间的距离信息，通常使用跳数（hops）或某种度量来表示。

每个节点维护一个距离向量表，其中包含到其他节点的最短距离。节点周期性地将其向量表发送给相邻节点，相邻节点会根据接收到的信息更新自己的向量表。

:::details 优缺点
- 简单易实现： 距离向量路由算法相对较简单，容易实现和部署。它不需要大量的计算和存储资源，适用于较小规模的网络。

- 分布式协作： 节点之间仅交换距离向量信息，不需要全局知识。这使得算法适用于分布式网络环境。

- 慢收敛： 距离向量算法的一个缺点是慢收敛性。由于信息是通过邻居节点传递的，网络中的信息更新可能需要一些时间才能传播到整个网络，特别是在大规模和复杂网络中。

- 计数到无穷： 一个问题是计数到无穷现象，即如果存在一个环路或者不断的传递，距离值可能会趋向于无穷大，从而导致不稳定的路由。

- 拥塞和环路： 距离向量算法不能有效处理网络拥塞或环路情况，可能导致不稳定的路由和降低的网络性能。
:::

最早的路由协议 RIP（Routing Information Protocol）就用的距离矢量路由算法。它适用于小型网络（小于 15 跳）。现在一个数据中心内部路由器数目就很多，因而不适用了。

2. 链路状态路由算法（Link State Routing）—— 基于 Dijkstra

它基于节点之间的链路状态信息来计算最短路径，并选择最优的路径来传输数据包。


#### 动态路由协议

1. OSPF（Open Shortest Path First，开放式最短路径优先）

OSPF 是一种内部网关协议（IGP，Interior Gateway Protocol），用于在企业内部网络或自治系统中进行路由选择。基于 Link State Routing，旨在计算最短路径并支持大规模、复杂的网络拓扑。

内部网关协议的重点就是找到最短的路径。在一个组织内部，路径最短往往最优。当然有时候 OSPF 可以发现多个最短的路径，可以在这多个路径中进行负载均衡，这常常被称为**等价路由**。

这一点非常重要。有了等价路由，到一个地方去可以有相同的两个路线，可以分摊流量，还可以当一条路不通的时候，走另外一条路。这个在后面我们讲数据中心的网络的时候，一般应用的接入层会有负载均衡 LVS (Linux Virtual Server)。它可以和 OSPF 一起，实现高吞吐量的接入层设计。

2. BGP（Border Gateway Protocol，外网路由协议）

BGP 是一种外部网关协议（EGP，Exterior Gateway Protocol），用于在不同的自治系统（AS，Autonomous System）之间进行路由选择。与内部网关协议（IGP，Interior Gateway Protocol）如 OSPF 和 RIP 不同，BGP 主要用于互联网核心路由器之间的路由决策。

BGP 协议使用的算法是路径矢量路由协议（path-vector protocol）。它是距离矢量路由协议的升级版。

BGP 又分为两类，eBGP 和 iBGP。自治系统间，边界路由器之间使用 eBGP 广播路由。内部网络也需要访问其他的自治系统。边界路由器如何将 BGP 学习到的路由导入到内部网络呢？就是通过运行 iBGP，使得内部的路由器能够找到到达外网目的地的最好的边界路由器。

