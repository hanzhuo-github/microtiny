---
lang: zh-CN
title: 第二层到第三层
description:
article: false
---

## 1. 物理层 & MAC 层

### 1.1 第一层（物理层）

设备：集线器（Hub），广播

### 1.2 第二层（数据链路层）

#### MAC（Medium Access Control，媒体访问控制）

- 解决的是谁先发谁后发的问题，学名是**多路访问**。有很多算法解决这个问题：
    1. 信道划分：分多个道，你走你的，我走我的
    2. 轮流协议：轮着来
    3. 随机接入协议（以太网就用的这种方式）：管他三七二十一，先出门，堵的话就回去
- 判断发给谁，谁接收
    - 链路层地址，即 MAC 地址
    - 第二层的网络包格式：
        |目标 MAC<br>（6 bytes）|源 MAC<br>（6 bytes）|类型<br>（2 bytes）|数据<br>（46-1500 bytes）|CRC<br>（4 bytes）|
        |:-:|:-:|:-:|:-:|:-:|

        - 类型：0800 - IP 数据报，0860 - ARP 请求
        - CRC 循环冗余检测：通过 XOR 异或来计算整个包是否在发送的过程中出现了了错误
    - 有了目标 MAC 地址，数据包在链路上广播，MAC 的网卡发现这个包是给它的，于是把包收进来。接着打开 IP 包，发现 IP 包也是自己的，再打开 TCP 包，发现端口是 80，nginx 就是监听的 80。于是将请求提交给 nginx，nginx 返回一个网页。

#### ARP 协议

问题：如果一个广播网络里面接入了 N 台机器，怎么知道每台机器的 MAC 地址呢？

答案：ARP 协议 - 根据 IP 地址找 MAC 地址的协议。这是一个输出全靠“吼”的阶段。

|目标 MAC<br>（6 bytes）|源 MAC<br>（6 bytes）|类型<br>（2 bytes）|ARP 报文|
|:-:|:-:|:-:|:-:|

过程：要发送数据的机器发送一个广播包，等目的 IP 对应的机器来回应自己。

ARP 报文格式：
|硬件类型<br>（Ethernet）|协议类型<br>（IP）|硬件地址长度<br>（6）|协议地址长度<br>（6）|操作代码<br>（1 request 2 reply）|发送者 MAC|发送者 IP|目标 MAC|目标 IP|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|

ARP 缓存：为了避免每次都用 ARP 请求，机器本地也会进行 ARP 缓存。由于机器会不断上线下线，IP 也可能会变，所以 ARP 的 MAC 地址缓存过一段时间就会过期。

#### 交换机 & 转发表

机器数少的时候，我们可以用集线器组网。集线器是广播的，每个端口不管是否需要该包，都会接收然后发给主机，然后让主机自己判断是否需要。当机器数多的时候，端口什么都接受什么都转发的话，会更容易产生冲突，而且把不需要的包转发出去纯属浪费。

我们需要稍微智能一点的设备，该设备每个口可以解析 MAC 头，检查下目标 MAC 地址，然后根据策略进行转发。即第二层设备：交换机。

交换机如何知道每个口的电脑的 MAC 地址呢？需要交换机会学习，学习的结果就是**转发表**。

电脑 A 向电脑 B 发送一个包，当包到达交换机时，最开始交换机并不知道电脑 B 在哪个口，于是它只能将包发送给除了连接电脑 A 口以外的其他口。交换机聪明之处在于，它会记住，电脑 A（对应的MAC）在哪个口。以后遇到目的地址是电脑 A 的 MAC 地址时，直接发送到对应的口就行。

这样过了一段时间之后，交换机就有了整个网络的结构了，这时基本不用广播了，可以准确转发。


### 1.3 交换机与 VLAN


下图是两台交换机连接三个局域网的情况。

<div align=center>
    <img src=/images/basic/network/section1/Lan.png width=50%/>
</div>

当机器 1 向机器 4（已知其 IP）发送包的时候，目的 MAC 还不知道，所以需要先用 ARP 获取目的 MAC。

:::details 简述交换机学习网络拓扑信息的过程
现在两台交换机都不了解网络的任何拓扑信息。

机器 1 发起广播。机器 2 能收到，但是没它啥事。交换机 A 也收到了这个广播，此时它不知道网络的拓扑信息，于是它将该广播包转发给除了广播包来的方向之外的其他所有网口。

机器 3 也收到了信息，但是这和它也没啥关系。交换机 B 同样收到了该广播包，它也不知道网络的拓扑信息，于是它也按照广播策略将包转发到 LAN 3。此时，机器 4 和机器 5 都能收到广播信息。机器 4 主动响应，这是找我的，我的 MAC 是 blabla。于是一个 ARP 请求就完成了。

在上面的过程中，两台交换机都学到了这样的信息：机器 1 是在左边的网口。

下次当机器 2 要访问机器 1 时，先通过 ARP 获取机器 1 的 MAC 地址。知道目的 MAC 后，发送数据包。该消息会到达机器 1，也会到交换机 A。交换机已经知道了机器 1 不在右边的网口，于是这个广播信息不会广播到 LAN 2 和 LAN 3。
:::

#### 环路问题 & STP 协议

环路问题会导致 ARP 请求爆炸，且交换机无法学习到网络的拓扑结构。

数据结构中有**最小生成树**，有环的我们常称为**图**。将图中的环破坏了，就生成了**树**。计算机网络中生成树算法是STP（Spanning Tree Protocol）。

<div align=center>
    <img src=/images/basic/network/section1/stp.png width=50%/>
</div>

STP 中的概念：
- Root Bridge，根交换机
- Designated Bridge，指定交换机
- Bridge Protocol Data Unit，BPDU，网桥协议数据单元。“互相比较实例”的协议。只有 Root Bridge 可以发，其他交换机只能转发 Root Bridge 的消息。
- Priority Vector，优先级向量。`[Root Bridge ID, Root Path Cost, Bridge ID, Port ID]`。在 BPDU 中。

##### STP 的工作过程

网络管理员为所有的交换机分配了优先级。交换机通过互相发送 BPDU 来判断谁的优先级更高。

具体过程这里不介绍了。

#### 广播问题 & 安全问题

**物理隔离**：使用单独的交换机配置单独的子网

**虚拟隔离**，**虚拟局域网（VLAN）**：一个交换机上会连属于多个局域网的机器。

交换机如何区别某个机器属于哪个局域网呢？在原来的二层的头上加一个 TAG，里面有一个 VLAN ID，一共12位（可以划分 4096 个 VLAN）。这样仍然不够，目前云计算厂商例绝对不止 4096 个用户。当然每个用户需要一个 VLAN，后面章节再讲这个问题。

<div align=center>
    <img src=/images/basic/network/section1/vlan.png width=50%/>
</div>

如果我们使用的交换机是支持 VLAN 的，当交换机把二层的头取下来时就可以识别 VLAN ID。这样，只有相同 VLAN 的包才会互相转发，不同 VLAN 的包是看不到的。

对于支持 VLAN 的交换机，有一种口叫 Trunk 口。它可以转发属于任何 VLAN 的数据，交换机之间可以通过这种口互相连接。

<div align=center>
    <img src=/images/basic/network/section1/trunk.png width=50%/>
</div>



### 1.4 ICMP 与 ping

#### ICMP

ping 基于 ICMP 协议（Internet Control Message Protocol, 互联网控制报文协议）工作。ICMP 用来监测网络通信故障、实现链路追踪，最典型的应用就是 ping 和 traceroute。它要解决 IP 肯呢个出现的不可靠问题，属于 IP 的组成部分。

ICMP 是网络层的协议，所以 ICMP 报文是封装在 IP 包里的。IP包有两部分：IP头 + 正文（这里是 ICMP 报文）。其中 IP 分组头中，协议字段为 1，表示数据部分是 ICMP 报文。

ICMP 报文前 4 格式统一：

|类型<br>（1B）|代码<br>（1B）|校验和<br>（2B）|与类型值相关<br>（4B）|ICMP 数据部分|
|:-:|:-:|:-:|:-:|:-:|


:::details ICMP 报文类型
<table>
    <tr><th>ICMP 报文大类</th><th>类型值</th><th>ICMP 报文类型</th></tr>
    <tr><td rowspan="5">差错报告报文</td><td>3</td><td>目的不可达</td></tr>
    <tr><td>4</td><td>源抑制</td></tr>
    <tr><td>5</td><td>超时</td></tr>
    <tr><td>11</td><td>参数问题</td></tr>
    <tr><td>12</td><td>重定向</td></tr>
    <tr><td rowspan="4">询问报文</td><td>8 或 0</td><td>回送请求和应答</td></tr>
    <tr><td>13 或 14</td><td>时间戳请求和应答</td></tr>
    <tr><td>15 或 16</td><td>路由器询问与通告</td></tr>
    <tr><td>17 或 18</td><td>地址掩码请求和应答</td></tr>
</table>

- 查询报文：

    - 目的不可达报文主要有以下 7 种类型：
        - 网络不可达（network unreachable）：表示路由器寻址出错，下一跳路由器可能存在故障。网络不可达报文只能由路由器产生。代码 0 表示网络不可达。
        - 主机不可达（host unreachable）：表示网络寻址不存在问题，可能是目的主机不工作或不存在。主机不可达报文只能由路由器产生。代码 1 表示主机不可达。
        - 协议不可达（protocol unreachable）：IP 分组携带的数据来自高层协议，例如 UDP、TCP、OSPF 等。如果目的主机接收分组的数据字段来自 TCP，但是目的主机的 TCP 未运行，这时目的主机不能处理 IP 分组携带的 TCP 数据，则主机将产生一个协议不可达报文，通知源主机此次传输失败。代码 2 表示协议不可达。
        - 端口不可达（port unreachable）：表示分组要交付的应用进程没有运行。代码 3 表示端口不可达。
        - 源路由失败（source route failed），表示由源主机路由选项中规定的一个或多个路由器无法通过。代码5表示源路由失败。
        - 目的网络不可知（unknown destination network）：表示路由器根本不知道关于目的网络的信息。代码6表示目的网络不可知。目的网络不可知与网络不可达不同，网络不可达是知道目的网络存在，但是无法将分组送达目的网络.
        - 目的主机不可知（unknown destination host）：表示路由器根本不知道关于目的主机的信息。代码7表示目的主机不可知。

    - 源抑制：让源站放慢发送速度

    - 超时：超过网络包的生存时间仍然没到

    - 重定向：让下次发给另一个路由。

- 差错报告报文：会将出错的 IP 包的 IP 头和 IP 正文前的 8 个字节加到报文里。

:::

#### ping

ping 命令执行时，源主机会构建 ICMP 请求数据包。类型为 8，增加顺序号（用于区分连续 ping 时发出的多个包，每发出一个包，顺序号会自动加 1。为了能够计算往返时间 RTT，会在报文的数据部分插入发送时间。

被 ping 的设备构建的应答包中，类型字段为 0，顺序号为接收到的请求数据包中的顺序号。

如果在规定时间内，源主机没有收到 ICMP 应答包，说明目的主机不可达。如果接收到了，源主机会用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。

如果在自己可控范围内遇到网落不通的问题，除了直接 ping 目的 IP 外，还应该有一个清晰的网络拓扑图。并且从理论上来讲，应该要清楚地知道一个网络包从源地址到目标地址都需要经过哪些设备，然后逐个 ping 中间的这些设备或者机器。如果可能的话，在这些关键点，通过 `tcpdump -i eth0 icmp`，查看包有没有到达某个点，回复的包到达了哪个点，可以更加容易推断出错的位置。点此阅读 [tcpdump](https://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html)。

如果不在我们的控制范围内，很多中间设备都是禁止 ping 的，但是 ping 不通不代表网络不通。这个时候就要使用 `telnet`，通过其他协议来测试网络是否通，这个就不在本篇的讲述范围了。


#### traceroute: 差错报文的使用

并非只有真正遇到错误才可以收到 ICMP。Traceroute 这个程序利用 ICMP 规则，制造一些能够产生错误的场景。

- 设置 TTL 追踪路由

Traceroute 可以设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。Traceroute 的参数指向某个目的 IP 地址，它会发送一个 UDP 数据包。将 TTL 设置成 1，于是一旦遇到一个路由器，它就嘎了。于是就会返回一个 ICMP 包，也就是网络差错包，类型是超时。

接下来将 TTL 设置成 2。于是就可以知道第二关有多远。如此反复，直到到达主机。于是，Traceroute 就拿到了所有的路由 IP。如果有的路由器设置了不回 ICMP，那么 Traceroute 就看不到这些中间路由。

如何判断主机可达？Traceroute 会选择一个不可能的值作为 UDP 端口号（大于 30,000）。当该数据包到达时，目的主机的 UDP 模块将产生“端口不可达”的 ICMP 报文。如果数据没有达到主机，则可能回复的是超时。

> UDP 是无连接的，不会像 TCP 那样返回 ACK 确认，发出后是没有办法确定有没有收到的。所以要故意出错，让对方返回 ICMP 错误码来确定经过的 route。

- 设置不分片，确定路径的 MTU

设置“不分片”标志。发送的第一个分组的长度正好与出口 MTU 相等。如果中间遇到窄的关口会被卡住，会发送 ICMP 网络差错包。每次收到 ICMP“不能分片”差错时就减小分组的长度，直到到达目标主机。

#### 小结

- ICMP 用来检测网络通信故障以及实现链路追踪。ICMP 分两种，差错报告报文、查询报文。
- ping 使用查询报文，Traceroute 使用差错报告报文。



