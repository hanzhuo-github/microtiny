import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{o as t,c as e,f as n,b as a,d as s}from"./app-4ed637ae.js";const p="/images/code/ds/chaining.png",i={},m=n('<p>我们也称散列表为哈希表或 hash 表。它利用数组支持按照下标随机访问数据的特性，是数组的一种扩展。</p><p>键（key）、散列函数（hash 函数、哈希函数）、散列值（hash 值、哈希值）</p><p>hash 函数设计的基本要求：</p><ol><li>hash 函数计算得到的 hash 值是一个非负整数</li><li>如果 key1 = key2，那么 hash(key1) = hash(key2)</li><li>如果 key1 ≠ key2，那么 hash(key1) ≠ hash(key2)</li></ol><p>但是在实际中，无法完全避免散列冲突。</p><h2 id="_1-解决散列冲突的方法" tabindex="-1"><a class="header-anchor" href="#_1-解决散列冲突的方法" aria-hidden="true">#</a> 1. 解决散列冲突的方法</h2><h3 id="_1-1-开放寻址法-open-addressing" tabindex="-1"><a class="header-anchor" href="#_1-1-开放寻址法-open-addressing" aria-hidden="true">#</a> 1.1 开放寻址法（open addressing）</h3><p>核心思想：如果出现了冲突，就重新探测一个空闲位置将元素插入。</p><p>如何探测？</p><h4 id="_1-1-1-线性探测-linear-probing" tabindex="-1"><a class="header-anchor" href="#_1-1-1-线性探测-linear-probing" aria-hidden="true">#</a> 1.1.1 线性探测（Linear Probing）</h4><p>核心思想：经过散列函数得到的散列值对应的位置已经被占用了，那么就从当前位置开始，依次向后查找，直到找到空闲位置。</p><p>查找元素时，比较下标为散列值的元素和要查找的元素。如果相等，则说明该元素就是要找的元素；否则就依次往后找。如果遍历到数组中的空闲位置仍然没找到，就说明要查找的元素没有在散列表中。</p><p>删除操作时，不能简单地只把要删除的元素设置为空。如果简单地设置为空，那么在下次查找某个元素时，可能查到该位置时，就判定该元素不在散列表里（实际上这个空的位置是我们后来删除的）。我们可以将删除的元素，特殊标记为 <code>deleted</code>。当线性探测查找时，遇到标记为 <code>deleted</code> 不要停下来，继续向下探测。</p>',13),c=a("p",null,[s("线性探测的缺点：当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置越来越少，线性探测的时间就会越来越久。极端情况下需要探测整个散列表，即最坏情况下的时间复杂度为 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mi",null,"n"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(n)")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord mathnormal"},"n"),a("span",{class:"mclose"},")")])])]),s("。")],-1),o=a("h4",{id:"_1-1-2-二次探测-quadratic-probing",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_1-1-2-二次探测-quadratic-probing","aria-hidden":"true"},"#"),s(" 1.1.2 二次探测（Quadratic probing）")],-1),r=a("p",null,[s("二次探测，跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"h"),a("mi",null,"a"),a("mi",null,"s"),a("mi",null,"h"),a("mo",{stretchy:"false"},"("),a("mi",null,"k"),a("mi",null,"e"),a("mi",null,"y"),a("mo",{stretchy:"false"},")"),a("mo",null,"+"),a("mn",null,"0")]),a("annotation",{encoding:"application/x-tex"},"hash(key)+0")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal"},"ha"),a("span",{class:"mord mathnormal"},"s"),a("span",{class:"mord mathnormal"},"h"),a("span",{class:"mopen"},"("),a("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k"),a("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"ey"),a("span",{class:"mclose"},")"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),a("span",{class:"mbin"},"+"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"0")])])]),s("，"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"h"),a("mi",null,"a"),a("mi",null,"s"),a("mi",null,"h"),a("mo",{stretchy:"false"},"("),a("mi",null,"k"),a("mi",null,"e"),a("mi",null,"y"),a("mo",{stretchy:"false"},")"),a("mo",null,"+"),a("mn",null,"1")]),a("annotation",{encoding:"application/x-tex"},"hash(key)+1")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal"},"ha"),a("span",{class:"mord mathnormal"},"s"),a("span",{class:"mord mathnormal"},"h"),a("span",{class:"mopen"},"("),a("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k"),a("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"ey"),a("span",{class:"mclose"},")"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),a("span",{class:"mbin"},"+"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"1")])])]),s("，"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"h"),a("mi",null,"a"),a("mi",null,"s"),a("mi",null,"h"),a("mo",{stretchy:"false"},"("),a("mi",null,"k"),a("mi",null,"e"),a("mi",null,"y"),a("mo",{stretchy:"false"},")"),a("mo",null,"+"),a("mn",null,"2")]),a("annotation",{encoding:"application/x-tex"},"hash(key)+2")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal"},"ha"),a("span",{class:"mord mathnormal"},"s"),a("span",{class:"mord mathnormal"},"h"),a("span",{class:"mopen"},"("),a("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k"),a("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"ey"),a("span",{class:"mclose"},")"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),a("span",{class:"mbin"},"+"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"2")])])]),s("，...。而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"h"),a("mi",null,"a"),a("mi",null,"s"),a("mi",null,"h"),a("mo",{stretchy:"false"},"("),a("mi",null,"k"),a("mi",null,"e"),a("mi",null,"y"),a("mo",{stretchy:"false"},")"),a("mo",null,"+"),a("mn",null,"0")]),a("annotation",{encoding:"application/x-tex"},"hash(key)+0")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal"},"ha"),a("span",{class:"mord mathnormal"},"s"),a("span",{class:"mord mathnormal"},"h"),a("span",{class:"mopen"},"("),a("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k"),a("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"ey"),a("span",{class:"mclose"},")"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),a("span",{class:"mbin"},"+"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"0")])])]),s("，"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"h"),a("mi",null,"a"),a("mi",null,"s"),a("mi",null,"h"),a("mo",{stretchy:"false"},"("),a("mi",null,"k"),a("mi",null,"e"),a("mi",null,"y"),a("mo",{stretchy:"false"},")"),a("mo",null,"+"),a("msup",null,[a("mn",null,"1"),a("mn",null,"2")])]),a("annotation",{encoding:"application/x-tex"},"hash(key)+1^{2}")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal"},"ha"),a("span",{class:"mord mathnormal"},"s"),a("span",{class:"mord mathnormal"},"h"),a("span",{class:"mopen"},"("),a("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k"),a("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"ey"),a("span",{class:"mclose"},")"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),a("span",{class:"mbin"},"+"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.8141em"}}),a("span",{class:"mord"},[a("span",{class:"mord"},"1"),a("span",{class:"msupsub"},[a("span",{class:"vlist-t"},[a("span",{class:"vlist-r"},[a("span",{class:"vlist",style:{height:"0.8141em"}},[a("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[a("span",{class:"pstrut",style:{height:"2.7em"}}),a("span",{class:"sizing reset-size6 size3 mtight"},[a("span",{class:"mord mtight"},[a("span",{class:"mord mtight"},"2")])])])])])])])])])])]),s("，"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"h"),a("mi",null,"a"),a("mi",null,"s"),a("mi",null,"h"),a("mo",{stretchy:"false"},"("),a("mi",null,"k"),a("mi",null,"e"),a("mi",null,"y"),a("mo",{stretchy:"false"},")"),a("mo",null,"+"),a("msup",null,[a("mn",null,"2"),a("mn",null,"2")])]),a("annotation",{encoding:"application/x-tex"},"hash(key)+2^{2}")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal"},"ha"),a("span",{class:"mord mathnormal"},"s"),a("span",{class:"mord mathnormal"},"h"),a("span",{class:"mopen"},"("),a("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k"),a("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"ey"),a("span",{class:"mclose"},")"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),a("span",{class:"mbin"},"+"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.8141em"}}),a("span",{class:"mord"},[a("span",{class:"mord"},"2"),a("span",{class:"msupsub"},[a("span",{class:"vlist-t"},[a("span",{class:"vlist-r"},[a("span",{class:"vlist",style:{height:"0.8141em"}},[a("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[a("span",{class:"pstrut",style:{height:"2.7em"}}),a("span",{class:"sizing reset-size6 size3 mtight"},[a("span",{class:"mord mtight"},[a("span",{class:"mord mtight"},"2")])])])])])])])])])])]),s("，...。")],-1),h=n(`<h4 id="_1-1-3-双重散列-double-hashing" tabindex="-1"><a class="header-anchor" href="#_1-1-3-双重散列-double-hashing" aria-hidden="true">#</a> 1.1.3 双重散列（Double hashing）</h4><p>使用一组 hash 函数 hash1(key)，hash2(key)，hash3(key), ...。我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p><hr><p>不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用<strong>装载因子</strong>（load factor）来表示空位的多少。</p><div class="language-text" data-ext="text"><pre class="language-text"><code>散列表的装载因子 = 填入表中的元素个数/散列表的长度
</code></pre></div><p>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p><h3 id="_1-2-链表法-chaining" tabindex="-1"><a class="header-anchor" href="#_1-2-链表法-chaining" aria-hidden="true">#</a> 1.2 链表法（chaining）</h3><p>更常用的散列冲突解决办法，相比开放寻址法更简单。</p><p>如下图，每个“桶”（bucket）或“槽”（slot）都对应一条链表，所有散列值相同的元素都放到相同曹伟对应的链表中。</p><div align="center"><img src="`+p+'" width="50%/"></div>',10),u=a("p",null,[s("插入 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mn",null,"1"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(1)")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord"},"1"),a("span",{class:"mclose"},")")])])]),s("。查找、删除的时间复杂度跟链表的长度 k 成正比，即 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mi",null,"k"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(k)")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k"),a("span",{class:"mclose"},")")])])]),s("。对于散列表叫均匀的散列函数，理论上来讲 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"k"),a("mo",null,"="),a("mi",null,"n"),a("mi",{mathvariant:"normal"},"/"),a("mi",null,"m")]),a("annotation",{encoding:"application/x-tex"},"k=n/m")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6944em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k"),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),a("span",{class:"mrel"},"="),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal"},"n"),a("span",{class:"mord"},"/"),a("span",{class:"mord mathnormal"},"m")])])]),s("，n 表示散列中数据的个数，m 表示散列表中“槽”的个数。")],-1),d=a("h2",{id:"_2-打造一个工业级水平的散列表",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_2-打造一个工业级水平的散列表","aria-hidden":"true"},"#"),s(" 2. 打造一个工业级水平的散列表")],-1),g=a("h3",{id:"_2-1-如何设计",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_2-1-如何设计","aria-hidden":"true"},"#"),s(" 2.1 如何设计？")],-1),k=a("ul",null,[a("li",null,[a("p",null,"散列函数不能太复杂 -> 计算复杂 -> 间接影响散列表的性能")]),a("li",null,[a("p",null,"散列函数生成的值要尽可能随机且均匀分布 -> 避免或最小化散列冲突。即便出现冲突，散列到每个槽里的数据也会比较平均。")]),a("li",null,[a("p",null,"动态扩容 & 动态缩容"),a("ul",null,[a("li",null,[a("p",null,"动态扩容"),a("p",null,[s("当装载因子过大时，也可以进行"),a("strong",null,"动态扩容"),s("，重新申请一个更大的散列表，将数据搬移到新的散列表中。如果每次扩容都申请一个原来散列表大小两倍的空间，原来装载因子为 0.8，则扩容之后的装载因子就下降为原来的一半，变成了 0.4。")]),a("p",null,[s("插入一个数据，最好情况下，不需要扩容，最好时间复杂度是 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mn",null,"1"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(1)")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord"},"1"),a("span",{class:"mclose"},")")])])]),s("。最坏情况下，散列表装载因子过高，启动扩容，我们需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度是 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mi",null,"n"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(n)")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord mathnormal"},"n"),a("span",{class:"mclose"},")")])])]),s("。用摊还分析法，均摊情况下，时间复杂度接近最好情况，就是 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mn",null,"1"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(1)")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord"},"1"),a("span",{class:"mclose"},")")])])]),s("。")])]),a("li",null,[a("p",null,[s("动态缩容 实际上，对于动态散列表，随着数据的删除，散列表中的数据会越来越少，空闲空间会越来越多。如果我们对空间消耗非常敏感，我们可以在装载因子小于某个值之后，启动"),a("strong",null,"动态缩容"),s("。当然，如果我们更加在意执行效率，能够容忍多消耗一点内存空间，那就可以不用费劲来缩容了。")])]),a("li",null,[a("p",null,"“一次性”扩容？ 有时，“一次性”扩容的开销会让用户崩溃，这是我们可以将扩容操作穿插在插入操作的过程中。")])])]),a("li",null,[a("p",null,"如何选择冲突解决方法？"),a("p",null,"Java 中 LinkedHashMap 采用的是链表法解决冲突，ThreadLocalMap 通过线性探测的开放寻址法来结局冲突。"),a("ul",null,[a("li",null,[a("p",null,"开放寻址法"),a("ul",null,[a("li",null,[s("优点： "),a("ul",null,[a("li",null,"数据都存在数组中，可以有效利用 CPU 缓存加快查询进度。"),a("li",null,"序列化比较简单。链表法包含指针，序列化起来没那么容易。")])]),a("li",null,[s("缺点： "),a("ul",null,[a("li",null,"删除数据时你叫麻烦，需要特殊标记已经删除的数据"),a("li",null,"由于所有数据都存储在一个数组中，于是相比链表法，其冲突的代价更高 -> 装载因子的上限不能太大 -> 更浪费内存空间")])]),a("li",null,"应用：当数据量比较小、装载因子小时，适合采用开放寻址法。")])]),a("li",null,[a("p",null,"链表法"),a("ul",null,[a("li",null,[s("优点： "),a("ul",null,[a("li",null,"对内存的利用率比开放寻址法要高。"),a("li",null,"对大装载因子的容忍度更高。开放寻址法只适用装载因子小于1的情况。")])]),a("li",null,[s("缺点： "),a("ul",null,[a("li",null,"链表要存指针，所以对于比较小的对象的存储，比较消耗内存，还有可能让内存的消耗翻倍。"),a("li",null,"链表中的结点是零散分布在内存中的（非连续），所以对 CPU 缓存不友好。")])]),a("li",null,[s("应用 "),a("ul",null,[a("li",null,"实际上，我们对链表法稍加改造，可以实现一个更加高效的散列表。那就是，我们将链表法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树。这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是 O(logn)。这样也就有效避免了前面讲到的散列碰撞攻击。"),a("li",null,"比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。")])])])])])])],-1),y=n(`<h3 id="_2-2-工业级散列表" tabindex="-1"><a class="header-anchor" href="#_2-2-工业级散列表" aria-hidden="true">#</a> 2.2 工业级散列表</h3><p>Java 中的 HashMap。</p><h4 id="_2-2-1-初始大小" tabindex="-1"><a class="header-anchor" href="#_2-2-1-初始大小" aria-hidden="true">#</a> 2.2.1 初始大小</h4><p>HashMap 默认的初始的大小是 16。</p><p>这个默认值是可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高 HashMap 的性能。</p><h4 id="_2-2-2-装在因子和动态扩容" tabindex="-1"><a class="header-anchor" href="#_2-2-2-装在因子和动态扩容" aria-hidden="true">#</a> 2.2.2 装在因子和动态扩容</h4><p>最大装载因子默认是 0.75，当 HashMap 中元素个数超过 0.75 * capacity 时，就会扩容，每次扩容为原来的两倍大小。</p><h4 id="_2-2-3-散列冲突解决方法" tabindex="-1"><a class="header-anchor" href="#_2-2-3-散列冲突解决方法" aria-hidden="true">#</a> 2.2.3 散列冲突解决方法</h4><p>HashMap 底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 HashMap 的性能。</p><p>于是，在 JDK1.8 版本中，为了对 HashMap 做进一步优化，我们引入了红黑树。而当链表长度太长（默认超过 8）时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点，提高 HashMap 的性能。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。</p><h4 id="_2-2-4-散列函数" tabindex="-1"><a class="header-anchor" href="#_2-2-4-散列函数" aria-hidden="true">#</a> 2.2.4 散列函数</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；
    <span class="token keyword">return</span> <span class="token punctuation">(</span>h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>capicity <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//capicity表示散列表的大小</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，hashCode() 返回的是 Java 对象的 hash code。比如 String 类型的对象的 hashCode() 就是下面这样：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> var1 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>hash<span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>var1 <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> var2 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> var3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> var3 <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>var3<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      var1 <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">*</span> var1 <span class="token operator">+</span> var2<span class="token punctuation">[</span>var3<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> var1<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> var1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,14),x=[m,c,o,r,h,u,d,g,k,y];function v(w,b){return t(),e("div",null,x)}const M=l(i,[["render",v],["__file","hash-table.html.vue"]]);export{M as default};
