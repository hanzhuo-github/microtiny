import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as t,c as p,b as s,d as n,e as a}from"./app-e50f947d.js";const l={},i=s('<h2 id="_1-几种常见的链表结构" tabindex="-1"><a class="header-anchor" href="#_1-几种常见的链表结构" aria-hidden="true">#</a> 1. 几种常见的链表结构</h2><p>链表的结构五花八门，下面介绍三种最常见的列表结构：单链表、双向链表、循环链表。</p><h3 id="_1-1-单链表" tabindex="-1"><a class="header-anchor" href="#_1-1-单链表" aria-hidden="true">#</a> 1.1 单链表</h3><p>一些概念：</p><ul><li>结点： <ul><li>头结点：记录链表的基地址</li><li>尾结点：指针指向空地址 NULL</li></ul></li><li>后继指针</li></ul>',5),o=n("p",null,[a("插入、删除的时间复杂度都是 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mn",null,"1"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(1)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord"},"1"),n("span",{class:"mclose"},")")])])]),a("，随机访问的性能不如数组，要 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])]),a(" 的时间复杂度。")],-1),c=s('<h3 id="_1-2-循环链表" tabindex="-1"><a class="header-anchor" href="#_1-2-循环链表" aria-hidden="true">#</a> 1.2 循环链表</h3><p>循环链表是一种特殊的单链表。循环链表的尾结点指向链表的头结点。</p><p>优点：从链尾到链头比较方便。在单链表中，从已知一结点出发，只能访问到该结点以及它之后的结点；而使用循环链表时，从任意结点出发都可以访问到表中的所有节点。当要处理的数据具有环型结构的特点时，很适合采用循环链表，如著名的约瑟夫问题。</p><h3 id="_1-3-双向链表" tabindex="-1"><a class="header-anchor" href="#_1-3-双向链表" aria-hidden="true">#</a> 1.3 双向链表</h3><p>除了有后继指针 <code>next</code>，还有前驱指针 <code>prev</code>。</p><p>需要更多的空间来存储前驱指针，但是能够支持双向遍历。</p>',6),r=n("p",null,[a("双向链表可以支持 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mn",null,"1"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(1)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord"},"1"),n("span",{class:"mclose"},")")])])]),a(" 时间复杂度来找到前驱节点，于是双向链表在某些情况下的插入、删除等操作比单链表简单高效（单链表需要从头结点开始找）。")],-1),u=s(`<p>对于一个有序链表，双向链表的按值查询的效率要比单链表高一些。我们可以记录上次查找的位置 p，每次查询是，根据要找的值与 p 的大小关系，决定往前找还是往后找，所以平均值需要查找一半的数据。</p><h3 id="_1-4-双向循环链表" tabindex="-1"><a class="header-anchor" href="#_1-4-双向循环链表" aria-hidden="true">#</a> 1.4 双向循环链表</h3><h2 id="_2-数组-v-s-链表" tabindex="-1"><a class="header-anchor" href="#_2-数组-v-s-链表" aria-hidden="true">#</a> 2. 数组 v.s. 链表</h2><ul><li><p>数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。</p></li><li><p>数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容。</p></li><li><p>如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。</p></li></ul><h2 id="_3-用链表的应用" tabindex="-1"><a class="header-anchor" href="#_3-用链表的应用" aria-hidden="true">#</a> 3. 用链表的应用</h2><h3 id="_3-1-实现-lru" tabindex="-1"><a class="header-anchor" href="#_3-1-实现-lru" aria-hidden="true">#</a> 3.1 实现 LRU</h3><p>链表的典型应用场景：LRU(Least Recently Used, 最近最少使用) 缓存淘汰算法</p><p>我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。</p><p>当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。</p><ol><li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</li><li>如果此数据没有在缓存链表中，又可以分为两种情况： <ul><li>如果此时缓存未满，则将此结点直接插入到链表的头部；</li><li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</li></ul></li></ol><h3 id="_3-2-快慢指针" tabindex="-1"><a class="header-anchor" href="#_3-2-快慢指针" aria-hidden="true">#</a> 3.2 快慢指针</h3><ul><li>判断是否有环 <ul><li>判断环的起点</li></ul></li><li>找中点（中点、上中点、下中点）</li></ul><h2 id="_4-正确写出链表代码" tabindex="-1"><a class="header-anchor" href="#_4-正确写出链表代码" aria-hidden="true">#</a> 4. 正确写出链表代码</h2><h3 id="_4-1-理解指针或引用的含义-——-地址" tabindex="-1"><a class="header-anchor" href="#_4-1-理解指针或引用的含义-——-地址" aria-hidden="true">#</a> 4.1 理解指针或引用的含义 —— 地址</h3><h3 id="_4-2-警惕指针丢失和内存泄漏" tabindex="-1"><a class="header-anchor" href="#_4-2-警惕指针丢失和内存泄漏" aria-hidden="true">#</a> 4.2 警惕指针丢失和内存泄漏</h3><p>先后接，再前接</p><p>删除链表结点时，记得手动释放内存空间。</p><h3 id="_4-3-利用哨兵简化实现难度" tabindex="-1"><a class="header-anchor" href="#_4-3-利用哨兵简化实现难度" aria-hidden="true">#</a> 4.3 利用哨兵简化实现难度</h3><details class="hint-container details"><summary>对头结点和尾结点的特殊处理</summary><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// 插入</span>
new_node <span class="token operator">-&gt;</span> next <span class="token operator">=</span> p <span class="token operator">-&gt;</span> next<span class="token punctuation">;</span>
p <span class="token operator">-&gt;</span> next <span class="token operator">=</span>  new_node<span class="token punctuation">;</span>

<span class="token comment">// 插入第一个节点</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    head <span class="token operator">=</span> new_node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// 删除</span>
p <span class="token operator">-&gt;</span> next <span class="token operator">=</span> p <span class="token operator">-&gt;</span> next <span class="token operator">-&gt;</span> next<span class="token punctuation">;</span>

<span class="token comment">// 删除最后一个结点</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">-&gt;</span> next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    head <span class="token operator">=</span> null
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><p>引入哨兵结点，在任何时候，不管链表是否为空，head 指针都会指向这个哨兵结点。这种链表叫<strong>带头链表</strong>。不带哨兵结点的链表叫做<strong>不带头链表</strong>。</p><p>使用<strong>带头链表</strong>之后，插入第一个结点、删除最后一个结点就可以统一为相同的代码实现逻辑。</p><details class="hint-container details"><summary>利用哨兵简化变成难度</summary><p>任务：给定数组 a，查找 key，返回 key 的索引（其中 n 表示数组 a 的长度）</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">char</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> null <span class="token operator">||</span> n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 

    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> i
        <span class="token punctuation">}</span>
        <span class="token operator">++</span>i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">char</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> null <span class="token operator">||</span> n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 用 a[n-1] 做哨兵，这里做特殊处理</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">char</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    a<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>

    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment">// 相比于上面的代码，少了 i &lt; n 这个比较操作</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">++</span>i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 恢复 a[n - 1]</span>
    a<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当代码执行万次、几十万次时，省掉的一个比较语句积累的时间会比较明显。</p><p>上面只是举例说明哨兵的作用，写代码时不必写成第二段那样（可读性太差）。</p></details><h3 id="_4-4-重点留意边界条件处理" tabindex="-1"><a class="header-anchor" href="#_4-4-重点留意边界条件处理" aria-hidden="true">#</a> 4.4 重点留意边界条件处理</h3><ul><li>链表为空时</li><li>链表只包含一个结点时</li><li>链表只包含两个结点时</li><li>处理头结点 &amp; 尾结点时</li></ul><h3 id="_4-5-举例画图-辅助思考" tabindex="-1"><a class="header-anchor" href="#_4-5-举例画图-辅助思考" aria-hidden="true">#</a> 4.5 举例画图，辅助思考</h3><h3 id="_4-6-多写多练" tabindex="-1"><a class="header-anchor" href="#_4-6-多写多练" aria-hidden="true">#</a> 4.6 多写多练</h3><ul><li>单链表反转 206</li><li>链表中环的检测 141 快慢指针</li><li>两个有序链表的合并 21</li><li>删除链表倒数第 n 个结点 19 双指针（固定步数差值）</li><li>求链表的中间结点 876 快慢指针</li></ul>`,27),d=[i,o,c,r,u];function k(m,h){return t(),p("div",null,d)}const _=e(l,[["render",k],["__file","linked-list.html.vue"]]);export{_ as default};
