const e=JSON.parse('{"key":"v-c8b6f49c","path":"/code/data-structure-and-algorithm/queue.html","title":"队列","lang":"zh-CN","frontmatter":{"lang":"zh-CN","title":"队列","description":null,"article":false,"date":"2023-08-21T00:00:00.000Z"},"headers":[{"level":2,"title":"Introduction","slug":"introduction","link":"#introduction","children":[]},{"level":2,"title":"1. 阻塞队列","slug":"_1-阻塞队列","link":"#_1-阻塞队列","children":[]},{"level":2,"title":"2. 并发队列","slug":"_2-并发队列","link":"#_2-并发队列","children":[]},{"level":2,"title":"Q: 线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理","slug":"q-线程池没有空闲线程时-新的任务请求线程资源时-线程池该如何处理","link":"#q-线程池没有空闲线程时-新的任务请求线程资源时-线程池该如何处理","children":[]}],"git":{"createdTime":1692617079000,"updatedTime":1692617079000,"contributors":[{"name":"Sunshine","email":"hanzhuosoul@gmail.com","commits":1}]},"readingTime":{"minutes":2.91,"words":872},"filePathRelative":"code/data-structure-and-algorithm/queue.md","localizedDate":"2023年8月21日","excerpt":"<h2> Introduction</h2>\\n<p>栈：入栈（push）、出栈（pop）</p>\\n<p>队列：入队（enqueue）、出队（dequeue）</p>\\n<blockquote>\\n<p>队尾入队，队首出队</p>\\n</blockquote>\\n<p>循环队列、阻塞队列、并发队列。比如高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列；Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁。</p>\\n<p>循环队列：</p>\\n<ul>\\n<li>队空：head == tail</li>\\n<li>队满：(tail + 1)%n == head</li>\\n</ul>"}');export{e as data};
