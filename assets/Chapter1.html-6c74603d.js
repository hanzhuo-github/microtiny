import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as a,b as r}from"./app-9011bd5d.js";const i="/images/basic/network/section1/Lan.png",n="/images/basic/network/section1/stp.png",s="/images/basic/network/section1/vlan.png",l="/images/basic/network/section1/trunk.png",h={},c=r('<h2 id="_1-物理层-mac-层" tabindex="-1"><a class="header-anchor" href="#_1-物理层-mac-层" aria-hidden="true">#</a> 1. 物理层 &amp; MAC 层</h2><h3 id="_1-1-第一层-物理层" tabindex="-1"><a class="header-anchor" href="#_1-1-第一层-物理层" aria-hidden="true">#</a> 1.1 第一层（物理层）</h3><p>设备：集线器（Hub），广播</p><h3 id="_1-2-第二层-数据链路层" tabindex="-1"><a class="header-anchor" href="#_1-2-第二层-数据链路层" aria-hidden="true">#</a> 1.2 第二层（数据链路层）</h3><h4 id="mac-medium-access-control-媒体访问控制" tabindex="-1"><a class="header-anchor" href="#mac-medium-access-control-媒体访问控制" aria-hidden="true">#</a> MAC（Medium Access Control，媒体访问控制）</h4><ul><li>解决的是谁先发谁后发的问题，学名是<strong>多路访问</strong>。有很多算法解决这个问题： <ol><li>信道划分：分多个道，你走你的，我走我的</li><li>轮流协议：轮着来</li><li>随机接入协议（以太网就用的这种方式）：管他三七二十一，先出门，堵的话就回去</li></ol></li><li>判断发给谁，谁接收 <ul><li><p>链路层地址，也被称为 MAC 地址</p></li><li><p>第二层的网络包格式：</p><table><thead><tr><th style="text-align:center;">目标 MAC<br>（6 bytes）</th><th style="text-align:center;">源 MAC<br>（6 bytes）</th><th style="text-align:center;">类型<br>（2 bytes）</th><th style="text-align:center;">数据<br>（46-1500 bytes）</th><th style="text-align:center;">CRC<br>（4 bytes）</th></tr></thead></table><ul><li>类型：0800 - IP 数据报，0860 - ARP 请求</li><li>CRC 循环冗余检测：通过 XOR 异或来计算整个包是否在发送的过程中出现了了错误</li></ul></li></ul></li></ul><h4 id="arp-协议" tabindex="-1"><a class="header-anchor" href="#arp-协议" aria-hidden="true">#</a> ARP 协议</h4><p>问题：如果一个广播网络里面接入了 N 台机器，怎么知道每台机器的 MAC 地址呢？</p><p>答案：ARP 协议 - 根据 IP 地址找 MAC 地址的协议。这是一个输出全靠“吼”的阶段。</p><table><thead><tr><th style="text-align:center;">目标 MAC<br>（6 bytes）</th><th style="text-align:center;">源 MAC<br>（6 bytes）</th><th style="text-align:center;">类型<br>（2 bytes）</th><th style="text-align:center;">ARP 报文</th></tr></thead></table><p>过程：要发送数据的机器发送一个广播包，等目的 IP 对应的机器来回应自己。</p><p>ARP 报文格式：</p><table><thead><tr><th style="text-align:center;">硬件类型<br>（Ethernet）</th><th style="text-align:center;">协议类型<br>（IP）</th><th style="text-align:center;">硬件地址长度<br>（6）</th><th style="text-align:center;">协议地址长度<br>（6）</th><th style="text-align:center;">操作代码<br>（1 request 2 reply）</th><th style="text-align:center;">发送者 MAC</th><th style="text-align:center;">发送者 IP</th><th style="text-align:center;">目标 MAC</th><th style="text-align:center;">目标 IP</th></tr></thead></table><p>ARP 缓存：为了避免每次都用 ARP 请求，机器本地也会进行 ARP 缓存。由于机器会不断上线下线，IP 也可能会变，所以 ARP 的 MAC 地址缓存过一段时间就会过期。</p><h4 id="转发表" tabindex="-1"><a class="header-anchor" href="#转发表" aria-hidden="true">#</a> 转发表</h4><p>机器数少的时候，我们可以用集线器组网。集线器是广播的，每个端口不管是否需要该包，都会接收然后发给主机，然后让主机自己判断是否需要。当机器数多的时候，端口什么都接受什么都转发的话，会更容易产生冲突，而且把不需要的包转发出去纯属浪费。</p><p>我们需要稍微智能一点的设备，该设备每个口可以解析 MAC 头，检查下目标 MAC 地址，然后根据策略进行转发。即第二层设备：交换机。</p><p>交换机如何知道每个口的电脑的 MAC 地址呢？需要交换机会学习，学习的结果叫做<strong>转发表</strong>。</p><p>电脑 A 向电脑 B 发送一个包，当包到达交换机时，最开始交换机并不知道电脑 B 在哪个口，于是它只能将包发送给除了连接电脑 A 口以外的其他口。交换机聪明之处在于，它会记住，电脑 A（对应的MAC）在哪个口。以后遇到目的地址是电脑 A 的 MAC 地址时，直接发送到对应的口就行。</p><p>这样过了一段时间之后，交换机就有了整个网络的结构了，这时基本不用广播了，可以准确转发。</p><h3 id="_1-3-交换机与-vlan" tabindex="-1"><a class="header-anchor" href="#_1-3-交换机与-vlan" aria-hidden="true">#</a> 1.3 交换机与 VLAN</h3><p>下图是两台交换机连接三个局域网的情况。</p><div align="center"><img src="'+i+'" width="50%/"></div><p>当机器 1 向机器 4（已知其 IP）发送包的时候，目的 MAC 还不知道，所以需要先用 ARP 获取目的 MAC。</p><details class="hint-container details"><summary>简述交换机学习网络拓扑信息的过程</summary><p>现在两台交换机都不了解网络的任何拓扑信息。</p><p>机器 1 发起广播。机器 2 能收到，但是没它啥事。交换机 A 也收到了这个广播，此时它不知道网络的拓扑信息，于是它将该广播包转发给除了广播包来的方向之外的其他所有网口。</p><p>机器 3 也收到了信息，但是这和它也没啥关系。交换机 B 同样收到了该广播包，它也不知道网络的拓扑信息，于是它也按照广播策略将包转发到 LAN 3。此时，机器 4 和机器 5 都能收到广播信息。机器 4 主动响应，这是找我的，我的 MAC 是 blabla。于是一个 ARP 请求就完成了。</p><p>在上面的过程中，两台交换机都学到了这样的信息：机器 1 是在左边的网口。</p><p>下次当机器 2 要访问机器 1 时，先通过 ARP 获取机器 1 的 MAC 地址。知道目的 MAC 后，发送数据包。该消息会到达机器 1，也会到交换机 A。交换机已经知道了机器 1 不在右边的网口，于是这个广播信息不会广播到 LAN 2 和 LAN 3。</p></details><h4 id="环路问题-stp-协议" tabindex="-1"><a class="header-anchor" href="#环路问题-stp-协议" aria-hidden="true">#</a> 环路问题 &amp; STP 协议</h4><p>环路问题会导致 ARP 请求爆炸，且交换机无法学习到网络的拓扑结构。</p><p>数据结构中有<strong>最小生成树</strong>，有环的我们常称为<strong>图</strong>。将图中的环破坏了，就生成了<strong>树</strong>。计算机网络中生成树算法是STP（Spanning Tree Protocol）。</p><div align="center"><img src="'+n+'" width="50%/"></div><p>STP 中的概念：</p><ul><li>Root Bridge，根交换机</li><li>Designated Bridge，指定交换机</li><li>Bridge Protocol Data Unit，BPDU，网桥协议数据单元。“互相比较实例”的协议。只有 Root Bridge 可以发，其他交换机只能转。</li><li>Priority Vector，优先级向量。<code>[Root Bridge ID, Root Path Cost, Bridge ID, Port ID]</code>。在 BPDU 中。</li></ul><h4 id="广播问题-安全问题" tabindex="-1"><a class="header-anchor" href="#广播问题-安全问题" aria-hidden="true">#</a> 广播问题 &amp; 安全问题</h4><p><strong>物理隔离</strong>：使用单独的交换机配置单独的子网</p><p><strong>虚拟隔离</strong>，<strong>虚拟局域网（VLAN）</strong>：一个交换机上会连属于多个局域网的机器。</p><p>交换机如何区别某个机器属于哪个局域网呢？在原来的二层的头上加一个 TAG，里面有一个 VLAN ID，一共12位（可以划分 4096 个 VLAN）。这样仍然不够，目前云计算厂商例绝对不止 4096 个用户。当然每个用户需要一个 VLAN，后面章节再讲这个问题。</p><div align="center"><img src="'+s+'" width="50%/"></div><p>如果我们使用的交换机是支持 VLAN 的，当交换机把二层的头取下来时就可以识别 VLAN ID。这样，只有相同 VLAN 的包才会互相转发，不同 VLAN 的包是看不到的。</p><p>对于支持 VLAN 的交换机，有一种口叫 Trunk 口。它可以转发属于任何 VLAN 的数据，交换机之间可以通过这种口互相连接。</p><div align="center"><img src="'+l+'" width="50%/"></div>',39),o=[c];function d(p,g){return e(),a("div",null,o)}const m=t(h,[["render",d],["__file","Chapter1.html.vue"]]);export{m as default};
