const nt="ENTRIES",T="KEYS",V="VALUES",F="";class D{constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case V:return this.value();case T:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const h=u*i;t:for(const c of e.keys())if(c===F){const a=o[h-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let l=0;l<c.length;++l,++a){const p=c[l],f=i*a,g=f-i;let d=o[f];const m=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let _=m;_<y;++_){const b=p!==t[_],z=o[g+_]+ +b,A=o[g+_+1]+1,w=o[f+_]+1,L=o[f+_+1]=Math.min(z,A,w);L<d&&(d=L)}if(d>s)continue t}W(e.get(c),t,s,n,o,a,i,r+c)}};class C{constructor(t=new Map,s=""){this._size=void 0,this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=I(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=O(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=O(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,T)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,V)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},O=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return O(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const h=e.get(u);if(r===u.length)e=h;else{const c=new Map;c.set(u.slice(r),h),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=I(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=I(e);n.set(o+t,s),n.delete(o)},I=e=>e[e.length-1],it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",P="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},q=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,lt=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),q(n.terms,u)}}return e},[P]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);q(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d:h}=u;return Math.log(1+(s-t+.5)/(t+.5))*(h+e*(i+1)/(e+i*(1-r+r*n/o)))},dt=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},ft={k:1.2,b:.7,d:.5},gt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},H={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:ft},mt={combineWith:P,prefix:(e,t,s)=>t===s.length-1},pt={batchSize:1e3,batchWait:10},J={minDirtFactor:.1,minDirtCount:20},Ft={...pt,...J};class _t{constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?Ft:t.autoVacuum;this._options={...gt,...t,autoVacuum:s,searchOptions:{...H,...t.searchOptions||{}},autoSuggestOptions:{...mt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=J,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const yt=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},U=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},At=(e,t,s,n)=>{if(!e._index.has(n)){U(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?U(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(ht[s])||new Map},B=(e,t,s,n,o,u,i,r,h=new Map)=>{if(o==null)return h;for(const c of Object.keys(u)){const a=u[c],l=e._fieldIds[c],p=o.get(l);if(p==null)continue;let f=p.size;const g=e._avgFieldLength[l];for(const d of p.keys()){if(!e._documentIds.has(d)){At(e,l,d,s),f-=1;continue}const m=i?i(e._documentIds.get(d),s,e._storedFields.get(d)):1;if(!m)continue;const y=p.get(d),_=e._fieldLength.get(d)[l],b=at(y,f,e._documentCount,_,g,r),z=n*a*m*b,A=h.get(d);if(A){A.score+=z,ct(A.terms,t);const w=N(A.match,s);w?w.push(c):A.match[s]=[c]}else h.set(d,{score:z,terms:[t],match:{[s]:[c]}})}}return h},Ct=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((d,m)=>({...d,[m]:N(n.boost,m)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:h}=n,{fuzzy:c,prefix:a}={...H.weights,...i},l=e._index.get(t.term),p=B(e,t.term,t.term,1,l,o,u,h);let f,g;if(t.prefix&&(f=e._index.atPrefix(t.term)),t.fuzzy){const d=t.fuzzy===!0?.2:t.fuzzy,m=d<1?Math.min(r,Math.round(t.term.length*d)):d;m&&(g=e._index.fuzzyGet(t.term,m))}if(f)for(const[d,m]of f){const y=d.length-t.term.length;if(!y)continue;g==null||g.delete(d);const _=a*d.length/(d.length+.3*y);B(e,t.term,d,_,m,o,u,h,p)}if(g)for(const d of g.keys()){const[m,y]=g.get(d);if(!y)continue;const _=c*d.length/(d.length+y);B(e,t.term,d,_,m,o,u,h,p)}return p},K=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},l=t.queries.map(p=>K(e,p,a));return Y(l,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:h}=i,c=r(t).flatMap(a=>h(a)).filter(a=>!!a).map(dt(i)).map(a=>Ct(e,a,i));return Y(c,i.combineWith)},X=(e,t,s={})=>{const n=K(e,t,s),o=[];for(const[u,{score:i,terms:r,match:h}]of n){const c=r.length,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(h),match:h};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return o.sort(G),o},Et=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of X(e,t,s)){const r=i.join(" "),h=n.get(r);h!=null?(h.score+=u,h.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:h}]of n)o.push({suggestion:u,terms:r,score:i/h});return o.sort(G),o},zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:h,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const l=new _t(a);l._documentCount=t,l._nextId=s,l._documentIds=k(n),l._idToShortId=new Map,l._fieldIds=o,l._fieldLength=k(u),l._avgFieldLength=i,l._storedFields=k(r),l._dirtCount=h||0,l._index=new C;for(const[p,f]of l._documentIds)l._idToShortId.set(f,p);for(const[p,f]of e){const g=new Map;for(const d of Object.keys(f)){let m=f[d];c===1&&(m=m.ds),g.set(parseInt(d,10),k(m))}l._index.set(p,g)}return l},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let l="";i===0?l=c.length>20?`… ${c.slice(-20)}`:c:a?l=c.length+i>100?`${c.slice(0,100-i)}… `:c:l=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,l&&o.push(l),i+=l.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let h=s.indexOf(n,u);if(h===-1)return null;for(;h>=0;){const c=h+n.length;if(r(e.slice(u,h)),u=c,i>100)break;h=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return X(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,h=u.includes("@"),c=u.includes("#"),[a,l]=u.split(/[#@]/),{contents:p}=n[a]??={title:"",contents:[]};if(h)p.push([{type:"customField",key:a,index:l,display:i.map(f=>o.c.map(g=>j(g,f))).flat().filter(f=>f!==null)},r]);else{const f=i.map(g=>j(o.h,g)).filter(g=>g!==null);if(f.length&&p.push([{type:c?"heading":"title",key:a,...c&&{anchor:l},display:f},r]),"t"in o)for(const g of o.t){const d=i.map(m=>j(g,m)).filter(m=>m!==null);d.length&&p.push([{type:"text",key:a,...c&&{anchor:l},display:d},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=yt(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Et(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/en/\":{\"documentCount\":0,\"nextId\":0,\"documentIds\":{},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{},\"averageFieldLength\":[],\"storedFields\":{},\"dirtCount\":0,\"index\":[],\"serializationVersion\":2},\"/\":{\"documentCount\":257,\"nextId\":257,\"documentIds\":{\"0\":\"v-8daa1a0e\",\"1\":\"v-47394a38\",\"2\":\"v-47394a38#_1-快速介绍\",\"3\":\"v-47394a38#_2-属性的顺序\",\"4\":\"v-14dd182b\",\"5\":\"v-14dd182b#_1-symbols\",\"6\":\"v-14dd182b#_2-作用\",\"7\":\"v-14dd182b#_3-global-symbols\",\"8\":\"v-14dd182b#_3-1-symbol-for-key-读取-symbol\",\"9\":\"v-14dd182b#_3-2-symbol-keyfor-symbol-读取-description\",\"10\":\"v-14dd182b#_4-系统-symbol\",\"11\":\"v-14dd182b#总结\",\"12\":\"v-1c369cee\",\"13\":\"v-1c369cee#_1-symbol-iterator\",\"14\":\"v-1c369cee#_2-显示调用迭代器\",\"15\":\"v-1c369cee#_3-可迭代-iterable-v-s-类数组-array-like\",\"16\":\"v-1c369cee#_4-array-from\",\"17\":\"v-1c369cee#总结\",\"18\":\"v-333550ae\",\"19\":\"v-333550ae#_1-快速介绍\",\"20\":\"v-333550ae#不要用-比较数组\",\"21\":\"v-333550ae#_2-数组的方法\",\"22\":\"v-9e0cde30\",\"23\":\"v-9e0cde30#基本使用\",\"24\":\"v-9e0cde30#_1-export\",\"25\":\"v-9e0cde30#_2-import\",\"26\":\"v-9e0cde30#_3-export-使用-as\",\"27\":\"v-9e0cde30#_4-export-default\",\"28\":\"v-9e0cde30#_5-export-既有-default-又有命名实体\",\"29\":\"v-9e0cde30#_2-re-export\",\"30\":\"v-7bf9caeb\",\"31\":\"v-652d8e04\",\"32\":\"v-9f1cb90a\",\"33\":\"v-9f1cb90a#_1-概念\",\"34\":\"v-9f1cb90a#_2-notation\",\"35\":\"v-1c3d7e88\",\"36\":\"v-b398ee9c\",\"37\":\"v-b398ee9c#_1-准确性-accuracy\",\"38\":\"v-b398ee9c#_2-精确度-precision\",\"39\":\"v-b398ee9c#_3-召回率-recall\",\"40\":\"v-b398ee9c#_4-f1-分数-f1-score\",\"41\":\"v-5095a1d2\",\"42\":\"v-5095a1d2#_1-基本术语\",\"43\":\"v-5095a1d2#_2-现代字符编码模型\",\"44\":\"v-5095a1d2#_2-1-抽象字符表-acr-abstract-character-repertoire\",\"45\":\"v-5095a1d2#_2-2-编号字符集-ccs-coded-character-set\",\"46\":\"v-5095a1d2#_2-3-字符编码方式-形式-格式-规则-cef-character-encoding-form\",\"47\":\"v-5095a1d2#_2-4-字符编码模式ces-ces-character-encoding-scheme\",\"48\":\"v-5095a1d2#_2-5-传输编码语法-tes-transfer-encoding-syntax\",\"49\":\"v-5095a1d2#_2-6-小结\",\"50\":\"v-4d2bf094\",\"51\":\"v-4d2bf094#_1-ebcdic-码与-ascii-码\",\"52\":\"v-4d2bf094#_1-1-ebcdic-码\",\"53\":\"v-4d2bf094#_1-2-ascii字符编码方案简介\",\"54\":\"v-4d2bf094#_2-eascii-及-iso-8859-字符编码方案\",\"55\":\"v-4d2bf094#_2-1-eascii\",\"56\":\"v-4d2bf094#_2-2-iso-iec-8859\",\"57\":\"v-4d2bf094#_3-简体汉字编码方案-gbk2312、gbk-等\",\"58\":\"v-4d2bf094#_3-1-背景\",\"59\":\"v-4d2bf094#_3-2-gb2312\",\"60\":\"v-4d2bf094#_3-3-gbk\",\"61\":\"v-4d2bf094#_3-4-gb18030\",\"62\":\"v-4d2bf094#_3-5-小结\",\"63\":\"v-49c23f56\",\"64\":\"v-49c23f56#_1-概述\",\"65\":\"v-49c23f56#_1-1-bmp、sp\",\"66\":\"v-49c23f56#_1-2-utf-16\",\"67\":\"v-49c23f56#_1-3-码点名称\",\"68\":\"v-d623d08a\",\"69\":\"v-d623d08a#_1-协议三要素-语法、语义、顺序\",\"70\":\"v-d623d08a#_2-ip-和-cidr\",\"71\":\"v-d623d08a#_3-ip-addr-ifconfig\",\"72\":\"v-d623d08a#_4-ip-地址配置\",\"73\":\"v-d623d08a#_5-动态主机配置协议-dhcp-dynamic-host-configuration-protocol\",\"74\":\"v-d623d08a#dhcp-的工作方式\",\"75\":\"v-d623d08a#step-1-dhcp-discover\",\"76\":\"v-d623d08a#step-2-dhcp-offer\",\"77\":\"v-d623d08a#step-3-dhcp-request\",\"78\":\"v-d623d08a#step-4-dhcp-ack\",\"79\":\"v-d623d08a#_6-ip-地址回收和续租\",\"80\":\"v-d623d08a#_7-预启动执行环境-pxe-pre-boot-execution-environment\",\"81\":\"v-d623d08a#pxe-的工作过程\",\"82\":\"v-3e588d2c\",\"83\":\"v-c93be06c\",\"84\":\"v-c93be06c#复杂度分析\",\"85\":\"v-c93be06c#时间复杂度-空间复杂度\",\"86\":\"v-c93be06c#最好、最坏、平均、均摊时间复杂度\",\"87\":\"v-c93be06c#_1-最好情况时间复杂度-best-case-time-complexity-、最坏情况时间复杂度-worst-case-time-complexity\",\"88\":\"v-c93be06c#_2-平均情况时间复杂度-average-case-time-complexity\",\"89\":\"v-c93be06c#_3-均摊时间复杂度-amortized-time-complexity\",\"90\":\"v-68a607de\",\"91\":\"v-68a607de#_1-几种常见的链表结构\",\"92\":\"v-68a607de#_1-1-单链表\",\"93\":\"v-68a607de#_1-2-循环链表\",\"94\":\"v-68a607de#_1-3-双向链表\",\"95\":\"v-68a607de#_1-4-双向循环链表\",\"96\":\"v-68a607de#_2-数组-v-s-链表\",\"97\":\"v-68a607de#_3-用链表的应用\",\"98\":\"v-68a607de#_3-1-实现-lru\",\"99\":\"v-68a607de#_3-2-快慢指针\",\"100\":\"v-68a607de#_4-正确写出链表代码\",\"101\":\"v-68a607de#_4-1-理解指针或引用的含义-——-地址\",\"102\":\"v-68a607de#_4-2-警惕指针丢失和内存泄漏\",\"103\":\"v-68a607de#_4-3-利用哨兵简化实现难度\",\"104\":\"v-68a607de#_4-4-重点留意边界条件处理\",\"105\":\"v-68a607de#_4-5-举例画图-辅助思考\",\"106\":\"v-68a607de#_4-6-多写多练\",\"107\":\"v-c8b6f49c\",\"108\":\"v-c8b6f49c#introduction\",\"109\":\"v-c8b6f49c#_1-阻塞队列\",\"110\":\"v-c8b6f49c#_2-并发队列\",\"111\":\"v-c8b6f49c#q-线程池没有空闲线程时-新的任务请求线程资源时-线程池该如何处理\",\"112\":\"v-2bfb5101\",\"113\":\"v-2bfb5101#递归需要满足的-3-个条件\",\"114\":\"v-2bfb5101#如何编写递归代码\",\"115\":\"v-2bfb5101#递归代码要警惕堆栈溢出\",\"116\":\"v-2bfb5101#警惕重复计算\",\"117\":\"v-2bfb5101#将递归代码改为非递归代码\",\"118\":\"v-1f043171\",\"119\":\"v-1f043171#_1-冒泡、插入、选择\",\"120\":\"v-1f043171#_1-1-bubble-sort\",\"121\":\"v-1f043171#_1-2-insertion-sort\",\"122\":\"v-1f043171#_1-3-selection-sort\",\"123\":\"v-1f043171#_1-4-小结\",\"124\":\"v-1f043171#_2-归并排序-快速排序\",\"125\":\"v-1f043171#_2-1-merge-sort\",\"126\":\"v-1f043171#_2-2-quick-sort\",\"127\":\"v-1f043171#_2-3-比较\",\"128\":\"v-1f043171#_3-线性排序-桶排序、计数排序、基数排序\",\"129\":\"v-1f043171#_3-1-bucket-sort\",\"130\":\"v-1f043171#_3-2-counting-sort\",\"131\":\"v-1f043171#_3-3-radix-sort\",\"132\":\"v-1f043171#_4-实现通用、高性能的排序函数\",\"133\":\"v-1f043171#优化排序\",\"134\":\"v-bb09a2ca\",\"135\":\"v-bb09a2ca#栈的应用\",\"136\":\"v-bb09a2ca#函数调用栈\",\"137\":\"v-bb09a2ca#表达式求值\",\"138\":\"v-bb09a2ca#括号匹配\",\"139\":\"v-bb09a2ca#浏览器回退、前进\",\"140\":\"v-668a7906\",\"141\":\"v-668a7906#_1-nlp-介绍\",\"142\":\"v-668a7906#_1-1-术语-architectures-vs-checkpoints\",\"143\":\"v-668a7906#_2-transformers-能做什么\",\"144\":\"v-668a7906#_2-1-快速体验-🤗-transformers-库\",\"145\":\"v-668a7906#_2-2-局限性-偏见\",\"146\":\"v-668a7906#_3-transformer-背景知识\",\"147\":\"v-668a7906#_3-1-transformer-是语言模型-language-model\",\"148\":\"v-668a7906#_3-2-transformer-是大模型\",\"149\":\"v-668a7906#_3-3-迁移学习-transfer-learning\",\"150\":\"v-668a7906#_4-transformer-结构\",\"151\":\"v-668a7906#_4-1-注意力层-attention-layers\",\"152\":\"v-668a7906#_4-2-原始模型\",\"153\":\"v-668a7906#_5-小结\",\"154\":\"v-6320c7c8\",\"155\":\"v-6320c7c8#_1-pipeline-都做了什么\",\"156\":\"v-6320c7c8#_1-1-使用-tokenizer-进行预处理\",\"157\":\"v-6320c7c8#_1-2-model\",\"158\":\"v-6320c7c8#_1-2-1-model-输出-hidden-states-或-features-高维张量\",\"159\":\"v-6320c7c8#_1-2-2-model-heads\",\"160\":\"v-6320c7c8#_1-3-后处理\",\"161\":\"v-6320c7c8#_2-models\",\"162\":\"v-6320c7c8#_2-1-创建-transformer\",\"163\":\"v-6320c7c8#_2-1-1-不同的加载方法\",\"164\":\"v-6320c7c8#_2-1-2-保存方法\",\"165\":\"v-6320c7c8#_2-2-使用-transformer-进行推理-inference\",\"166\":\"v-6320c7c8#_3-tokenizers\",\"167\":\"v-6320c7c8#_3-1-tokenization-算法\",\"168\":\"v-6320c7c8#_3-1-1-word-based\",\"169\":\"v-6320c7c8#_3-1-2-character-based\",\"170\":\"v-6320c7c8#_3-1-3-subword-tokenization\",\"171\":\"v-6320c7c8#_3-2-加载-保存\",\"172\":\"v-6320c7c8#_3-3-编码-encoding\",\"173\":\"v-6320c7c8#_3-3-1-tokenization\",\"174\":\"v-6320c7c8#_3-3-2-将-tokens-转换为-input-ids\",\"175\":\"v-6320c7c8#_3-4-解码-decoding\",\"176\":\"v-6320c7c8#_3-5-小结\",\"177\":\"v-6320c7c8#_4-处理多个序列\",\"178\":\"v-6320c7c8#_4-1-批处理\",\"179\":\"v-6320c7c8#_4-2-填充-padding\",\"180\":\"v-6320c7c8#_4-3-attention-masks\",\"181\":\"v-6320c7c8#_4-4-长序列\",\"182\":\"v-6320c7c8#_5-tokenizer-api\",\"183\":\"v-6320c7c8#_5-1-特殊-token\",\"184\":\"v-6320c7c8#_5-2-小结\",\"185\":\"v-6320c7c8#总结\",\"186\":\"v-5fb7168a\",\"187\":\"v-5fb7168a#_1-处理数据\",\"188\":\"v-5fb7168a#_1-1-从-hub-中加载数据集\",\"189\":\"v-5fb7168a#_1-2-数据集预处理\",\"190\":\"v-5fb7168a#_1-3-动态填充-dynamic-padding\",\"191\":\"v-5fb7168a#_2-使用-trainer-api-进行微调\",\"192\":\"v-5fb7168a#_2-1-训练-training\",\"193\":\"v-5fb7168a#_2-2-评估-evaluation\",\"194\":\"v-5fb7168a#_3-使用-pytorch-训练\",\"195\":\"v-5fb7168a#_3-1-准备\",\"196\":\"v-5fb7168a#_3-1-1-数据加载器-dataloader-用于迭代批次\",\"197\":\"v-5fb7168a#_3-1-2-model\",\"198\":\"v-5fb7168a#_3-1-3-优化器-optimizer\",\"199\":\"v-5fb7168a#_3-1-4-学习率调度器-learning-rate-scheduler\",\"200\":\"v-5fb7168a#_3-2-training-loop\",\"201\":\"v-5fb7168a#_3-3-evaluation-loop\",\"202\":\"v-5fb7168a#_3-4-使用-🤗-accelerate-进行加速\",\"203\":\"v-5fb7168a#总结\",\"204\":\"v-5c4d654c\",\"205\":\"v-5c4d654c#_1-使用预训练模型\",\"206\":\"v-5c4d654c#_2-共享预训练模型\",\"207\":\"v-5c4d654c#_2-1-创建模型仓库\",\"208\":\"v-5c4d654c#_2-1-1-使用-push-to-hub-api\",\"209\":\"v-5c4d654c#_2-1-2-使用-huggingface-hub-python-库\",\"210\":\"v-5c4d654c#_2-1-3-使用-web-页面\",\"211\":\"v-5c4d654c#_2-2-上传-model-files\",\"212\":\"v-5c4d654c#_2-3-1-upload-file-方法\",\"213\":\"v-5c4d654c#_2-3-2-repository-类\",\"214\":\"v-5c4d654c#_2-3-3-git-based-方法\",\"215\":\"v-5c4d654c#_3-建立-model-card\",\"216\":\"v-5c4d654c#model-card-metadata\",\"217\":\"v-2d69903a\",\"218\":\"v-2d69903a#_1-处理不在-hugging-face-hub-上的数据集\",\"219\":\"v-2d69903a#_1-1-加载本地数据集\",\"220\":\"v-2d69903a#_1-2-加载远程数据集\",\"221\":\"v-2d69903a#_2-切片\",\"222\":\"v-2d69903a#_2-1-slicing-and-dicing-数据\",\"223\":\"v-2d69903a#_2-2-创建新列\",\"224\":\"v-2d69903a#_2-3-map-方法\",\"225\":\"v-0f0ad766\",\"226\":\"v-0f0ad766#_1-物理层-mac-层\",\"227\":\"v-0f0ad766#_1-1-第一层-物理层\",\"228\":\"v-0f0ad766#_1-2-第二层-数据链路层\",\"229\":\"v-0f0ad766#mac-medium-access-control-媒体访问控制\",\"230\":\"v-0f0ad766#arp-协议\",\"231\":\"v-0f0ad766#转发表\",\"232\":\"v-0f0ad766#_1-3-交换机与-vlan\",\"233\":\"v-0f0ad766#环路问题-stp-协议\",\"234\":\"v-0f0ad766#广播问题-安全问题\",\"235\":\"v-fabb23a2\",\"236\":\"v-fabb23a2#七种类型\",\"237\":\"v-fabb23a2#_1-undefined、null\",\"238\":\"v-fabb23a2#_2-string\",\"239\":\"v-fabb23a2#_3-number\",\"240\":\"v-fabb23a2#_4-symbol\",\"241\":\"v-fabb23a2#_5-object\",\"242\":\"v-fabb23a2#_6-类型转换\",\"243\":\"v-fabb23a2#_6-1-stringtonumber-number-str\",\"244\":\"v-fabb23a2#_6-2-numbertostring-string-num\",\"245\":\"v-fabb23a2#_6-3-object-to-primitive-conversion-对象-基本类型的转换-拆箱转换\",\"246\":\"v-fabb23a2#_6-4-基本类型-对象的转换-装箱转换\",\"247\":\"v-15217c36\",\"248\":\"v-2d0a776e\",\"249\":\"v-72c72144\",\"250\":\"v-7664c5fa\",\"251\":\"v-146a1089\",\"252\":\"v-1340a590\",\"253\":\"v-1340a552\",\"254\":\"v-0da66b30\",\"255\":\"v-ffbdf6be\",\"256\":\"v-093bfdbe\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1],\"2\":[2,43],\"3\":[2,44],\"4\":[1,35],\"5\":[2,23],\"6\":[2,53],\"7\":[3,12],\"8\":[7,29],\"9\":[7,17],\"10\":[3,17],\"11\":[1,42],\"12\":[2,59],\"13\":[3,86],\"14\":[2,44],\"15\":[9,43],\"16\":[3,45],\"17\":[1,44],\"18\":[1],\"19\":[2,81],\"20\":[3,23],\"21\":[2,229],\"22\":[2,4],\"23\":[1],\"24\":[2,12],\"25\":[2,12],\"26\":[4],\"27\":[3,8],\"28\":[5,32],\"29\":[3,42],\"30\":[1,12],\"31\":[2,9],\"32\":[1,2],\"33\":[2,85],\"34\":[2,67],\"35\":[1,1],\"36\":[1,25],\"37\":[3,14],\"38\":[3,16],\"39\":[3,16],\"40\":[4,68],\"41\":[2,4],\"42\":[2,106],\"43\":[2,2],\"44\":[8,20],\"45\":[7,83],\"46\":[11,46],\"47\":[8,69],\"48\":[8,30],\"49\":[3,34],\"50\":[2,4],\"51\":[5],\"52\":[3,14],\"53\":[3,82],\"54\":[6,31],\"55\":[3,21],\"56\":[4,45],\"57\":[6],\"58\":[3,76],\"59\":[3,47],\"60\":[2,29],\"61\":[3,36],\"62\":[3,16],\"63\":[3,4],\"64\":[2,23],\"65\":[3,81],\"66\":[4,44],\"67\":[3,33],\"68\":[1,3],\"69\":[5],\"70\":[4,81],\"71\":[4,166],\"72\":[3,65],\"73\":[8,20],\"74\":[2,7],\"75\":[4,34],\"76\":[4,28],\"77\":[4,39],\"78\":[4,19],\"79\":[3,20],\"80\":[8,101],\"81\":[2,46],\"82\":[1,23],\"83\":[1],\"84\":[1],\"85\":[2,44],\"86\":[4],\"87\":[9,28],\"88\":[7,31],\"89\":[6,13],\"90\":[1],\"91\":[2,6],\"92\":[2,17],\"93\":[3,13],\"94\":[3,23],\"95\":[3],\"96\":[5,45],\"97\":[2],\"98\":[4,23],\"99\":[3,7],\"100\":[2],\"101\":[4],\"102\":[3,5],\"103\":[3,64],\"104\":[2,5],\"105\":[4],\"106\":[3,15],\"107\":[1],\"108\":[1,33],\"109\":[2,18],\"110\":[2,26],\"111\":[4,41],\"112\":[1],\"113\":[3,5],\"114\":[1,36],\"115\":[1,46],\"116\":[1,41],\"117\":[1,33],\"118\":[1,34],\"119\":[4,2],\"120\":[3,72],\"121\":[4,61],\"122\":[4,39],\"123\":[3,45],\"124\":[3,2],\"125\":[4,113],\"126\":[3,86],\"127\":[3,50],\"128\":[5],\"129\":[4,38],\"130\":[4,59],\"131\":[3,15],\"132\":[3,35],\"133\":[1,24],\"134\":[1],\"135\":[1],\"136\":[1,11],\"137\":[1,19],\"138\":[1,14],\"139\":[2,21],\"140\":[3],\"141\":[3,27],\"142\":[5,34],\"143\":[3,8],\"144\":[6,71],\"145\":[3,49],\"146\":[3,23],\"147\":[7,24],\"148\":[4,2],\"149\":[5,15],\"150\":[3,59],\"151\":[6,25],\"152\":[3,49],\"153\":[2,25],\"154\":[4,31],\"155\":[3,6],\"156\":[4,115],\"157\":[3,59],\"158\":[9,35],\"159\":[4,46],\"160\":[3,66],\"161\":[2,15],\"162\":[4,61],\"163\":[3,39],\"164\":[3,36],\"165\":[6,47],\"166\":[2,9],\"167\":[4],\"168\":[4,69],\"169\":[5,39],\"170\":[4,26],\"171\":[4,69],\"172\":[4,37],\"173\":[3,28],\"174\":[7,18],\"175\":[5,34],\"176\":[3,12],\"177\":[2,7],\"178\":[3,110],\"179\":[5,74],\"180\":[4,93],\"181\":[2,80],\"182\":[3,13],\"183\":[4,60],\"184\":[3,50],\"185\":[1,22],\"186\":[2,21],\"187\":[2,33],\"188\":[4,83],\"189\":[3,144],\"190\":[6,81],\"191\":[5,42],\"192\":[5,147],\"193\":[4,127],\"194\":[4,43],\"195\":[3,47],\"196\":[5,40],\"197\":[4,31],\"198\":[5,22],\"199\":[8,42],\"200\":[4,56],\"201\":[3,56],\"202\":[6,116],\"203\":[1,26],\"204\":[5,21],\"205\":[2,14],\"206\":[2,19],\"207\":[3],\"208\":[7,107],\"209\":[7,62],\"210\":[6,3],\"211\":[4,17],\"212\":[6,36],\"213\":[4,62],\"214\":[5,126],\"215\":[4,41],\"216\":[3,30],\"217\":[4,39],\"218\":[6,32],\"219\":[2,69],\"220\":[3,26],\"221\":[2],\"222\":[6,403],\"223\":[2,73],\"224\":[4,16],\"225\":[1],\"226\":[4],\"227\":[4,4],\"228\":[5],\"229\":[6,42],\"230\":[2,49],\"231\":[1,45],\"232\":[4,65],\"233\":[3,38],\"234\":[2,37],\"235\":[1],\"236\":[1,7],\"237\":[3,17],\"238\":[2,36],\"239\":[2,76],\"240\":[2,22],\"241\":[2,31],\"242\":[2,9],\"243\":[6,38],\"244\":[6,15],\"245\":[10,19],\"246\":[6,1],\"247\":[1],\"248\":[1],\"249\":[2],\"250\":[1],\"251\":[1],\"252\":[1],\"253\":[1],\"254\":[1],\"255\":[1],\"256\":[2]},\"averageFieldLength\":[3.322957198443579,41.25452292181403],\"storedFields\":{\"0\":{\"h\":\"首页\"},\"1\":{\"h\":\"Object\"},\"2\":{\"h\":\"1. 快速介绍\",\"t\":[\"// 创建 let user = new Object() let user = {} user.name = \\\"John\\\" user.age = 10 delete user.age user[\\\"likes birds\\\"] = true delete user[\\\"likes birds\\\"] // 判断属性是否存在 alert(\\\"age\\\" in user) let key = \\\"age\\\" alert(key in user) let key = prompt(\\\"输入一个 user 属性\\\", \\\"name\\\") alert(user[key]) for (key in obj) { alert(key) alert(obj[key]) } function makeUser(name, age) { return { name, age, } } // 变量名不能是保留字 // 但 属性名没有这个限制 let obj = { for: 1, let: 2, return: 3, } alert( obj.for + obj.let + obj.return ) // 6 // 属性只能是 Symbol 或 Sting let obj = { 0: \\\"test\\\", // 箱单与 \\\"0\\\": \\\"test\\\" } alter(obj[\\\"0\\\"]) alter(obj[0]) \"]},\"3\":{\"h\":\"2. 属性的顺序\",\"t\":[\"整数属性会进行排序，其他属性按照创建的顺序显示。\",\"相关信息\",\"如果一个字符串可以和一个整数互相转换，那么它就是整数属性。\",\"// Number(...) 显式转换为数字 // Math.trunc 是内建的去除小数部分的方法。 alert( String(Math.trunc(Number(\\\"49\\\"))) ); // \\\"49\\\"，相同，整数属性 alert( String(Math.trunc(Number(\\\"+49\\\"))) ); // \\\"49\\\"，不同于 \\\"+49\\\" ⇒ 不是整数属性 alert( String(Math.trunc(Number(\\\"1.2\\\"))) ); // \\\"1\\\"，不同于 \\\"1.2\\\" ⇒ 不是整数属性 \",\"如果想让属性按照自定义的方式（非数值大小）显示，只需给键名前加一个 +。\",\"let codes = { \\\"+49\\\": \\\"Germany\\\", \\\"+41\\\": \\\"Switzerland\\\", \\\"+44\\\": \\\"Great Britain\\\", // .., \\\"+1\\\": \\\"USA\\\" }; for (let code in codes) { alert( +code ); // 49, 41, 44, 1 } \"]},\"4\":{\"h\":\"Symbol\",\"t\":[\"symbol 是唯一标识符的基本类型，用 Symbol([name]) 创建。\",\"symbol 的值总是不同的，这样我们可以用于“隐藏”对象属性。JavaScript 提供了系统 symbol，用 Symbol.* 进行访问，使用它们可以修改一些内建行为。\",\"如果想让同名 symbol 相等，需要用到全局注册表，用 Symbol.for(name) 获取以及注册，返回的是 symbol；用 Symbol.keyFor(symbol) 可以在全局注册表中寻找其 name。\",\"对象的 key 只能是 String 类型或 Symbol 类型。使用字符串做 key 容易造成属性名的冲突，ES 6 引入 Symbol 正是为了防止属性名冲突的。\"]},\"5\":{\"h\":\"1. Symbols\",\"t\":[\"let id = Symbol(); // 传入 description let id1 = Symbol(\\\"id\\\"); let id2 = Symbol(\\\"id\\\"); id1 == id2 // false \",\"Symbols 不能自动转化成 String\",\"Symbol 不能自动转换成 String，你可以用 toString() 方法，或者输出 symbol.description\",\"let id = Symbol(\\\"id\\\"); console.log(id); // TypeError console.log(id.toString()); // Symbol(id) console.log(id.description); // id \"]},\"6\":{\"h\":\"2. 作用\",\"t\":[\"当我们使用外部的 user 对象时，想为该对象增加属性时，使用 Symbol 可以避免属性名冲突，有效防止双方对该属性进行的重写覆盖。\",\"// another code let user = { id: 'Their Id', name: 'John', } \",\"let id = Symbol(\\\"id\\\") user[id] = \\\"Our Id\\\" \",\"我们定义对象的时候，如果使用 Symbol，应该是：\",\"let id = Symbol(\\\"id\\\"); let user = { name: \\\"John\\\", age: 30, [id]: 123 // not \\\"id\\\": 123 }; \",\"使用 for...in 遍历 key 或 Object.keys(obj) 时，Symbol 会被略过\",\"let id = Symbol(\\\"id\\\"); let user = { name: \\\"John\\\", age: 30, [id]: 123 }; for (let key in user) alert(key); // name, age Object.keys(user); // ['name', 'age'] \",\"想要获得 symbol 属性，可以用以下方法：\",\"Object.getOwnPropertySymbols(obj) 可以获取所有的 symbol 属性\",\"Reflect.ownKeys(obj) 可以返回对象所有键，包括 symbol\",\"Object.assign() 既拷贝 string，也拷贝 symbol\",\"let id = Symbol(\\\"id\\\"); let user = { [id]: 123 }; let clone = Object.assign({}, user); alert( clone[id] ); // 123 \",\"我们在拷贝或者合并对象时是希望对所有的属性做操作的。\"]},\"7\":{\"h\":\"3. Global symbols\",\"t\":[\"有时我们希望在不同的地方使用相同名字的 symbol 且它们对应的实体也是相同的。\",\"为了达到这个目的，我们需要使用全局 symbol 注册表（global symbol register），全局注册表中的 symbol 被称为全局 Symbol。\"]},\"8\":{\"h\":\"3.1 Symbol.for(key) 读取 symbol\",\"t\":[\"在注册表中读取 symbol 时使用 Symbol.for(key)。如果全局注册表中有 description 为 key 的 symbol，就会返回该 symbol，都则将创建一个新的 symbol（即创建了 Symbol(key)），并将其存储在注册表中。\",\"// 从全局注册表中读取 let id = Symbol.for(\\\"id\\\"); // 如果该 symbol 不存在，则创建它 // 再次读取（可能是在代码中的另一个位置） let idAgain = Symbol.for(\\\"id\\\"); // 相同的 symbol alert( id === idAgain ); // true \"]},\"9\":{\"h\":\"3.2 Symbol.keyFor(symbol) 读取 description\",\"t\":[\"// 通过 name 获取 symbol let sym = Symbol.for(\\\"name\\\"); let sym2 = Symbol.for(\\\"id\\\"); let local_sym = Symbol(\\\"local\\\") // 通过 symbol 获取 name alert( Symbol.keyFor(sym) ); // name alert( Symbol.keyFor(sym2) ); // id alert( Symbol.keyFor(local_sym) ); // undefined 只能查找全局注册表中的 symbol \"]},\"10\":{\"h\":\"4. 系统 symbol\",\"t\":[\"JavaScript 内置了很多系统 symbol，用 Symbol.* 来调用。我们可以用它们来微调对象的各个方面。\",\"Symbol.hasInstance\",\"Symbol.isConcatSpreadable\",\"Symbol.iterator\",\"Symbol.toPrimitive\",\"可以参考 iterables ，其中使用 Symbol.iterator 微调对象，以使得对象具有迭代性质。\"]},\"11\":{\"h\":\"总结\",\"t\":[\"symbol 是唯一标识符的基本类型，用 Symbol([name]) 创建。\",\"symbol 的值总是不同的，这样我们可以用于“隐藏”对象属性。JavaScript 提供了系统 symbol，用 Symbol.* 进行访问，使用它们可以修改一些内建行为。\",\"如果想让同名 symbol 相等，需要用到全局注册表，用 Symbol.for(name) 获取以及注册，返回的是 symbol；用 Symbol.keyFor(symbol) 可以在全局注册表中寻找其 name。\",\"注意：\",\"使用 for...in 遍历 key 或 Object.keys(obj) 时，Symbol 会被略过\",\"Object.getOwnPropertySymbols(obj) 可以获取所有的 symbol 属性\",\"Reflect.ownKeys(obj) 可以返回对象所有键，包括 symbol\",\"Object.assign() 既拷贝所有的属性，包括 symbol\"]},\"12\":{\"h\":\"Iterables 可迭代对象\",\"t\":[\"可以用 for...of 进行遍历的都是 可迭代对象（iterable）。它是通过 Symbol.iterator 实现的，该属性值是个函数，返回一迭代器（迭代器必须有 next() 函数，next() 函数返回 {done: Boolean, value: any}，当 done: true 时迭代结束）。\",\"String 和 Array 内部实现了 Symbol.iterable，它们内置的可迭代对象。用 for...of 对 String 进行遍历时，surrogate pairs 是可以被争取处理的。\",\"有索引和 length 属性的对象叫类数组（array-like）。\",\"Array.from(obj[, mapFn, thisArg]) 将可迭代对象或类数组 obj 转化为真正的数组。\",\"任何可以在 for...of 循环中使用的对象都是可迭代对象。例如，数组和字符串都是可迭代的。\",\"对象本身不是数组，如果它表示一个集合（list 或 set），那么我们会很自然地想使用 for..of 来遍历它。如何使得一个表示集合的对象可以被 for..of 遍历呢？\"]},\"13\":{\"h\":\"1. Symbol.iterator\",\"t\":[\"我们有这样一个对象，它表示数字区间，我们希望遍历该对象获取该数字区间的值。\",\"let range = { from: 1, to: 5, }; // 目标： // for (let num of range) ... num = 1, 2, 3, 4, 5 \",\"我们为对象增加一个名为 Symbol.iterator 的方法。\",\"当使用 for...of 时，它会调用这个方法（没有则会报错）。这个方法必须返回一个迭代器（iterator）——一个有 next 方法的对象。\",\"之后，for...of只对这个被返回的对象（即被返回的迭代器）进行操作。\",\"当 for...of 循环希望获取下一个数值时，它就调用这个对象的 next() 方法。\",\"next() 方法返回的结果的搁置必须是 {done: Boolean, value: any}，当 done=True 时，表示循环结束，否则 value 时下一个值。\",\"我们来看一下代码实现\",\"// 1. for..of 调用 Symbol.iteration 对应的函数 range[Symbol.iterator] = function() { // 返回迭代器 return { current: this.from, last: this.to, // 迭代器要有 next 方法 next() { if (this.current <= this.last) { return { done: false, value: this.current++ }; } else { return { done: true }; } } } } \",\"迭代器和它所迭代的对象是分开的\",\"range 本身没有 next() 属性\",\"迭代器是在 range[Symbol.iteration]() 被调用时生成的\",\"当然我们也可以让 range 直接成为一个迭代器：\",\"let range = { from: 1, to: 5, [Symbol.iterator]() { this.current = this.from; return this; } next() { if (this.current <= this.to) { return { done: false, value: this.current++ }; } else { return { done: true }; } } } \",\"但是这样的问题是，我们不能使用同时运行两个 for...of 了。因为同时进行循环的情况下他们共享迭代状态，而我们只有一个迭代器。不过并行执行 for...of 还是很罕见的。\",\"无穷迭代器\",\"可以创建无穷迭代器。比如设置 range.to = Infinity。\",\"对于无穷迭代器，我们可以使用 break 来停止。\"]},\"14\":{\"h\":\"2. 显示调用迭代器\",\"t\":[\"String 都是可迭代的，即可以使用 for...of 对其进行遍历。对于 SP 上的 surrogate pairs 也可以正常地处理。\",\"let str = '𝒳😂'; for (let char of str) { alert( char ); // 𝒳，然后是 😂 } \",\"下面我们直接使用迭代器本身来进行 for...of 遍历。\",\"let str = \\\"Hello\\\" // 实现 for (char of str) alert(char); 的效果 let iterator = str[Symbol.iterator](); while (true) { let result = iterator.next(); if (result.done) break; alert(result.value); // 输出字符 } \",\"这样做给了我们更多的控制权，不过很少这样做。比如，我们可以迭代一部分，做一些其他的操作，然后再继续迭代。\"]},\"15\":{\"h\":\"3. 可迭代（iterable）v.s. 类数组（array-like）\",\"t\":[\"iterables: 实现了 Symbol.iterator 方法的对象\",\"array-likes: 有索引和 length 属性的对象\",\"例如，String 它既是 iterable 也是 array-like。上面的 range 是 iterable 但不是 array-like。\",\"这里给一个 array-like 的对象：\",\"let arrayLike = { 0: \\\"apple\\\", 1: \\\"banana\\\", length: 2, } \",\"要注意，iterables 和 array-likes 都不是 array，没有 push、pop 等数组方法。\",\"但是对于 arrayLike 这个对象，我们可能会很自然地想到，如果能用 array 的方法就好了。\"]},\"16\":{\"h\":\"4. Array.from\",\"t\":[\"Array.from 可以将 iterables 和 array-likes 转成 array。\",\"Array.from 的完整语法为\",\"Array.from(obj[, mapFn, thisArg]) \",\"例：\",\"let arr = Array.from(range, num => num * num) alert(arr); // 1, 4, 9, 16, 25 \",\"对于 surrogate pairs，str 的 slice 方法不能正确处理，我们可以利用 Array.from 来做处理：\",\"function slice(str, start, end) { return Array.from(str).slice(start, end).join('') } let str = '𝒳😂𩷶' slice(str, 1, 3); // 😂𩷶 str.slice(1, 3); // \\\\uDCB3\\\\uD83D \"]},\"17\":{\"h\":\"总结\",\"t\":[\"可迭代对象（iterables）：可以用 for...of 进行遍历的对象 \",\"使用 Symbol.iterator 实现 \",\"obj[Symbol.iterator]() 的结果被称为 迭代器（iterator）\",\"迭代器必须有 next() 方法，它返回 {done: Boolean, value: any}，done:true 表明迭代结束，否则 value 就是 next 值。\",\"String 和 Array 是内置的可迭代对象。\",\"字符串迭代器可以正确处理 surrogate pair。\",\"类数组（array-like）：有索引和 length 属性的对象\",\"Array.from(obj[, mapFn, thisArg]) 将可迭代对象或类数组转化为真正的数组。\"]},\"18\":{\"h\":\"Array\"},\"19\":{\"h\":\"1. 快速介绍\",\"t\":[\"let arr = new Array(); let arr = []; let fruits = [\\\"Apple\\\", \\\"Orange\\\", \\\"Plum\\\"]; fruits[3] = \\\"Banana\\\"; alert(fruits[2]); // arr.at(i) 支持「负数」 alert(fruits[fruits.length - 1]) alert(fruits.at(-1)) /** push() pop() */ alert(fruits.pop()); // 删掉了 Banana，并将其 alert alert(fruits); // Apple, Orange, Plum fruits.push(\\\"Pear\\\"); // 相当于 fruits[fruits.length] = \\\"Pear\\\" alert(fruits); // Apple, Orange, Plum, Pear /** shift() unshift() */ alert(fruits.shift()); // 删掉了 Apple， 并将其 alert alert(fruits); // Orange, Plum, Pear fruits.unshift('Apple'); alert( fruits ); // Apple, Orange, Plum, Pear // push() 和 unshift() 可以一次添加多个元素 let fruits = [\\\"Apple\\\"]; fruits.push(\\\"Orange\\\", \\\"Peach\\\"); fruits.unshift(\\\"Pineapple\\\", \\\"Lemon\\\"); alert( fruits ); // [\\\"Pineapple\\\", \\\"Lemon\\\", \\\"Apple\\\", \\\"Orange\\\", \\\"Peach\\\"] /** 循环 */ let arr = [\\\"Apple\\\", \\\"Orange\\\", \\\"Pear\\\"]; // 1. for for (let i = 0; i < arr.length; i++){ alert(arr[i]) } // 2. for ... of 只获取元素，不获取索引 for ( let fruit of fruits) { alert(fruit) } // 3. for ... in 获取索引 // 适用于普通对象并做了对应优化，但是不适用于数组，速度要慢 10-100 倍 for (let key in fruits) { alert(fruits[key]) } /** length */ // 显示地将 length 减小再恢复原长，此过程不可逆（被截断的元素并不会找回来，是 undefined） // 清空数组最简单的方式 arr.length = 0 // 多维数组 let matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]; /** toString() */ // 以逗号连接数组中的元素 let arr = [1, 2, 3]; alert( arr ); // 1,2,3 alert( String(arr) === '1,2,3' ); // true // 数组没有 Symbol.toPrimitive，也没有 valueOf，只能执行 toString 进行转换 alert( [] + 1 ); // \\\"1\\\" alert( [1] + 1 ); // \\\"11\\\" alert( [1,2] + 1 ); // \\\"1,21\\\" \"]},\"20\":{\"h\":\"不要用 == 比较数组\",\"t\":[\"仅当两个对象引用的是同一个对象时，它们才相等 ==\",\"如果 == 两边一个是对象、一个是基本类型，那么该对象会被转换为原始类型\",\"null == undefined\",\"// 左边是基本类型，右边是数组，于是数组被转换成了基本类型: '' 0 == []; // true，'' 被转换成了数字0 '0' == []; // false，'' 不需要进一步进行类型转化，它们是不同的字符串 \",\"数组可以逐项比较，用 for 循环或迭代来进行。\"]},\"21\":{\"h\":\"2. 数组的方法\",\"t\":[\"上面已经介绍了 push(), pop(), shift(), unshift()。\",\"arr.splice(start[, deleteCount, elem1, ..., elemN])\",\"改变原数组，添加、删除、插入都可以完成\",\"从 start 开始修改，删除 deleteCount 个元素，并在当前位置插入 elem1, ..., elemN\",\"返回被删除的元素所组成的数组\",\"允许负向索引\",\"let arr = [1, 2, 5]; arr.splice(-1, 0, 3, 4); alert( arr ); // 1,2,3,4,5 \",\"arr.slice([start], [end])\",\"不改变原数组，将 [start, end) 区间的元素复制到新的数组中\",\"start 和 end 都可以是负数\",\"arr.concat(arg1, arg2...)\",\"不改变原数组。创建新数组，其中包含来自于其他数组和其他项的值\",\"接受任意数量的参数，数组或值都行\",\"`argN` 是数组时，其中的所有元素都会被复制；否则，复制参数本身\",\"let arr = [1, 2]; alert( arr.concat([3, 4]) ); // 1,2,3,4 alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6 alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6 \",\"对于对象（即使是类数组对象），由于它不是数组，所以会被当做元素直接添加\",\"let arr = [1, 2]; let arrayLike = { 0: \\\"something\\\", length: 1 }; alert( arr.concat(arrayLike) ); // 1,2,[object Object] \",\"如果类数组中有 Symbol.isConcatSpreadable 属性，那么它会被当做一个数组来处理：\",\"let arr = [1, 2]; let arrayLike = { 0: \\\"something\\\", 1: \\\"else\\\", [Symbol.isConcatSpreadable]: true, length: 2 }; alert( arr.concat(arrayLike) ); // 1,2,something,else \",\"arr.forEach(function(item, index, array) {...});\",\"indexOf(item, from)、lastIndexOf(item, from)、includes(item, from)\",\"都使用 === 进行比较\",\"includes() 可以正确处理 NaN，而另外两个不能\",\"arr.find(function(item, index, array) {...});\",\"返回满足条件的第一个元素 \",\"如果返回 true，则返回 item 并停止迭代\",\"如果为假值，则返回 undefined\",\"arr.findIndex、arr.findLastIndex 和 arr.find 有相同的语法，但是返回的是元素的索引而不是元素本身，没找到则返回 -1。\",\"arr.filter(function(item, index, array) {...});\",\"返回满足条件的元素组成的数组 \",\"如果 true， item 被 push 到 results，迭代继续\",\"如果什么都没找到，则返回空数组\",\"arr.map(function(item, index, array) {...});\",\"arr.sort()\",\"对数组进行**原位（in-place）**排序\",\"返回排序后的数组，但由于修改了数组本身（in-place 的含义），所以这个返回值一般会被忽略\",\"默认情况下按照字符串进行排序\",\"let arr = [ 1, 2, 15 ]; arr.sort(); alert( arr ); // 1, 15, 2 \",\"可以自定义顺序进行排序，提供一个函数作为 arr.sort() 的参数 \",\"比较函数要返回：正数表示大于，负数表示小于\",\"let arr = [ 1, 2, 15 ]; arr.sort((a, b) => a - b); alert(arr); // 1, 2, 15 \",\"arr.reverse() 颠倒顺序\",\"split 和 join\",\"str.split(delim[, arrLength])\",\"arr.join(glue)\",\"reduce/reduceRight 根据数组计算单个值\",\"语法：arr.reduce(function(accumulator, item, index, array) {...}, [initial]);\",\"accumulator: 上一个函数调用的结果，第一次等于 initial（如果提供了的话），如果没有提供，那么会将数组的第一个元素作为初始值，并从第二个元素开始迭代\",\"item: 当前的数组元素\",\"index: 当前索引\",\"arr: 数组本身\",\"reduceRight 从右到左\",\"Array.isArray(value) 判断 value 是否为数组。对数组用 typeof(value) 只能得到 object。\",\"arr.some(fn)、arr.every(fn) 检查是否「存在/所有」元素满足 fn\",\"arr.fill(value, start, end) 从索引 start 到 end，用重复的 value 填充数组\",\"arr.copyWithin(target, start, end) 将位置 start 到 end 的所有元素复制到自身的 target 位置（覆盖现有元素）\",\"arr.flat(depth)/arr.flatMap(fn) 从多维数组创建一个新的扁平数组。\",\"Array.of(element0[, element1[, …[, elementN]]]) 基于可变数量的参数创建一个新的 Array 实例，而不需要考虑参数的数量或类型。\",\"注：几乎所有函数的数组方法，比如 find，filter，map，除了 sort 是一个特例，都接受一个可选的附加参数 thisArg。\",\"`thisArg`\",\"下面是完整的语法\",\"arr.find(func, thisArg); arr.filter(func, thisArg); arr.map(func, thisArg); ... \",\"使用 army 的方法 canJoin() 作为过滤器，thisArg 用于传递上下文\",\"let army = { minAge: 18, maxAge: 27, canJoin(user) { return user.age >= this.minAge && user.age < this.maxAge; } }; let users = [ {age: 16}, {age: 20}, {age: 23}, {age: 30} ]; // 找到 army.canJoin 返回 true 的 user // 如果不传 army 作为 thisArg，那么 this.canJoin 将被作为独立函数调用，this 是 undefined // 也可以用 users.filter(user => army.canJoin(user)) 这是是 army 调用的，于是 this 是 army let soldiers = users.filter(army.canJoin, army); alert(soldiers.length); // 2 alert(soldiers[0].age); // 20 alert(soldiers[1].age); // 23 \"]},\"22\":{\"h\":\"Export & Import\",\"t\":[\"export 和 import 的用法\"]},\"23\":{\"h\":\"基本使用\"},\"24\":{\"h\":\"1. export\",\"t\":[\"直接在变量、函数、class 前面加 export 即可。注：export function 和 class 时，不需要在最后加分号。\"]},\"25\":{\"h\":\"2. import\",\"t\":[\"不用担心引入得太多\",\"使用现代构建工具（如 webpack 等）时，它们会将 modules 打包到一起并进行优化以加速 loading。它们也会将没有用到过的引用移除掉。\"]},\"26\":{\"h\":\"3. export 使用 as\"},\"27\":{\"h\":\"4. export default\",\"t\":[\"import User from './user.js'; new User('John'); \"]},\"28\":{\"h\":\"5. export 既有 default 又有命名实体\",\"t\":[\"// 📁 user.js export default class User { constructor(name) { this.name = name; } } export function sayHi(user) { alert(`Hello, ${user}!`); } \",\"使用 default 导出时，import 时不需要加 {}，且 import 时可以是任何名称（最好和文件同名）。\",\"Named export\",\"Default Export\",\"export class User {...}\",\"export default class User {...}\",\"import {User} from ...\",\"import User from ...\",\"使用 export default 时，可以不指定被导出实体的名称：\",\"export default function (user) { // 没有 function name alert(`Hello, ${user}`) } \"]},\"29\":{\"h\":\"2. Re-export\",\"t\":[\"语法：export ... from ...\",\"export {sayHi} from './say.js'; // re-export sayHi export {default as User} from './user.js'; // re-export default \",\"当我们写 package 的时候，一个文件下面有很多 modules，我们会将所有的功能在统一的位置进行 export。这样其他人在使用该包的时候，可以从统一的位置进行 import。\",\"现在我们有 auth 这个包，index.js 作为唯一的出口。auth 文件夹下其他的 modules 都从 index.js 的位置进行 export。\",\"对于 default export，在进行 re-export 时需要进行单独处理。\",\"对于 user.js 中的 default export:\",\"export default class User { //.. } \",\"使用 export User from './user.js' 是不行的。我们应该使用 export { default as User } from './user.js'.\",\"使用 export * from './user.js' 进行的 re-export 只会导出 named export，会忽略 default export。\",\"export * from './user.js'; // 导出了 named export export { default } from './user.js'; // 导出了 default export \"]},\"30\":{\"h\":\"介绍\",\"t\":[\"本模块用于记录 Hugging Face NLP Course 的学习过程。\",\"主要围绕以下四部分展开：\",\"🤗 Transformers\",\"🤗 DataSets\",\"🤗 Tokenizers\",\"🤗 Accelerate\"]},\"31\":{\"h\":\"读书笔记-统计学习导论\",\"t\":[\"书是开源的，访问 An Introduction to Statistical Learning 获得。\"]},\"32\":{\"h\":\"简介\",\"t\":[\"本篇文章记录了一些相关概念以及 notation\"]},\"33\":{\"h\":\"1. 概念\",\"t\":[\"error term: 误差项，has mean zero\",\"lease squares 最小二乘法 -> linear regression -> continuous or quantitative values\",\"linear discriminant analysis 线性判别分析, logistic regression -> non-numerical value: categorical or qualitative values\",\"generalized liner model: entire class of statistical learning methods that include both linear and regression\",\"classification and regression trees, generalized additive models 广义加性模型\",\"neural network, support vector machine\",\"scalar 标量\",\"K-nearest neighbor classifier\",\"cross-validation, bootstrap\",\"stepwise selection, ridge regression, principal components regression, lasso\",\"non-linear statistical learning\",\"non-linear additive models\",\"tree-based methods: bagging, boosting, random forests\",\"support vector machines: a set of approaches for performing both linear and non-linear classification\",\"deep learning\",\"survival analysis\",\"unsupervised\",\"principal components analysis, K-means clustering, hierarchical clustering\",\"multiple hypothesis testing 多重假设检验\"]},\"34\":{\"h\":\"2. Notation\",\"t\":[\"n: The number of distinct data points/observations\",\"p: the number of variables that are available for use in making predictions\",\"xi​j: the value of the jth variable for the ith observation\",\"X: n×p matrix\",\"X=​x11​x21​⋮xn1​​x12​x22​⋮xn2​​⋯⋯⋱⋯​x1p​x1p​⋮xnp​​​\",\"xi​: the rows of X. A vector of length p\",\"xi​=​xi​1xi​2⋮xi​p​​\",\"X=​x1T​x2T​⋮xnT​​​\",\"xj​: the column of X\",\"xj​=​x1​jx2​j⋮xn​j​​\",\"X=(x1​​x1​​⋯​xp​​)\",\"yi​:\",\"y=​y1​y2​⋮yn​​​\",\"长度为 n 的向量：小写加粗\",\"长度非 n 的向量：小写\",\"标量：小写\",\"矩阵：大写粗体\",\"随机变量：大写\",\"一些标记：\",\"标量：a∈R\",\"a vector of length k：a∈Rk\",\"r×s 矩阵：A∈Rk×s\",\"input: predictors, independent variables, features, variables\",\"output: response, dependent variable\"]},\"35\":{\"h\":\"jjj\",\"t\":[\"dfsjh\"]},\"36\":{\"h\":\"机器学习的评价指标\",\"t\":[\"在评价一个二分类的机器学习模型的性能时，我们通常可以选择 Accuracy、Precision、Recall、F1 Score 等指标。\",\"使用分类器做预测后，可以绘出混淆矩阵（Confusion Matrix）：\",\"True Positive (TP): 把正样本成功预测为正。\",\"True Negative (TN)：把负样本成功预测为负。\",\"False Positive (FP)：把负样本错误地预测为正。\",\"False Negative (FN)：把正样本错误的预测为负。\"]},\"37\":{\"h\":\"1. 准确性 Accuracy\",\"t\":[\"Accuracy=TP+TN+FP+FNTP+TN​\",\"from sklearn.metric import accuracy_score print('Accuracy: %.3f' % accuracy_score(y_test, y_pred)) \"]},\"38\":{\"h\":\"2. 精确度 Precision\",\"t\":[\"Precision=TP+FPTP​\",\"在预测为Positive的所有数据中，真实Positve的数据到底占多少\",\"from sklearn.metric import precision_score print('Precision: %.3f' % precision_score(y_test, y_pred)) \"]},\"39\":{\"h\":\"3. 召回率 Recall\",\"t\":[\"Recall=TP+FNTP​\",\"在所有的Positive数据中，到底有多少数据被成功预测为Positive\",\"from sklearn.metric import recall_score print('Recall: %.3f' % recall_score(y_test, y_pred)) \"]},\"40\":{\"h\":\"4. F1-分数 F1 Score\",\"t\":[\"F1−score=Precision+Recall2×Precision×Recall​\",\"F1 Score 是 Precision 和 Recall 的综合考量。它赋予Precision score和Recall Score相同的权重，以衡量其准确性方面的性能，使其成为准确性指标的替代方案。\",\"from sklearn.metric import f1_score print('Recall: %.3f' % f1_score(y_test, y_pred)) \",\"Recall v.s. Precision[^first]\",\"Recall > Precision:\",\"当 FN 的成本代价很高，希望尽量避免产生 FN 时，应该着重考虑提高Recall指标。 例如，癌症诊断场景中，False Negative 是得了癌症的病人没有被诊断出癌症，这种情况是最应该避免的。我们宁可把健康人误诊为癌症 (FP)，也不能让真正患病的人检测不出癌症 (FN) 而耽误治疗离世。所以，癌症诊断系统的目标是：尽可能提高Recall值，哪怕牺牲一部分Precision。\",\"Precision > Recall:\",\"当 FP 的成本代价很高，希望尽量避免产生 FP 时，应该着重考虑提高Precision指标。 例如，垃圾邮件分类时，垃圾邮件为Positive，正常邮件为 Negative，False Positive 是把正常邮件识别为垃圾邮件，这种情况是最应该避免的。我们宁可把垃圾邮件标记为正常邮件 (FN)，也不能让正常邮件直接进垃圾箱 (FP)。于是，垃圾邮件分类的目标是：尽可能提高Precision值，哪怕牺牲一部分recall。\",\"继续以癌症诊断场景为，FP 是将没有患癌症的人诊断为癌症，虽然这不致命，但是会给患者带来麻烦\",\"参考：多分类模型Accuracy, Precision, Recall和F1-score的超级无敌深入探讨\"]},\"41\":{\"h\":\"1. 术语\",\"t\":[\"本系列文章是对知乎专栏「刨根问底字符编码」 的学习记录。\"]},\"42\":{\"h\":\"1. 基本术语\",\"t\":[\"位（bit, binary digit），表示为 b，亦称二进制位、比特位、位元，指二进制数中的一位。\",\"位串（bit string）：一连串的位\",\"字节（byte），表示为 B，又称位元组：\",\"半字节（nibble）：4个 bit\",\"字节（byte）：8个 bit。有时用 8 位组（Octet）来强调 8 比特串\",\"字（word）、双字（Dword, double word）、四字（Qword, Quad word）、十字（Tbyte, Ten byte）\",\"现代 PC 一般以字节为单位，称为为按字节编址，因此字节一般也是存储器的最小存取单位以及处理器的最小寻址单位。 这与字符编码关系密切，比如码元的单字节与多字节、字节序的大端序与小端序等，都与以字节为基础的基本数据类型密切相关。\",\"字与字长\",\"字（word）：作为一整个整体来处理或运算的一串比特位，通常分为若干字节\",\"字长：字的长度（位数），决定了 CPU 一次操作实际处理的比特位数量。字长由 CPU 对外数据通路的数据总线宽度决定。\",\"一般来说，计算机可以最高效处理的数据大小应该与其字长相同。 桌面平台的处理器字长基本是 64 位，嵌入式平台 32 位，在某些专业领域（高端显卡等）64位甚至高达128位、256位。\",\"编码（encode）：信息从一种形式转换为另一种形式的过程\",\"解码（decode）：编码的逆过程\",\"字符集（character set、charset）\",\"字符编码（character encoding）：将字符集中的字符按一定方式编码为某指定集合中的某一对象的过程。\",\"字符编码模型（character encoding model）：反应字符编码系统的构成特点和个构成部分之间相互关系的模型框架。\",\"ASCII：传统字符编码模型。将字符集中的字符进行编号，编号就是该字符的编码\",\"统一码（Unicode）、通用字符集（UCS）：现代字符编码模型\",\"现代字符编码模型：\",\"有哪些字符\",\"这些字符的编号是什么\",\"这些编号如何编码成一系列逻辑层面有限大小的数字，即码元序列\",\"这些逻辑层面的码元序列如何转换为（即映射为）物理层面的字节序列(即字节流)\",\"在某些特殊的传输环境中（比如Email中），再进一步将字节序列进行适应性编码处理\",\"核心思想：创建一个能够用不同方式来编码的通用字符集\"]},\"43\":{\"h\":\"2. 现代字符编码模型\",\"t\":[\"现代字符编码模型分为了5个层次：\"]},\"44\":{\"h\":\"2.1 抽象字符表（ACR, Abstract Character Repertoire）\",\"t\":[\"明确字符的范围（即确定支持哪些字符）\",\"无序\",\"不同于具有特定字型的“具体”字符，“抽象”字符不具有特定的字形。\",\"字符表可以是封闭的（如ASCII字符表、ISO/IEC 8859系列），也可以是开放的（如 Unicode、Code Page 代码页）\"]},\"45\":{\"h\":\"2.2 编号字符集（CCS, Coded Character Set）\",\"t\":[\"用数字编号表示字符（即用数字给抽象字符表ACR中的字符进行编号），CCS 常简称为字符集\",\"将抽象字符表 SCR 中的每个抽象字符表示为 1 个非负整数 N 或者映射到 1 个坐标（非负整数值对 x, y），映射的结果就是编号字符集 CCS。\",\"由此产生了编号空间（code space），一般翻译为代码空间、码空间、码点空间\",\"编号空间可以用以下方式进行描述\",\"(x,y)：GB2312的汉字编号空间是94 x 94\",\"N：ISO-8859-1的编号空间是256\",\"存储单元尺寸：ISO-8859-1是一个8比特的编号空间（28=256）\",\"子集：如行、列、面（Plane平面、层面）等等\",\"码点（code point 或 code position）：码点空间中的位置\",\"还经常会用“码点”来指代“码点值”，需要根据上下文进行判断\",\"码点值（或码点编号）：一个字符占用的码点所在的坐标或非负整数，即该字符的编号\",\"在 Unicode 编码方案中，字符码点又称为 Unicode 标量值（Unicode Scalar Value）\",\"字符编号不完全等同于码点编号（即码点值）\",\"一般编号字符集 CCS 里的码点数量要大于抽象字符表 ACR 中的字符数量。 在编号字符集中，除了字符码点之外，还有非字符码点和保留码点\",\"在 Unicode 标准中，一个抽象字符可能对应多个码点，也可能使用多个码点组成的序列来表示。\",\"如码点编号为U+51C9与U+F979的这两个码点实际上是同一个字符“凉”，这是为了兼容韩国字符集标准KS X 1001:1998。再如 aˋ，由码点编号为U+0061的基本字符字母 a 和码点编号为U+0300的组合字符读音符号 ˋ 所共同组成。\"]},\"46\":{\"h\":\"2.3 字符编码方式/形式/格式/规则（CEF, Character Encoding Form）\",\"t\":[\"将字符编号编码为逻辑上的码元序列（即逻辑字符编码）\",\"也被称为存储格式（Storage Format）\",\"以 Unicode 为例，它的 CCS 所需的码点数量赎回不断增加的，而计算机所能表示的整数范围却是有限的。如何通过相对有限的整型数来可扩展地表示可能会无限增长的字符数量？对于 ASCII 字符编码等早期广泛应用的编码方案，如何做兼容？这就是 CEF 要解决的问题。\",\"CEF 就是将 CCS 中的码点值（码点编号、字符编号）转化成有限比特长度的编码值（字符编码）。\",\"这个编码值是码元的序列（code unit sequence）。\",\"码元（code unit）\",\"CEF 虽然也被称为存储格式，但是它只涉及逻辑层面、与特定的计算机系统平台无关的编码方式，尚未涉及到物理层面上、与特定计算机系统平台有关的存储方式\",\"UTF-8、UTF-16、UTF-32 等，都是 Unicode 字符集（编号字符集 CCS）常用的字符编码方式（CEF）\"]},\"47\":{\"h\":\"2.4 字符编码模式CES（CES, Character Encoding Scheme）\",\"t\":[\"将逻辑上的码元序列映射为物理上的字节序列（字节流，即物理字符编码）\",\"也称作序列化模式（Serialization Format）\",\"经过编码后的字符能在计算机中进行处理、存储和传输\",\"CEF 是跟特定计算机系统平台无关的逻辑意义上的编码过程，而 CES 就属于跟特定计算机系统平台有关的物理意义上的编码过程。\",\"由于硬件平台与操作系统设计上的历史原因，对于U TF-16、UTF-32 等采用多字节码元的编码方式而言，必须使用一个原先称之为**零宽度不中断空格(ZERO WIDTH NO-BREAK SPACE)**的字符（Unicode字符编号为 0xFEFF，用来指定字节序 （Byte-Order 或 Endianness，也称字节顺序、位元组顺序），是大端序还是小端序），计算机才能够正确地进行处理、存储和传输。\",\"对于 UTF-8 这种采用单字节码元的编码方式来说，并不存在字节序问题，无需指明字节序。所以在各种计算机系统平台中，UTF-8 编码的码元序列与字节序列都是相同的。\",\"编码（encode）可能指 CEF 也可能是指 CES，解码（decode）也存在对应的两种可能。\",\"编码（encoding）就相应的可能指码元序列，也可能指字节序列。\",\"程序员更多接触到的是 CES 将码元序列进一步编码所形成的 字节序列，这是物理意义上的最终编码\",\"通过 CEF 编码后得到的码元序列，更多的是逻辑意义上的中间编码，一般不和它直接打交道。\",\"第五层的 TES 所形成的编码用于某些特殊的传输环境，打交道机会也比较少。\"]},\"48\":{\"h\":\"2.5 传输编码语法（TES, Transfer Encoding Syntax）\",\"t\":[\"用将字节序列作进一步的适应性编码处理\",\"在某些特殊传输环境中，需要对 CES 所提供的字节序列（字节流）进一步进行适应性编码。一般有两种处理方式：\",\"把字节序列映射到一套更受限制的值域内，以满足该特殊环境的限制。\",\"如用于 Email 传输的 Base64 编码或者 quoted-printable 编码（即可打印字符引用编码），都是把8位的字节映射为7位长的数据。\",\"Email 协议的设计仅能传输 7 位 ASCII 字符。\",\"压缩字节序列的值\",\"如 LZW 或者进程长度编码等无损压缩技术。\"]},\"49\":{\"h\":\"2.6 小结\",\"t\":[\"同一个字符，因多个不同的字符编码方式 CEF（如 UTF-8、UTF-16、UTF-32 等），会有不同的码元序列（Code Unit Sequence）\",\"同一个码元序列，因 2 个不同的字符编码模式 CES（大端、小端），可能具有 2 个不同的字节序列（Byte Sequence）\",\"不同的码元序列或是字节序列，只要表示的是同一个字符，name对应的**码点值（码点编号、字符编号）**一般都是相同的（在Unicode标准中，为了与其它标准兼容，有少数字符可能与多个码点对应）\"]},\"50\":{\"h\":\"2. 字符编码\",\"t\":[\"本系列文章是对知乎专栏「刨根问底字符编码」 的学习记录。\"]},\"51\":{\"h\":\"1 EBCDIC 码与 ASCII 码\"},\"52\":{\"h\":\"1.1 EBCDIC 码\",\"t\":[\"EBCDIC（Extended Binary Coded Decimal Interchange Code，扩展二进制编码的十进制交换码）：1964年，IBM 为大型机操作系统而开发设计的。英文字母的排列是不连续的，这带来了一些困扰和麻烦。\"]},\"53\":{\"h\":\"1.2 ASCII字符编码方案简介\",\"t\":[\"ASCII（American Standard Code for Information Interchange，美国信息交换标准码）：后来 IBM 的个人计算机和工作站操作系统采用了 ASCII 码，后来称为了英文字符编码工业标准。\",\"由美国国家标准学会ANSI（American National Standard Institute）于1968年正式制定\",\"1972 年被 ISO/IEC 采用，，制定为 ISO/IEC 646 标准\",\"7 位二进制表示一个字符，总共 128 （27）个字符。\",\"计算机普遍采用8位作为一个字节来进行存取与处理，因此剩下最高位的那1比特一般为0，但有时在一些通讯系统中也被用作奇偶校验位。\",\"4 类字符\",\"0~31：不可显示不可打印的控制字符或通讯专用字符。如 0x07（BEL响铃）会让计算机发出哔的一声、0x00（NUL空，注意不是空格）通常用于指示字符串的结束、0x0D（CR回车）和 0x0A（LF换行）用于指示打印机的打印针头退到行首（即回车）并移到下一行（即换行）等\",\"注：将这些用于控制或通讯的控制字符或通讯专用字符称之为“字符”，感觉上似乎有点怪，实际上这些所谓的“字符”表示的其实是一种动作或行为，因此才既不可显示也不可能打印。\",\"32：可显示但不可打印的空格字符\",\"33~126：可显示可打印字符，其中 48~57 为 0-9 的阿拉伯数字，65~90 为 26 个大写英文字母，97~122 为26个小写英文字母，其余的是一些标点符号、运算符号等\",\"127：不可显示不可打印的控制字符DEL\"]},\"54\":{\"h\":\"2 EASCII 及 ISO 8859 字符编码方案\",\"t\":[\"计算出现后，逐渐从美国发展到了欧洲。除了最基本的美国使用的那 128 个 ASCII 码之外，还有很多衍生的拉丁字母等字符。考虑到一个字节能够表示的编码实际上有 256（28）个，于是欧洲各国纷纷打起了后面 128 个编码的主意。\",\"各国对于 0x80 ~ 0xFF 的设计各自为政，形成了多个 ANSI 编码方案。为了统一这种混乱局面，又先后设计了两套统一的技能兼容 ASCII 码、又支持各国所使用的那些衍生字段的单字节编码方案：EASCII（Extended ASCII）和 ISO/IEC8859。\"]},\"55\":{\"h\":\"2.1 EASCII\",\"t\":[\"将 ASCII 中闲置的最高位利用起来。当第一个比特位为 0 时，仍然表示之前的 ASCII 字符；当第一个比特位为 1 时，表示补充扩展的其他衍生字符。\",\"现在 EASCII 码基本上被废弃了，它容纳的字符太少，国际化和标准化程度不够。目前已经被 ISO/IEC 8859 字符编码方案取代了。\"]},\"56\":{\"h\":\"2.2 ISO/IEC 8859\",\"t\":[\"和 EASCII 一样，ISO/IEC 8859 也是在 ASCII 码的基础上利用了最高位，即扩展剩余的128位。但实际上只有 0xA0~0xFF （十进制 160~255）这 96 个编码定义了字符。\",\"与 ASCII、EASCII 字符编码方案只包括单个独立的字符集不同，ISO/IEC 8859 字符编码方案包括了一组字符集，或者说 ISO/IEC 8859 相当于是一组字符集的总称，其内共包含了 15 个字符集，即 ISO/IEC 8859-n，n=1、2、3...15、16，其中 12 未定义，所以实际上共 15 个。这 15 个字符集大致上包括了欧洲各国所使用到的字符。\",\"目前使用最为普遍的是 ISO/IEC 8859-1 （也称 Latin-1）字符集，收录了西欧常用字符（包括德法两国的字母）。\"]},\"57\":{\"h\":\"3. 简体汉字编码方案（GBK2312、GBK 等）\"},\"58\":{\"h\":\"3.1 背景\",\"t\":[\"中文汉字多达10万+，而一个字节只能表示 256 个字符，所以只能使用多个字节来表示一个字符。\",\"在 GB（汉语“国标”首字母）系列编码方案中，如果一个字节是 0~127，那么这个字节的含义与 ASCII 码相同，否则，这个字节和下个字节共同组成汉字（或其他字符）。\",\"GB2312 是最早的 GB 编码方案，收录的汉字不足 1 万，基本满足日常需要，但不包括生僻字，于是后来又进行了扩展。\",\"GBK 是在 GB2312 上扩展后的字符集，K 指扩展。\",\"GB18030 是在 GBK 基础上进行进一步扩展得到的，加入了少数民族的文字，一些生僻字被编到了 4 字节。\",\"上述三个 GB 系列编码方案每次扩展都完全保留之前版本的编码，即每个新版本都向下兼容。\",\"多字节字符与 ASCII 码混用时，有 2 种处理方式：\",\"将 ASCII 重新编码为多字节，以便与其他多字节字符统一。如 UTF-16、UTF-32 等。\",\"保持 ASCII 字符为单字节编码，将其他多字节字符编码中的各个字节的最高位设为 1，以避免与 ASCII 码（首位为 0）冲突。如 GB、UTF-8。\",\"UTF-16、UTF-32 是多字节编码，采用的是多字节码元，UTF-8 虽然也是多字节编码，但采用的是单字节码元。GB 系列虽然除 ASCII 字符外的其余字符位多字节编码，但采用的是单字节码元，由于历史原因，又进一步引发了更为麻烦的字节序（Byte-Order）问题。\"]},\"59\":{\"h\":\"3.2 GB2312\",\"t\":[\"GB2312 是双字节编码，前一字节为高字节，后面的为低字节。一个汉字的编码（即汉字内码）的字节，其值必须大于 127（即最高位为 1），并且必须是 2 个大于 127 的字节连在一起共同表示一个汉字。\",\"GB2312 标准共收录 6763 个汉字，其中一级汉字 3755 个，二级汉字 3008个；同时，除了汉字，GB2312 还收录了包括拉丁字母、希腊字母、日文平假名及片假名字符、俄语西里尔字母在内的 682 个字符。\",\"可能是出于显示上视觉美观的考虑，这 682 个字符中还包括了 ASCII 里本来就有的数字、标点、字母等字符。即对 ASCII 码中原本就有的单字节编码的字符，又编入了 2 个字节长的 GB2312 编码版本。这些双字符编码字符就是全角字符，他们对应的单字节编码的 ASCII 字符就是半角字符。\"]},\"60\":{\"h\":\"3.3 GBK\",\"t\":[\"GBK 只要求高字节大于 127 就表示这是一个汉字的开始。向后完全兼容 GB1212，还支持 GB1212-1980 不支持的部分中文简体、中文繁体、日文。共收录汉字 21003 个、符号 883 个，并提供 1894个 造字码位，简、繁体字融于一体。\",\"微软的CP936通常被视为等同于GBK。但 GBK 定义的字符较 CP936 多出了 95 个（15个非汉字及80个汉字）。\"]},\"61\":{\"h\":\"3.4 GB18030\",\"t\":[\"中国国家质量技术监督局于 2000 年 3 月 17 日推出了 GB18030-2000 标准，以取代 GBK。GB18030-2000 除保留全部 GBK 编码汉字之外，在第二字节再度进行扩展，增加了大约一百个汉字及四位元组编码空间。\",\"2005 年，GB18030 编码方案在 GB18030-2000 的基础上又进行了扩充，于是又有了 GB18030-2005《信息技术中文编码字符集》。\",\"GB18030-2000 是 GBK 的升级版本，它的主要特点是在 GBK 基础上增加了 CJK 中日韩统一表意文字扩充 A 的汉字；而GB18030-2005 的主要特点是在 GB18030-2000 基础上又增加了 CJK 中日韩统一表意文字扩充 B 的汉字。\",\"微软也为GB18030定义了专门的代码页：CP54936，但是这个代码页实际上并没有真正使用。\"]},\"62\":{\"h\":\"3.5 小结\",\"t\":[\"GB 类字符集均属于双字节字符集 DBCS（Double Byte Character Set）。基于DBCS的编码方案里，最大的特点是两字节长的中文字符和一字节长的英文字符（ASCII字符）完全兼容，可以并存于同一个文件内。\",\"使用GB类编码方案时一般都要时刻记住：一个汉字由两个字节组成（即一个汉字占用的存储空间相当于两个英文字符所占用的存储空间）。\"]},\"63\":{\"h\":\"3. Unicode 编码方案\",\"t\":[\"本系列文章是对知乎专栏「刨根问底字符编码」 的学习记录。\"]},\"64\":{\"h\":\"1. 概述\",\"t\":[\"Unicode字符集的目标是涵盖目前人类使用的所有字符，并为每个字符分配一个唯一的字符编号（即码点编号、码点值），一一对应于编号空间（Code Space，即代码空间、码空间、码点空间）里的码点（Code Point，即代码点）。\",\"目前，Unicode字符集将所有字符按照使用上的频繁度，被划分为了17个平面（Plane），每个平面上的编号空间有 216=65536 个码点。将来根据需要，还可扩展为更多平面。\"]},\"65\":{\"h\":\"1.1 BMP、SP\",\"t\":[\"第 0 个平面称为基本多语言平面（BMP, Basic Multilingual Plane），简称为进本平面，平面 0，覆盖当今世界上正在使用中的常用字符。\",\"我们平常用到的大多数常见字符，一般都是位于 BMP 平面上的。\",\"BMP 以外的其他平面为增补平面（SP, Supplementary Plane），也称辅助平面，目前共 16 个增补平面 SP。\",\"增补平面要么用来表示一些非常特殊的字符（比如不常用的象形文字、远古时期的文字等），多半只有专家在历史和科学领域里才会用到它们；要么被留作扩展之用，尚未被分配字符，称之为保留区。目前Unicode字符集的17个平面中尚有大量的保留区编号空间未被使用。\",\"另外，BMP 平面中有一个私用区，也称为专用区（PUA：Private Use Area，或PUZ：Private Use Zone）：0xE000~0xF8FF（十进制 57344~63743），共6400个码点，被保留为私用，Unicode 官方未将之分配给任何 Unicode 字符，因而可根据需要由合作者之间私下协商将其分配给私有字符。\",\"注：Unicode 标准到目前为止实际上共定义了三个私用区：一个为如上所述的BMP中的 U+E000~U+F8FF，另外两个几乎包含了整个第 15 平面和第 16 平面，分别为 U+F0000~U+FFFFD 和 U+100000~U+10FFFD；私用区相当于是可以由 Unicode 官方之外的个人和机构自由定义字符的特殊区域，因此私用区中的同一个码点，可被分配给不同的字符，具体是哪个字符，取决于用户使用的字体文件，从而导致不同的用户由于安装了不同的字体文件，有可能所看到的私有字符也不同。\",\"BMP 中还有一个被称为代理区（Surrogate Zone）的特殊区域：0xD800-0xDFFF（十进制55296~57343），共 2048 个码点，这些码点被称之为代理码点，目的是用基本平面BMP中的两个码点“代理”表示 BMP 以外的其他增补平面 SP 中的字符。\"]},\"66\":{\"h\":\"1.2 UTF-16\",\"t\":[\"Unicode字符集的字符编码方式一开始规定，使用两个字节的码元（即16位码元）来统一表示所有的字符（即 UTF-16）。UTF-16 中将 ASCII 码的长度由 8 位扩展为 16 位（高 9 位永远是 0），其余的字符全部重新统一编码。\",\"无论是半角的英文字母还是全角的汉字，它们都表示“1个字符”，其编码也都是“2个字节”。\",\"Unicode 在制订 UTF-16 字符编码之处，没有考虑与任何一种现有的字符编码保持完全兼容。例如要将文本内容在 UTF-16 和 GBK 之间进行转换，只能通过查表这样低效率的办法。即便是 ASCII 字符，也属于是不完全的间接兼容或半兼容，因为 UTF-16 是两个字节表示的，不同于 ASCII 的单字节编码。于是后来又设计了 UTF-8 字符编码方式，从而实现了与 ASCII 编码的完全兼容。\"]},\"67\":{\"h\":\"1.3 码点名称\",\"t\":[\"Unicode 字符集为每个字符根据其所在的码点分配了唯一的码点值（即码点编号）。同时为每个码点赋予了一个正式的名称，用 U+ 后接十六进制数字表示，称为码点名称或字符名称。（U+0041 表示英文大写字母 A，可在这里查询\",\"Unicode字符集中的 U+0000~U+007F（即十进制的 0~127），跟ASCII字符集（即 ISO/IEC 646 标准）是一致的；U+0000~U+00FF（即十进制的 0~255），跟 ISO/IEC 8859-1 字符集（即Latin-1字符集）也是一致的。\"]},\"68\":{\"h\":\"通信协议综述\",\"t\":[\"专栏「趣谈网络协议」学习记录\"]},\"69\":{\"h\":\"1. 协议三要素：语法、语义、顺序\"},\"70\":{\"h\":\"2. IP 和 CIDR\",\"t\":[\"IP 分类\",\"Class\",\"前缀位\",\"网络地址位数\",\"剩余的位数\",\"网络数\",\"每个网络的主机数\",\"IP 地址范围\",\"私有 IP 地址范围\",\"A类地址\",\"0\",\"8\",\"24\",\"128\",\"16,777,214\",\"0.0.0.0~127.255.255.255\",\"10.0.0.0~10.255.255.255\",\"B类地址\",\"10\",\"16\",\"16\",\"16,384\",\"65,534\",\"128.0.0.0~191.255.255.255\",\"172.16.0.0~172.31.255.255\",\"C类地址\",\"110\",\"24\",\"8\",\"2,097,152\",\"254\",\"192.0.0.0~223.255.255.255\",\"192.168.0.0~192.168.255.255\",\"D类地址（群播）\",\"1110\",\"未定义\",\"未定义\",\"未定义\",\"未定义\",\"224.0.0.0~239.255.255.255\",\"E类地址（保留）\",\"1111\",\"未定义\",\"未定义\",\"未定义\",\"未定义\",\"240.0.0.0~255.255.255.255\",\"无类型域间选路（CIDR）\",\"打破原来设计的几类地址的做法，将 IP 地址分为两部分：网络号 + 主机号。如 IP 为 10.0.24.16/22，22 指的是前22位是网络号，后 10 位是主机号。\",\"广播地址：10.0.27.255。当发出一个目的地址为 10.0.27.255 的分组时，它将被分发给该网段上的所有计算机。\",\"子网掩码：255.255.252.0。\",\"子网掩码 & IP 地址 = 网路号\",\"公有 IP 地址、私有 IP 地址\",\"组播地址（之后 VXLAN 协议会涉及到）\"]},\"71\":{\"h\":\"3. ip addr / ifconfig\",\"t\":[\"查看 IP 地址：Windows -> ipconfig, Linux -> ifconfig 或者 ip addr\",\"如果在一个被剪裁的很小的 Linux 系统中没有 ifconfig 或者 ip addr，可以自行安装 net-tools 和 iproute2 这两个工具。\",\"net-tools 起源于 BSD，自 2001 年起，Linux 社区已经对其停止维护，而 iproute2 旨在取代 net-tools，并提供了一些新功能。一些 Linux 发行版已经停止支持 net-tools，只支持 iproute2。 net-tools 通过 procfs(/proc) 和 ioctl 系统调用去访问和改变内核网络配置，而 iproute2 则通过 netlink 套接字接口与内核通讯。 net-tools 中工具的名字比较杂乱，而 iproute2 则相对整齐和直观，基本是 ip 命令加后面的子命令。\",\"ip 后面的 scope global eth0 指的是 eth0 这张网卡是 global，是可以对外的，能够接收来自各个地方的包。而scope host lo 这张网卡仅仅可以供本机星湖通信。\",\"lo -> loopback(环回接口)，往往会被分配到 127.0.0.1 这个地址。这个地址用于本机通信，经过内核处理后直接返回，不会在任何网络中出现。\",\"在 IP 地址的上一行是 link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff，这个被称为 MAC 地址，是一个网卡的物理地址，用十六进制，6 个 byte 表示。\",\"MAC 地址全局全局唯一，为什么还要用 IP 呢？\",\"MAC 地址是唯一的标识，但是要将一个网络包从一个地方传到另一个地方，除了需要确定的地址，还需要定位功能，而 IP 地址次具有远程定位功能（类比身份证 & 地址）。 MAC 地址具有一定定位功能，但是通信范围比较小，局限在一个子网里。一旦跨网，MAC 地址就不行了。\",\"网络设备的状态标识（net_device flags）：<BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000\",\"UP: 网卡处于启动状态\",\"BROADCAST: 该网卡有广播地址，可以发送广播包\",\"MULTICAST: 网卡可以发送多播包\",\"LOWER_UP: 表示 L1 是启动的，即网线插着\",\"MTU500: 最大传输单元 MTU 为 1500，以太网的默认值 MTU 是 MAC 层的概念。以太网规定正文部分不允许超过 1500 字节。正文里有 IP 的头、TCP 的头、HTTP的头。如果放不下，就要分片传输。\",\"qdisc mq: qdisc(queueing discipline)，排队规则。如果需要通过某个网络接口发送数据包，它都需要按照为这个接口配置的 qdisc（排队规则）把数据包加入队列。 \",\"最简单的 qdisc 是 pfifo，不对进入的数据包做任何处理，数据包采用先进先出的方式通过队列\",\"pfifo_fast 稍微复杂一点，他的队列包括三个波段（band），在每个波段里使用先进先出。 \",\"band 0 的优先级最高。\",\"数据包按照服务类型（Type of Service, TOS）被分配到三个 band 里。TOS 是 IP 头中的一个字段，表示当前的包的优先级。\",\"mq 是多队列。\"]},\"72\":{\"h\":\"4. IP 地址配置\",\"t\":[\"当配置的地址不在同一个网段时，包就无法发送出去了。\",\"例如，周围的机器都是 192.168.1.x，但是配置的 IP 是 192.2.2.4。现在来 ping 192.168.1.6，在把包发出去之前要先把 MAC 层填好，源 MAC 直接填入，但是目的 MAC 需要费一番功夫。\",\"Linux 首先会判断，目的 IP 和源 IP 是否在同一网段，或者和我的一个网卡是否在同一个网段。只有是一个网段的，他才会发送 ARP 请求，获取 MAC 地址。\",\"如果不是一个网段的，那么它会企图把包发送到网关。\",\"如果你配置了网关，Linux 会获取网关的 MAC 地址，然后将包发出去。对于 192.168.1.6 来说，虽然路过它的这个包 IP 是它，但是 MAC 地址不是它的，所以它的网卡不会把包收进去。\",\"如果没配网关，那么包完全发不出去。\",\"如果直接将网关配置成 192.168.1.6 呢？完全不可能，Linux 不会允许配置成功。网关需要和当前的网络至少一个网卡是同一个网段的，192.2.2.4 的网关不可能是 192.168.1.6。\",\"实际分配的时候，一般都是网络管理员分配 IP 地址，且不会直接用命令，而是放在一个配置文件里面。不同系统的配置文件格式不同，但是无非就是 CIDR、子网掩码、广播地址和网关地址。\"]},\"73\":{\"h\":\"5. 动态主机配置协议（DHCP, Dynamic Host Configuration Protocol）\",\"t\":[\"我们需要自动配置的协议。使用 DHCP，网络管理员只需要配置一段共享的 IP 地址。每一台新接入的机器都通过 DHCP 协议，来这个 IP 地址里申请，然后自动配置好。等人走了或者用完了，还回去，这样其他的机器也能用。\",\"所以，如果是数据中心里面的服务器，IP 一旦配置好，基本不会变，这就相当于买房自己装修。\"]},\"74\":{\"h\":\"DHCP 的工作方式\",\"t\":[\"共 4 次广播，使用 UDP 协议。\"]},\"75\":{\"h\":\"Step 1: DHCP Discover\",\"t\":[\"当一台机器新加入一个网络时，只知道自己的 MAC 地址。这时的沟通基本靠“吼”，我来啦，有人吗？这一步称为 DHCP Discover。\",\"新来的机器使用 IP 地址 0.0.0.0 发送了一个广播包，目的 IP 是 255.255.255.255。广播包封装了 UDP，UDP 封装了 BOOTP。DHCP 是 BOOTP 的增强版，但是抓包后可能看到的名称还是 BOOTP 协议。\",\"广播包内容如下：我是新来的（boot request），我的 MAC 地址是这个，我没 IP，谁能租给我个 IP 地址！\"]},\"76\":{\"h\":\"Step 2: DHCP Offer\",\"t\":[\"如果一个网络管理员在网络里配置了 DHCP Server，它就相当于这些 IP 的管理员。由于 MAC 是唯一的，所以 DHCP Server 知道来了个“新人”，需要租给它一个 IP 地址。这个过程称为 DHCP Offer。DHCP Server 会为此客户保留为它提供的 IP 地址，不会为其他客户分配同一个 IP 地址。\",\"DHCP Offer 的格式如下，里面有给新人分配的地址：\",\"DHCP Server 仍然使用广播地址作为目的地址，因为此时请求分配 IP 的新人还没有自己的 IP。DHCP Server 为它分配了一个可以用的 IP，并发送了子网掩码、网关和 IP 地址租用期等信息。\"]},\"77\":{\"h\":\"Step 3: DHCP Request\",\"t\":[\"如果有多个 DHCP Server，这台机器会收到多个 IP 地址。他会选择其中一个 DHCP Offer，一般是最先到达的那个，并向网络发送一个 DHCP Request 广播数据包，包中包含客户端的 MAC 地址、接受的租约中的 IP 地址、提供此租约的 DHCP 服务器地址等，并且告诉所有的 DHCP Server 它将接受哪一台服务器提供的 IP 地址，告诉其他 DHCP 服务器，谢谢你们的接纳，并撤销他们提供的 IP 地址，以便提供给下一个 IP 租用请求者。\",\"此时，由于还没有得到 DHCP Server 的最后确认，客户端仍然使用 0.0.0.0 为源 IP 地址、255.255.255.255 为目标地址进行广播。在 BOOTP 里面，接受某个 DHCP Server 分配的 IP。\"]},\"78\":{\"h\":\"Step 4: DHCP ACK\",\"t\":[\"最终租约达成的时候，还是需要广播一下，让大家都知道。\",\"当 DHCP Server 收到客户机的 DHCP request 之后，会广播返回给客户机一个 DHCP ACK 消息包，表明已经接受客户机的选择，并将这一 IP 地址的合法租用信息和其他的配置信息都放入该广播包，发给客户机，欢迎它加入网络大家庭。\"]},\"79\":{\"h\":\"6. IP 地址回收和续租\",\"t\":[\"客户机在租期过去 50% 的时候，直接向为其提供 IP 的 DHCP Server 发送 DHCP request 消息包。客户机接收到该服务器回应的 DHCP ACK 消息包，会根据包中提供的新租期以及其他更新的 TCP/IP 参数，更新自己的配置。这样，IP 租用期更新就完成了。\"]},\"80\":{\"h\":\"7. 预启动执行环境（PXE, Pre-boot Execution Environment）\",\"t\":[\"DHCP 协议中还有个细节。网络管理员不仅能自动分配 IP 地址，还能帮你自动安装操作系统！\",\"数据中心的管理员肯呢个一下子拿到几百台控的机器，所以他希望的不仅仅是自动分配 IP 地址，还要自动安装系统。装好系统之后自动分配 IP 地址，直接启动就能用了。\",\"BIOS 启动之后才能安装操作系统，但是在没安装操作系统之前，是没有启动扇区的，所以这个过程叫预启动执行环境（PXE）。\",\"PXE 协议分为客户端和服务器端，由于没有操作系统，只能先把客户端放在 BIOS 里面。计算机启动是，BIOS 把 PXE 客户端调入内存里，就可以连接到服务器做一些操作了。\",\"PXE 客户端（通常也称为 PXE 固件）是网卡固件的一部分，被网卡厂商固化在了网卡的 ROM 中。\",\"PXE 客户端自己需要有 IP 地址。PEX 客户端启动的时候，啥都没有。但是可以发送 DHCP 请求，让 DHCP Server 给它分配一个地址。\",\"PXE 客户端有了自己的地址，那它怎么知道 PXE 服务器在哪呢？\",\"DHCP Server 除了分配 IP 地址以外，还可以做一些其他的事情。下面是一个 DHCP Server 的样例配置：\",\"ddns-update-style interim; ignore client-updates; allow booting; allow bootp; subnet 192.168.1.0 netmask 255.255.255.0 { option routers 192.168.1.1; option subnet-mask 255.255.255.0; option time-offset -18000; default-lease-time 21600; max-lease-time 43200; range dynamic-bootp 192.168.1.240 192.168.1.250; filename \\\"pxelinux.0\\\"; next-server 192.168.1.180; } \",\"如果想使用 PXE，需要配置 next-server，指向 PXE 服务器的地址，还要配置初始启动文件 filename。\",\"这样 PXE 客户端启动后，发送 DHCP，除了能得到 IP 地址，还能知道 PXE 服务器在哪。也可以知道如何从 PXE 服务器上下载某个文件，去初始化操作系统。\"]},\"81\":{\"h\":\"PXE 的工作过程\",\"t\":[\"PXE 客户端启动。通过 DHCP 协议告诉 DHCP Server 我是“新人”，我来了。DHCP Server 租给他一个 IP 地址，同时也给它 PXE 服务器的地址、启动文件 pxelinux.0。\",\"PXE 客户端去 PXE 服务器下载启动文件。系在启动文件使用的是 TFTP 协议，所以 PXE 服务器上，还需要有一个 TFTP 服务器。PXE 客户端向 TFTP 服务器请求下载这个文件，TFTP 服务器将文件传给它。\",\"PXE 收到了这个文件，开始执行该文件。这个文件会指示 PXE 客户端，向 TFTP 服务器请求计算机的配置信息 pxelinux.cfg。TFTP 服务器会给 PXE 客户端一个配置文件，里面会指明内核在哪里、initramfs 在哪里。PXE 客户端会请求这些文件。\",\"启动 Linux 内核。\"]},\"82\":{\"h\":\"数组\",\"t\":[\"一块连续的内存空间，支持随机访问\",\"插入和删除比较低效（平均情况时间复杂度为 O(n)），因为可能要大量移动数据。\",\"插入：如果对数组内元素的顺序没有要求，那么可以将要插入位置的元素插入到最后，而将待插入的元素直接插入对应位置，则时间复杂度就会降到 O(1)。\",\"删除：可以先记录下已经删除的数据。每次删除并不进行数据的移动，只记录数据已经被删除，当数组没有更多空间存储数据时，我们再出发执行一次真正的删除操作。\",\"点此查看 JavaScript 中的数组提供的功能。\"]},\"83\":{\"h\":\"introduction\"},\"84\":{\"h\":\"复杂度分析\"},\"85\":{\"h\":\"时间复杂度 & 空间复杂度\",\"t\":[\"（渐进）时间复杂度量级： T(n)=O(f(n))，O 表示执行时间 T(n) 与 f(n) 成正比\",\"多项式量级 \",\"常量阶 O(1)\",\"对数阶 O(logn)\",\"i = 1; while (i < n) { i = i * 2; } \",\"线性阶 O(n)\",\"线性对数阶 O(nlogn) 如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。如归并排序、快速排序。\",\"平方阶 O(n2)、立方阶 O(n3)、...、 k 次方阶 O(nk)\",\"非多项式量级 \",\"指数阶 O(2n)\",\"阶乘阶 O(n!)\",\"（渐进）空间复杂度：常见 O(1)、O(n)、O(n2)\"]},\"86\":{\"h\":\"最好、最坏、平均、均摊时间复杂度\"},\"87\":{\"h\":\"1. 最好情况时间复杂度（best case time complexity）、最坏情况时间复杂度（worst case time complexity）\",\"t\":[\"// 在给定数组 array 中找指定元素 x int find(int[] array, int n, int x) { int i = 0; int pos = -1; for (; i < n; ++i) { if (array[i] == x) { pos = i; break; } } return pos; } \",\"如果我们要找的元素刚好是数组的第一个元素，那么循环只执行 1 步，时间复杂度就是 O(1)；如果数组中没有该元素，那么需要将整个数组遍历一遍，时间复杂度就是 O(n)。\",\"上面对应的就是最好情况时间复杂度和最坏情况时间复杂度。\"]},\"88\":{\"h\":\"2. 平均情况时间复杂度（average case time complexity）\",\"t\":[\"最好情况和最坏情况都是极端情况下的代码复杂度，于是又引入了平均情况时间复杂度，简称平均时间复杂度。\",\"还是上面查找元素在数组中的位置，有 n+1 种情况：在数组中（n 种）以及不在数组中。把每种情况下要遍历的元素的个数累加起来再除以 n+1，就可以得到需要遍历元素个数的平均值：\",\"n+11+2+3+...+n+n​=2(n+1)n(n+3)​O(n)\",\"如果我们从概率的角度分析，假设在数组中的概率和不在数组中的概率都是 21​，那么出现在每个位置的概率为 2n1​，计算加权平均（期望）。于是平均时间复杂度的全称是加权平均时间复杂度或期望时间复杂度。\",\"1×2n1​+2×2n1​+3×2n1​+...+n×2n1​+n×21​=43n+1​\",\"只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。\"]},\"89\":{\"h\":\"3. 均摊时间复杂度（amortized time complexity）\",\"t\":[\"摊还分析：对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。\"]},\"90\":{\"h\":\"链表\"},\"91\":{\"h\":\"1. 几种常见的链表结构\",\"t\":[\"链表的结构五花八门，下面介绍三种最常见的列表结构：单链表、双向链表、循环链表。\"]},\"92\":{\"h\":\"1.1 单链表\",\"t\":[\"一些概念：\",\"结点： \",\"头结点：记录链表的基地址\",\"尾结点：指针指向空地址 NULL\",\"后继指针\",\"插入、删除的时间复杂度都是 O(1)，随机访问的性能不如数组，要 O(n) 的时间复杂度。\"]},\"93\":{\"h\":\"1.2 循环链表\",\"t\":[\"循环链表是一种特殊的单链表。循环链表的尾结点指向链表的头结点。\",\"优点：从链尾到链头比较方便。在单链表中，从已知一结点出发，只能访问到该结点以及它之后的结点；而使用循环链表时，从任意结点出发都可以访问到表中的所有节点。当要处理的数据具有环型结构的特点时，很适合采用循环链表，如著名的约瑟夫问题。\"]},\"94\":{\"h\":\"1.3 双向链表\",\"t\":[\"除了有后继指针 next，还有前驱指针 prev。\",\"需要更多的空间来存储前驱指针，但是能够支持双向遍历。\",\"双向链表可以支持 O(1) 时间复杂度来找到前驱节点，于是双向链表在某些情况下的插入、删除等操作比单链表简单高效（单链表需要从头结点开始找）。\",\"对于一个有序链表，双向链表的按值查询的效率要比单链表高一些。我们可以记录上次查找的位置 p，每次查询是，根据要找的值与 p 的大小关系，决定往前找还是往后找，所以平均值需要查找一半的数据。\"]},\"95\":{\"h\":\"1.4 双向循环链表\"},\"96\":{\"h\":\"2. 数组 v.s. 链表\",\"t\":[\"数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。\",\"数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容。\",\"如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。\"]},\"97\":{\"h\":\"3. 用链表的应用\"},\"98\":{\"h\":\"3.1 实现 LRU\",\"t\":[\"链表的典型应用场景：LRU(Least Recently Used, 最近最少使用) 缓存淘汰算法\",\"我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。\",\"当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。\",\"如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。\",\"如果此数据没有在缓存链表中，又可以分为两种情况： \",\"如果此时缓存未满，则将此结点直接插入到链表的头部；\",\"如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。\"]},\"99\":{\"h\":\"3.2 快慢指针\",\"t\":[\"判断是否有环 \",\"判断环的起点\",\"找中点（中点、上中点、下中点）\"]},\"100\":{\"h\":\"4. 正确写出链表代码\"},\"101\":{\"h\":\"4.1 理解指针或引用的含义 —— 地址\"},\"102\":{\"h\":\"4.2 警惕指针丢失和内存泄漏\",\"t\":[\"先后接，再前接\",\"删除链表结点时，记得手动释放内存空间。\"]},\"103\":{\"h\":\"4.3 利用哨兵简化实现难度\",\"t\":[\"对头结点和尾结点的特殊处理\",\"// 插入 new_node -> next = p -> next; p -> next = new_node; // 插入第一个节点 if (head == null) { head = new_node; } \",\"// 删除 p -> next = p -> next -> next; // 删除最后一个结点 if (head -> next == null) { head = null } \",\"引入哨兵结点，在任何时候，不管链表是否为空，head 指针都会指向这个哨兵结点。这种链表叫带头链表。不带哨兵结点的链表叫做不带头链表。\",\"使用带头链表之后，插入第一个结点、删除最后一个结点就可以统一为相同的代码实现逻辑。\",\"利用哨兵简化变成难度\",\"任务：给定数组 a，查找 key，返回 key 的索引（其中 n 表示数组 a 的长度）\",\"int find(char* a, int n, char key) { if (a == null || n <= 0) { return -1; } int i = 0; while (i < n ) { if (a[i] == key) { return i } ++i; } return -1; } \",\"int find(char* a, int n, char key) { if (a == null || n < 0) { return -1; } // 用 a[n-1] 做哨兵，这里做特殊处理 if (a[n - 1] == key) { return n-1; } char tmp = a[n - 1]; a[n - 1] = key; int i = 0; // 相比于上面的代码，少了 i < n 这个比较操作 while (a[i] != key) { ++i; } // 恢复 a[n - 1] a[n - 1] = tmp; if (i == n - 1) { return -1; } else { return i; } } \",\"当代码执行万次、几十万次时，省掉的一个比较语句积累的时间会比较明显。\",\"上面只是举例说明哨兵的作用，写代码时不必写成第二段那样（可读性太差）。\"]},\"104\":{\"h\":\"4.4 重点留意边界条件处理\",\"t\":[\"链表为空时\",\"链表只包含一个结点时\",\"链表只包含两个结点时\",\"处理头结点 & 尾结点时\"]},\"105\":{\"h\":\"4.5 举例画图，辅助思考\"},\"106\":{\"h\":\"4.6 多写多练\",\"t\":[\"单链表反转 206\",\"链表中环的检测 141 快慢指针\",\"两个有序链表的合并 21\",\"删除链表倒数第 n 个结点 19 双指针（固定步数差值）\",\"求链表的中间结点  876  快慢指针\"]},\"107\":{\"h\":\"队列\"},\"108\":{\"h\":\"Introduction\",\"t\":[\"栈：入栈（push）、出栈（pop）\",\"队列：入队（enqueue）、出队（dequeue）\",\"队尾入队，队首出队\",\"循环队列、阻塞队列、并发队列。比如高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列；Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁。\",\"循环队列：\",\"队空：head == tail\",\"队满：(tail + 1)%n == head\"]},\"109\":{\"h\":\"1. 阻塞队列\",\"t\":[\"阻塞队列是在队列的基础上增加了阻塞操作。在队列为空的时候，从队头取数据会被阻塞，知道队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作会被阻塞，知道队列中有空闲位置后再插入数据，然后再返回。\",\"这种基于阻塞队列实现的“生产者-消费者”模型，可以有效地协调生产和消费的速度。我们还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。\"]},\"110\":{\"h\":\"2. 并发队列\",\"t\":[\"在多线程的情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题。如何实现一个线程安全的队列呢？\",\"线程安全的队列叫并发队列。最简单的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或取操作。实际上，基于数组的循环队列（避免数据搬移），利用 CAS（Compare And Swap）原子操作（避免真正去 OS 底层申请锁资源），可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。\"]},\"111\":{\"h\":\"Q: 线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理\",\"t\":[\"一般有两种策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。\",\"我们希望公平地处理每个排队的需求，先进者先服务，所以队列这种数据结构很适合来存储排队请求。\",\"利用链表实现的队列，我们可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的时间过长。针对响应时间比较敏感的系统，基于链表实现的无线排队的线程池是不合适的。\",\"利用数组实现的有界队列（bounded queue），队列大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。\",\"队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。\"]},\"112\":{\"h\":\"递归\"},\"113\":{\"h\":\"递归需要满足的 3 个条件\",\"t\":[\"一个问题的解可以分解为几个子问题的解\",\"这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样\",\"存在递归终止条件\"]},\"114\":{\"h\":\"如何编写递归代码\",\"t\":[\"关键在于写出递推公式，找到终止条件。\",\"例题：有 n 个台阶，每次可以跨 1 个或 2 个台阶，请问走 n 个台阶有多少种走法？\",\"分析：可以把第一个的走法分为两类，第一类是第一步走了 1 个台阶，另一类是第一步走了 2 个台阶。所以 n 个台阶的走法就等于先走 1 阶后，n - 1 个台阶的走法，加上先走 2 阶后，n - 2 个台阶的走法：f(n)=f(n−1)+f(n−2)。\",\"终止条件：f(1)=1,f(2)=2\",\"最终代码：\",\"int f(int n) { if (n == 1) return 1; if (n == 2) return 2; return f(n-1) + f(n-2); } \"]},\"115\":{\"h\":\"递归代码要警惕堆栈溢出\",\"t\":[\"函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。\",\"我们可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。当递归调用超过一定深度之后，就不再向下递归了，直接返回报错。\",\"// 全局变量，表示递归的深度。 int depth = 0; int f(int n) { ++depth； if (depth > 1000) throw exception; if (n == 1) return 1; return f(n-1) + 1; } \",\"但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如 10、50，就可以用这种方法，否则这种方法并不是很实用。\"]},\"116\":{\"h\":\"警惕重复计算\",\"t\":[\"上面爬台阶的例子中，计算 f(5) = f(4) + f(3)，但是在计算 f(4) = f(3) + f(2) 时，也计算了 f(3)。这就是重复计算问题。\",\"为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先去散列表中取，没有对应的值再进行计算。这样就可以避免重复计算的问题了。\",\"public int f(int n) { if (n == 1) return 1; if (n == 2) return 2; if (hasSolvedList.containsKey(n)) { return hasSolvedList.get(n) } int ret = f(n-1) + f(n-2); hasSolvedList.put(n, ret); return ret; } \",\"注意\",\"由于递归需要在内存栈中进行压栈出栈操作，当调用栈比较深时，需要考虑这部分的时间开销。另外，空间上也要考虑压栈出栈的开销。\"]},\"117\":{\"h\":\"将递归代码改为非递归代码\",\"t\":[\"递归：\",\"优点：代码易理解，写起来很简洁。\",\"缺点：空间复杂度高，有堆栈溢出的风险，存在重复计算、过多的函数调用会耗时等问题。\",\"所有的递归代码都可以改为迭代循环的非递归写法。实际上是将递归改为了“手动”递归，本质并没有改变。\",\"int f (int n) { if (n == 1) return 1; if (n == 2) return 2; int ret = 0; int pre = 2; int prepre = 1; for (int i = 3; i <= n; ++1) { ret = pre + prepre; prepre = pre; pre = ret; } return ret; } \"]},\"118\":{\"h\":\"排序\",\"t\":[\"排序算法\",\"时间复杂度\",\"是否基于比较\",\"冒泡、插入、选择\",\"O(n2)\",\"✓\",\"快排\",\"O(nlogn)\",\"✓\",\"桶、计数、基数\",\"O(n)\",\"✗\",\"要考虑的指标：\",\"时间复杂度：最好、最坏、平均；时间复杂度的系数、常数、低阶；比较次数和交换（或移动）次数\",\"空间复杂度：原地排序（Sorted in place）-> O(1)\",\"稳定性\"]},\"119\":{\"h\":\"1. 冒泡、插入、选择\",\"t\":[\"这三种排序算法都是原地排序。\"]},\"120\":{\"h\":\"1.1 Bubble Sort\",\"t\":[\"对相邻数据做操作，比较 + 交换。\",\"代码\",\"public void bubbleSort(int[] a, int n) { if ( n <= 1) return; for (int i = 0; i < n; ++i) { // 是否有数据交换 boolean flag = false; for (int j = 0; j < n - i - j; ++j) { if (a[j] > a[j+1]) { int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; flag = true; // 有数据交换 } } if(!flag) break; } } \",\"稳定：当相邻元素大小相等时，不做交换。\",\"时间复杂度： \",\"最好：已经有序，一次冒泡，O(n)\",\"最坏：倒序，n次冒泡，O(n2)\",\"平均：O(n2)\",\"有序度 & 逆序度、满序度\",\"分析：冒泡排序有两个原子操作（比较和交换）。每交换一次，有序度加 1。交换次数=逆序度=2n(n−1)​−初始有序度。最坏情况下，初始有序度是 0，需要进行 2n(n−1)​ 次交换。最好情况下初始有序度是 2n(n−1)​，不需要进行交换。平均情况下，取中间值 4n(n−1)​。比较操作肯定比交换操作多，复杂度的上限是 O(n2)，所以平均情况下的时间复杂度是 O(n2)\"]},\"121\":{\"h\":\"1.2 Insertion Sort\",\"t\":[\"将数组中的元素分为两个区间：已排序区间和未排序区间。取未排序区间中的元素，在已排序区间中找到合适的位置将其插入，直到未排序区间为空。其中，初始已排序区间是数组的第一个元素。\",\"比较 + 移动。将未排序区间的一个元素插入已排序空间时，需要与已排序空间的元素依次比较大小，找到合适的位置插入，插入点之后的元素都需要往后移动腾出位置。\",\"移动的次数是固定的，等于逆序度。\",\"代码\",\"public void insertionSort(int[] a, int n) { if (n <= 1) return; for (int i = 1; i < n; ++i) { int value = a[i]; int j = i - 1; // 查找插入位置 for (; j >= 0; --j) { if (a[j] > value) { a[j+1] = a[j]; // 移动数据 } else { break; } } a[j+1] = value; // 插入数据 } } \",\"稳定：注意将元素插到相同元素的后面。\",\"时间复杂度： \",\"最好：有序，每次进行一次比较就可以确定插入位置，没有移动。O(n)\",\"最坏：倒序。O(n2)\",\"平均：O(n2)\",\"分析：在数组中插入一个元素的时间复杂度是 O(n)，循环执行 n 次插入操作，平均时间复杂度是 O(n2)\"]},\"122\":{\"h\":\"1.3 Selection Sort\",\"t\":[\"分排序空间和未排序空间。每次从未排序区间中找到最小的元素，将其放到已排序区间的末尾（与插入点位置的元素交换）。\",\"代码\",\"public void selectionSort(int[] a, int n) { if (n <= 1) return; for (int i = 0; i < n - 1; ++i) { int min = i; for (int j = i + 1; j < n; ++j) { if (a[j] < a[min]) { min = j; } } // 交换 if (min != i) { int tmp = a[min]; a[min] = a[i]; a[i] = tmp; } } } \",\"不稳定：找到最小值和目标位置做交换，这个交换的操作决定了它是不稳定的。\",\"时间复杂度：最好、最坏、平均都是 O(n2)。因为需要遍历找到最小元素，找到最小元素的时间复杂度是 O(n2)。\"]},\"123\":{\"h\":\"1.4 小结\",\"t\":[\"冒泡和插入排序都是稳定的，选择排序不稳定。\",\"对于冒泡和插入，它们的时间复杂度都是 O(n2)，都是原地排序，且都可以稳定。但是插入排序更受欢迎。\",\"无论怎么优化，冒泡排序的元素交换次数是固定值，插入排序的元素移动次数也是固定值，数值上等于数组初始状态的逆序度。但是从代码上看，冒泡排序要进行 3 个赋值操作，而插入排序只需要一个。\",\"// 冒泡中元素交换 if (a[j] > a[j+1]) { int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; flag = true; } // 插入排序中的元素移动 if (a[j] > value) { a[j+1] = a[j]; } else { break; } \",\"原地\",\"稳定\",\"最好\",\"最坏\",\"平均\",\"冒泡排序\",\"✓\",\"✓\",\"O(n)\",\"O(n2)\",\"O(n2)\",\"插入排序\",\"✓\",\"✓\",\"O(n)\",\"O(n2)\",\"O(n2)\",\"选择排序\",\"✓\",\"✗\",\"O(n2)\",\"O(n2)\",\"O(n2)\"]},\"124\":{\"h\":\"2. 归并排序 & 快速排序\",\"t\":[\"归并排序和快速排序都用到了分治思想。\"]},\"125\":{\"h\":\"2.1 Merge Sort\",\"t\":[\"将数组分成前后两部分，对两部分分别排序，再将排好序的两部分合并在一起，整个数组就有序了。\",\"归并排序使用的是分治思想，将大问题分解成小的子问题，子问题解决了，大问题也就解决了。分治算法一般都用递归来实现。分治是一种处理思想，而递归是一种编程技巧。\",\"先写递推公式：\",\"merge_sort(p, r) = merge(merge_sort(p, q), merge_sort(q+1, r)) 终止条件：p >= r \",\"代码\",\"void merge_sort(int[] arr, int n) { merge_sort_process(arr, 0, n-1) } void merge_sort_process(int[] arr, int l, int r) { if ( l >= r) return; mid = (l + r)/2; merge_sort_process(arr, p, mid); merge_sort_process(arr, mid+1, r); // 将 arr[l..mid] 和 arr[mid+1...r] 合并 merge(arr, l, mid, r) } void merge(int[] arr, l, mid, r) { int[] tmp = new int[r-l+1]; int i = 0; int p = l; int q = m+1; while(p <= mid && q < r) { tmp[i++] = arr[p] <= arr[q] ? arr[p++] : arr[q++]; } while(p <= mid) { tmp[i++] = arr[p++]; } while(q < r) { tmp[i++] = arr[q++]; } for(i = 0; i < r-l+1; ++i) { arr[l+i] = tmp[i]; } } \",\"稳定：取决于 merge 函数\",\"空间复杂度：O(n)\",\"时间复杂度：任何情况下都是 O(nlogn)\",\"快速排序最差情况下的时间复杂度是 O(n2)，但是归并排序并没有快排那样应用广泛。主要原因是，归并排序不是原地排序算法。\",\"递归代码的时间复杂度分析\",\"将问题 a 分解成子问题 b 和 c。问题 b 和 c 解决了在把二者的结果合并成 a 的结果。\",\"T(a)=T(b)+T(c)+K\",\"其中 K 是将子问题的结果合并成问题 a 的结果所消耗的时间。\",\"对于归并排序，n 个元素所需要的时间是 T(n)，分解成两个子数组排序的时间都是 T(2n​)。merge() 合并两个有序子数组的时间复杂度已知是 O(n)。\",\"n=1时，T(1)n>1时，T(n)​=C;=2×T(2n​)+n;=2×(2×T(4n​)+n/2)+n=4×T(4n​)+2×n=4×(2×T(8n​)+n/4)+2×n=8×T(8n​)+3×n...=2k×T(2kn​)+k×n​\",\"当 k=log2​n 时，T(2kn​)=T(1)，带入上式得，T(n)=Cn+nlog2​n。用大 O 标记法表示为 O(nlogn)。\"]},\"126\":{\"h\":\"2.2 Quick Sort\",\"t\":[\"也是分治。选取要排序数组中的任意一个元素最为 pivot（分区点），遍历数组，将小于 pivot 的放在左边，将大于 pivot 的放在右边。然后，我们分别排序 pivot 左边的数据和 pivot 右边的数据，直到区间缩小为 1。\",\"递推公式：\",\"quick_sort(l, r) = quick_sort(l, p-1) + quick_sort(p+1, r) 终止条件：l >= r \",\"代码\",\"void quick_sort(int[] arr, n) { quick_sort_process(arr, 0, n-1); } void quick_sort_process(int[] arr, l, r) { if (l >= r) return; // 分区，并返回分区点 int p = partition(arr, l, r); quick_sort_process(arr, l, p-1); quick_sort_process(arr, p+1, r); } void partition(int[] arr, int l, int r) { // 以最后一个元素作为分区的界限 int pivot = arr[r]; int i = l; for (int j = l; j < r; ++j) { if (arr[j] < pivot) { swap(arr[i], arr[j]); i++; } } swap(arr[i], arr[r]); return i; } \",\"对于 partition() 函数，i 就是在遍历数组，它表示的是小于 pivot 的下标。每次遇到下雨 pivot 的元素，都会跟 a[i] 交换，即 a[i] 存放小于 pivot 的数据。\",\"不稳定\",\"空间复杂度：原地，O(n)\",\"时间复杂度：O(nlogn)\",\"最好：O(nlogn)。分区平衡，大概满足 T(n)=2×T(2n​)+n\",\"最差：O(n2)。原数组有序，每次选择最后一个元素作为 pivot，需要进行大概 n 次分区，每次分区平均要扫描约 2n​ 个元素。这时快排的时间复杂度就从 O(nlogn) 退化到了 O(n2)。\",\"T(n) 在大部分情况下都可以做到 O(nlogn)，只有在极端情况下，才会退化到 O(n2)。\"]},\"127\":{\"h\":\"2.3 比较\",\"t\":[\"归并排序和快速排序用的都是分治思想。它们的区别在于：归并排序的处理过程是由下到上的，先处理子问题，然后再合并；而快排是由上到下的，先分区，然后再处理子问题。\",\"Q：利用分治思想解决非排序问题。如何在 O(n) 时间复杂度内查找一个无序数组中的第 K 大元素。\",\"A：选取最后一个元素做 pivot，进行原地分区，数组被分为三部分，arr[0...p], arr[p], arr[p+1...n-1]。如果 p+1 == k，那么 arr[p] 就是第 K 大的元素。如果 p+1 < K，那么到 arr[p+1...n-1] 中继续递归查找；如果 p+1 > K，那么到 arr[0...p] 中递归查找。\",\"时间复杂度分析：第一次需要遍历 n 个元素进行分区操作。下一次分区时，只需要对 n/2 个元素进行遍历。以此类推，直到区间缩小为 1。n+2n​+4n​+8n​+...+1=2n−1。即时间复杂度是 O(n)。\"]},\"128\":{\"h\":\"3. 线性排序：桶排序、计数排序、基数排序\"},\"129\":{\"h\":\"3.1 Bucket sort\",\"t\":[\"时间复杂度：n 个数据，m 个桶，平均每个桶 k = n/m 个数据。在每个桶中使用快排，在每个桶中的复杂度为 O(klogk)。则所有数据的时间复杂度就是 O(m×klogk)=nlogmn​。当桶的个数 m 接近数据个数 n 时，log(mn​) 就是一个非常小的常量，这时桶排序的时间复杂度接近于 O(n)。\",\"使用条件很苛刻：\",\"要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。\",\"数据在各个桶之间的分布是比较均匀的。极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。\",\"桶排序比较适合用在外部排序中。即数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。\"]},\"130\":{\"h\":\"3.2 Counting sort\",\"t\":[\"计数排序算是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。\",\"代码\",\"// 数组 a 中都是非负数 public void countingSort(int[] a, int n) { if (n <= 1) return; // 确定数据范围 int max = a[0]; for (int i = 1; i < n; ++i) { if (max < a[i]) { max = a[i]; } } // 申请数组，赋初值 0 int[] c = new int[max + 1]; for (int i = 0; i <= max; ++i) { c[i] = 0; } // 遍历数组 a，用 c 记录每个元素的个数 for (int i = 0; i < n; ++i) { c[a[i]]++; } // 对 c 累加 for (int i = 1; i <= max; ++i) { c[i] = c[i] + c[i - 1]; } // 对 a 数组排序之后的数组 int[] tmp = new int[n]; // 从后向前遍历，以保证计数是稳定的 for (int i = n - 1; i >= 0; --i) { int index = c[a[i]] - 1; tmp[index] = a[i]; c[a[i]] --; } // 将结果拷贝到 a for (int i = 0; i < n; ++i) { a[i] = tmp[i]; } } \",\"计数排序只能用在数据范围不大的场景中，如果数据范围 k 要比排序的数据 n 大很多，就不适合用计数排序了。\",\"而且，计数排序只能对非负数进行排序。对于其他类型，要将其转化为非负整数。\"]},\"131\":{\"h\":\"3.3 Radix sort\",\"t\":[\"根据每一位来排序，可以用桶排序或计数排序，时间复杂度可以做到 O(n)。如果要排序的数据有 k 位，那么就需要 k 次桶排序或者计数排序，总的时间复杂度是 O(kn)，k 不大时，基数排序的复杂度就近似于 O(n)。\"]},\"132\":{\"h\":\"4. 实现通用、高性能的排序函数\",\"t\":[\"时间复杂度\",\"稳定\",\"原地\",\"冒泡排序\",\"O(n2)\",\"✓\",\"✓\",\"插入排序\",\"O(n2)\",\"✓\",\"✓\",\"选择排序\",\"O(n2)\",\"✗\",\"✓\",\"归并排序\",\"O(nlogn)\",\"✓\",\"✗\",\"快速排序\",\"O(nlogn)\",\"✗\",\"✓\",\"桶排序\",\"O(n)\",\"✓\",\"✗\",\"计数排序\",\"O(n+k) k 是数据范围\",\"✓\",\"✗\",\"基数排序\",\"O(dn) d 是维度\",\"✓\",\"✗\",\"线性排序的使用场景特殊。小规模数据的排序可以用时间复杂度为 O(n2) 的算法。为了兼顾任意规模数据排序，一般都会选择时间复杂度是 O(nlogn) 的排序算法。比如 Java 中采用堆排序来实现排序函数，C 语言使用快速排序来实现排序函数。\"]},\"133\":{\"h\":\"优化排序\",\"t\":[\"快速排序在最坏情况下的时间复杂度是 O(n2)，我们要尽量避免。最坏情况出现的主要原因是分区点选得不够合理。最理想的分区点应该使得两个分区中的数据数量差不多多。\",\"下面是 2 个常用的比较简单的分区算法：\",\"三数取中法\",\"从区间的首、尾、中分别取出一个数，选择这三个数的中间值作为分区点。这样肯定比只取某一个数据好。如果排序的数组比较大，可能要“五数取中”、“十数取中”。\",\"随机法\",\"每次从要排序的区间中随机选择一个元素作为分区点。虽然不能保证每次分区点都选得很好，但是也不大可能出现每次分区点都选得很差的情况。\"]},\"134\":{\"h\":\"栈\"},\"135\":{\"h\":\"栈的应用\"},\"136\":{\"h\":\"函数调用栈\",\"t\":[\"操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个对应的栈帧出栈。\"]},\"137\":{\"h\":\"表达式求值\",\"t\":[\"编译器可以通过两个栈来实现四则运算。一个栈用来保存操作数，一个栈用来保存运算符。\",\"从左向右遍历表达式，遇到数字时，直接入栈。遇到运算符时，与栈顶的运算符进行比较。如果比栈顶元素的优先级高，就入栈；否则，从运算符栈中取出运算符，从操作数栈栈顶取出 2 个操作数，进行运算后，将结果压入操作数栈。继续比较当前运算符和新的栈顶运算符。\"]},\"138\":{\"h\":\"括号匹配\",\"t\":[\"用栈保存未被匹配的左括号，从左到右扫描字符串，当扫描到左括号时，将其压入栈中，当扫描到右括号时，取出栈顶的左括号，判断能否匹配，如果能则继续（否则，判定括号不匹配）。匹配完之后，栈为空，否则判定括号不匹配。\"]},\"139\":{\"h\":\"浏览器回退、前进\",\"t\":[\"使用两个栈来实现。当按顺序访问页面 a、b、c 后，按照其顺序，将 a、b、c 压入栈 1。当点击回退时，将栈 1 的栈顶取出压入栈 2 中。当前进时，将栈 2 的栈顶取出压入栈 1。栈 1 没有数据了的话，说明不能再回退了；栈 2 没有数据了的话，说明不能再前进了。\"]},\"140\":{\"h\":\"1. Transformer Models\"},\"141\":{\"h\":\"1. NLP 介绍\",\"t\":[\"NLP 的任务不仅仅是理解单个字词的含义，而是要理解上下文的含义。\",\"NLP 任务有很多，比如：\",\"对整个句子进行分类：获取评论的情绪，检测电子邮件是否为垃圾邮件，确定句子在语法上是否正确或两个句子在逻辑上是否相关\",\"对句子中的每个词语进行分类：识别句子的语法成分（名词、动词、形容词）或命名实体（人、地点、组织）\",\"生成上下文：用自动生成的文本完成提示，用屏蔽词填充文本中的空白\",\"从文本中提取答案：给定问题和上下文，根据上下文中提供的信息提取问题的答案\",\"根据输入文本生成新的句子：将文本翻译成另一种语言，总结文本\"]},\"142\":{\"h\":\"1.1 术语：Architectures vs. checkpoints\",\"t\":[\"在接下来的学习中，你将会看到 architectures、checkpoints，还有 models 这些术语。\",\"Architecture: 模型框架。每一层的定义、模型中发生的每个操作的定义。\",\"Checkpoints: 对于一个给定 architecture 的权重。\",\"Model: 范语，可能是指 architecture，也可能是指 checkpoints。\",\"如：BERT 是一个 architecture。bert-base-cased 是由 Google 团队为 BERT 训练的初始权重，它是 checkpoints。我们可以说 BERT model，也可以说 bert-base-cased model.\"]},\"143\":{\"h\":\"2. Transformers 能做什么\",\"t\":[\"你可以使用🤗 Transformers 库来创建并使用公开的模型。你可以在模型中心中查找预训练模型。你也可以在 Hub 中上传你自己的模型。\"]},\"144\":{\"h\":\"2.1 快速体验 🤗 Transformers 库\",\"t\":[\"🤗 Transformers 库提供了 pipeline() 函数，它聚合了预训练模型和对应的文本预处理。使用该函数可以直接根据输入返回目标输出。\",\"from transformers import pipeline # 选择任务 sentiment-analysis，创建分类器对象 # 没有指定 model，则会使用默认 model classifier = pipeline(\\\"sentiment-analysis\\\") # 1 传入一个句子 classifier(\\\"I've been waiting for a HuggingFace course my whole life.\\\") # 结果：[{'label': 'POSITIVE', 'score': 0.9598048329353333}] # 2 传入多个句子 classifier( [\\\"I've been waiting for a HuggingFace course my whole life.\\\", \\\"I hate this so much!\\\"] ) # 结果 # [{'label': 'POSITIVE', 'score': 0.9598048329353333}, # {'label': 'NEGATIVE', 'score': 0.9994558691978455}] \",\"目前支持的 pipeline 见 Model 中心。 如果不想使用默认模型，可通过 model 参数传递对应的模型名称。\",\"from transformers import pipeline generator = pipeline(\\\"text-generation\\\", model=\\\"distilgpt2\\\") generator( \\\"In this course, we will teach you how to\\\", max_length=30, num_return_sequences=2, ) \"]},\"145\":{\"h\":\"2.2 局限性 & 偏见\",\"t\":[\"为了在大规模数据上进行预训练，研究员们会收集尽可能多的数据，这其中可能会夹杂一些意识形态或者价值观的刻板印象。\",\"from transformers import pipeline unmasker = pipeline(\\\"fill-mask\\\", model=\\\"bert-base-uncased\\\") result = unmasker(\\\"This man works as a [MASK].\\\") print([r[\\\"token_str\\\"] for r in result]) result = unmasker(\\\"This woman works as a [MASK].\\\") print([r[\\\"token_str\\\"] for r in result]) \",\"['lawyer', 'carpenter', 'doctor', 'waiter', 'mechanic'] ['nurse', 'waitress', 'teacher', 'maid', 'prostitute'] \",\"观察结果，有明显的性别相关性，妓女成为了“女性工作”相关的前五名答案之一。\",\"注意\",\"原始模型中很容易掺杂性别歧视、种族歧视等问题，在模型上进一步微调并不会消除这种偏差。\"]},\"146\":{\"h\":\"3. Transformer 背景知识\",\"t\":[\"Transformer 架构于 2017 年 6 月推出。大体上可以将 Transformer 模型分为三类：\",\"GPT-like (自回归（auto-regressive）Transformer 模型)\",\"BERT-like (自编码（auto-encoding）Transformer 模型)\",\"BART/T5-like (序列到序列（sequence-to-sequence）Transformer 模型)\"]},\"147\":{\"h\":\"3.1 Transformer 是语言模型（language model）\",\"t\":[\"包括 GPT、BERT、BART、T5 等 Transformer 模型都是语言模型，即他们已经以自监督学习（self-supervised）的方式在大量文本上进行了训练。\",\"这类模型在其进行训练的语料上进行了理解，但是对于具体问题，它就没那么有针对性了，于是我们需要进行迁移学习（transfer learning）。在迁移学习时，对于具体问题，我们使用人工标注的数据以有监督的方式进行精调（fine-tune）。\"]},\"148\":{\"h\":\"3.2 Transformer 是大模型\",\"t\":[\"实现更好性能的一般策略是增加模型的大小以及预训练的数据量。\"]},\"149\":{\"h\":\"3.3 迁移学习（Transfer Learning）\",\"t\":[\"预训练（Pretraining）指从头开始训练模型。这往往需要使用大规模语料，花费长达数周的时间。\",\"微调（Fine-tuning）是在预训练好的模型上进行进一步的训练。要进行微调，你需要使用预训练模型以及针对特定任务的数据集再次进行训练。进行微调可以有效降低时间、设备成本，使用更小的数据集完成。\"]},\"150\":{\"h\":\"4. Transformer 结构\",\"t\":[\"扩展阅读\",\"推荐 The Illustrated Transformer 这篇文章。在该文章中，作者使用动图清晰地描述了 Transformer 的结构和原理。\",\"Transformer 主要由两部分组成：\",\"Encoders (编码器): 编码器接收输入并构建其表示（即特征）。这意味着对模型进行了优化，以从输入中获得理解。\",\"Decoders (解码器): 解码器使用编码器的表示（特征）以及其他输入来生成目标序列。这意味着该模型已针对生成输出进行了优化。\",\"这两部分可以单独使用，这取决于你要做什么任务：\",\"Encoder-only 模型（auto-encoding models）：适用于需要理解输入的任务，如句子分类和命名实体识别。\",\"这类模型有 ALBERT, BERT, DistillBERT, ELECTRA, RoBERTa\",\"Decoder-only 模型（auto-regressive models）：适用于生成任务，如文本生成。\",\"这类模型有 CTRL, GPT, GPT-2, Transformer XL\",\"Encoder-decoder 模型（sequence-to-sequence models）：适用于需要根据输入进行生成的任务，如翻译或摘要。预训练这类模型可以使用 encode 或 decoder 的目标。\",\"这类模型有 BART, mBART, Marian, T5\"]},\"151\":{\"h\":\"4.1 注意力层（Attention Layers）\",\"t\":[\"注意力层使得模型对不同位置的字词有着不同的关注程度。\",\"比如，在做文本翻译任务时，将 \\\"I like eating apples\\\" 翻译成中文，在翻译 like 时，模型需要关注 I 和 eating 来获得正确的翻译，而对 apples 的关注度可能小一些；翻译 \\\"It feels like a soft blanket\\\" 时，关注 feels 会帮助模型获得正确的翻译。\"]},\"152\":{\"h\":\"4.2 原始模型\",\"t\":[\"Transformer 最开始是为了翻译任务而设计的。\",\"在训练过程中，encoder 和 decoder 分别接收两种语言的同一个句子。encoder 使用注意力层，可以“看到”该句子中的全部字词。而 decoder 只能看到已经翻译好的字词（即在正在被翻译的字词之前已经生成的部分）。 比如 decoder 已经生成了3个单词，在生成第4个单词时，我们会把前三个单词也作为输入，连同 encoder 输出的部分一起作为 decoder 的输入来生成第4个单词。\",\"为了加快训练，我们会喂给 decoder 完整的目标，但是不允许它使用没有预测的词汇。例如，我们正在预测第4个单词，但是模型看到了目标中的第4个单词，显然这样的模型在实际中不会获得好的效果。\",\"最初的 Transformer 结构如下：\",\"注意，在 decoder 中，第一个注意力层关注所有 decoder 的过去的输入，第二个注意力层，使用了来自 encoder 的输出。因此它能够获得完整的输入句子来对当前词语进行最佳预测。\",\"我们还可以使用注意力遮罩层（attention mask）以使得模型关注某些表示。比如，在批处理句子时，会使用填充的方式使句子长度保持一致，填充的内容无意义，我们不希望模型关注它。\"]},\"153\":{\"h\":\"5. 小结\",\"t\":[\"本节内容介绍了 NLP 任务以及如何使用 🤗 Transformers 中的 pipeline() 函数来执行不同的 NLP 任务。你可以在模型中心中查找模型，按照 Model Card 中的说明或者使用页面上的 inference API 进行使用。\",\"我们简单介绍了 Transformer 的结构，如果你想做进一步了解，推荐阅读 The Illustrated Transformer。\"]},\"154\":{\"h\":\"2. 使用 🤗 Transformers\",\"t\":[\"Transformer 模型一般都很大，训练或者部署是一项复杂的任务。🤗 Transformers 库提供了简单的API，使得用户可以通过它来加载、训练、保存所有的 Transformer 模型。\",\"我们将使用 model 和 tokenizer 来实现在上一节中 pipeline() 函数完成的任务。然后会介绍 model API，看一看 model 类和 configuration 类，了解如何加载模型、它是怎么处理数字输入并输出预测的。\",\"接下来还有 tokenizer API。tokenizer 负责将文本转成数字表示（以作为神经网络的输入），并负责将数字表示转化成文本。我们还会展示如何批处理多个句子。\"]},\"155\":{\"h\":\"1. Pipeline 都做了什么\",\"t\":[\"上一节中提到的 pipeline() 函数实际上经过了以下几个步骤：预处理、将输入传递给模型、后处理\"]},\"156\":{\"h\":\"1.1 使用 tokenizer 进行预处理\",\"t\":[\"Transformer 模型不能直接处理原始文本，于是要先将文本输入转换成数字表示。实际上，Transformer 模型只接收 tensor 作为输入。\",\"tokenizer 的处理步骤：\",\"将文本切分成 tokens (可能是 words, subwords, 或者 symbols)\",\"将每一个 token 映射到一个数字上\",\"添加可能对模型有用的其他输入\",\"显然，使用模型进行预测时使用的上述操作应该和预训练时的操作一致。我们可以使用 AutoTokenizer 类以及它的 from_pretrained() 函数来实现这一点。使用模型的 checkpoints 名称，它会下载对应模型的 tokenizer 并缓存下来。\",\"在上一节中，我们使用了 sentiment-analysis\",\"from transformers import pipeline classifier = pipeline(\\\"sentiment-analysis\\\") classifier( [ \\\"I've been waiting for a HuggingFace course my whole life.\\\", \\\"I hate this so much!\\\", ] ) \",\"上面模型的默认 checkpoints 是 sentiment-analysis pipeline is distilbert-base-uncased-finetuned-sst-2-english，使用 AutoTokenizer 创建 tokenizer 对象\",\"from transformers import AutoTokenizer checkpoint = \\\"distilbert-base-uncased-finetuned-sst-2-english\\\" tokenizer = AutoTokenizer.from_pretrained(checkpoint) \",\"将文本传递给 tokenizer\",\"raw_inputs = [ \\\"I've been waiting for a HuggingFace course my whole life.\\\", \\\"I hate this so much!\\\", ] # padding, truncation 会在之后介绍；return_tensors 为 pt, 即 pytorch inputs = tokenizer(raw_inputs, padding=True, truncation=True, return_tensors=\\\"pt\\\") print(inputs) \",\"{ 'input_ids': tensor([ [ 101, 1045, 1005, 2310, 2042, 3403, 2005, 1037, 17662, 12172, 2607, 2026, 2878, 2166, 1012, 102], [ 101, 1045, 5223, 2023, 2061, 2172, 999, 102, 0, 0, 0, 0, 0, 0, 0, 0] ]), 'attention_mask': tensor([ [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0] ]) } \"]},\"157\":{\"h\":\"1.2 model\",\"t\":[\"与 AutoTokenizer 类似，🤗 Transformers 库还提供了 AutoModel class，它也有 from_pretrained() 方法。\",\"from transformers import AutoModel checkpoint = \\\"distilbert-base-uncased-finetuned-sst-2-english\\\" model = AutoModel.from_pretrained(checkpoint) \",\"上面的代码下载了 distilbert-base-uncased-finetuned-sst-2-english 的 checkpoints （如果还在同一环境中，那么它在之前已经被缓存了），并实例化了对应的模型。\",\"这个架构只包括最基本的 Transformer 模块，即下图中 Transformer Network 部分。\",\"注意\",\"Transformer Network 即我们在上一节中谈到的 Transformer 架构，这里只是画成 Embedding + Layers\",\"当然 🤗 Transformers 还提供了不同的架构。下面列举了一部分\",\"*Model (retrieve the hidden states)\",\"*ForCausalLM\",\"*ForMaskedLM\",\"*ForMultipleChoice\",\"*ForQuestionAnswering\",\"*ForSequenceClassification\",\"*ForTokenClassification\",\"and others 🤗\"]},\"158\":{\"h\":\"1.2.1 Model 输出（hidden states 或 features）：高维张量\",\"t\":[\"Transformer 模块输出的张量通常很大，它有以下三个维度：\",\"Batch size: 每次处理的序列长度（上述例子中为2）\",\"Sequence length: 序列的数字表示的长度（上述例子中为16）\",\"Hidden size: 每个模型输入的张量维度。通常很大（小模型可能是768，在大一些的模型中可能是3072甚至更大）\",\"我们将上面使用 tokenizer 得到的输入传递给 model，看看它的输出\",\"outputs = model(**inputs) print(outputs.last_hidden_state.shape) \",\"torch.Size([2, 16, 768]) \"]},\"159\":{\"h\":\"1.2.2 Model heads\",\"t\":[\"Model heads 通常有一层或多层线性层组成，以 hidden states 作为输入，将这些高维张量映射到不同的维度上。\",\"我们需要一个有序列分类（sequence classification）head 的模型，于是我们不用 AutoModel 类，我们使用 AutoModelForSequenceClassification。\",\"from transformers import AutoModelForSequenceClassification checkpoint = \\\"distilbert-base-uncased-finetuned-sst-2-english\\\" model = AutoModelForSequenceClassification.from_pretrained(checkpoint) outputs = model(**inputs) print(outputs.logits.shape) \",\"torch.Size([2, 2]) \",\"我们分析的是两个句子，判断每个句子是 positive 还是 negative，所以输出维度是 2x2\"]},\"160\":{\"h\":\"1.3 后处理\",\"t\":[\"print(outputs.logits) \",\"tensor([[-1.5607, 1.6123], [ 4.1692, -3.3464]], grad_fn=<AddmmBackward>) \",\"对于第一个句子，我们预测的是 [-1.5607, 1.6123]，这是logits（所有的 🤗 Transformers 模型输出的都是 logits）。实际上我们更希望得到类似于概率的结果，于是我们将它输入至 SoftMax 层中。\",\"import torch predictions = torch.nn.functional.softmax(outputs.logits, dim=-1) print(predictions) \",\"tensor([[4.0195e-02, 9.5980e-01], [9.9946e-01, 5.4418e-04]], grad_fn=<SoftmaxBackward0>) \",\"我们可以通过查看 model config 的 id2label 属性来查看对应的 label\",\"model.config.id2label \",\"{0: 'NEGATIVE', 1: 'POSITIVE'} \",\"到此为止，我们通过三个步骤（使用 tokenizer 进行预处理，将输入传递给 model，后处理）得到最终的结论：\",\"第一个句子: NEGATIVE: 0.0402, POSITIVE: 0.9598\",\"第二个句子: NEGATIVE: 0.9995, POSITIVE: 0.0005\"]},\"161\":{\"h\":\"2. Models\",\"t\":[\"我们详细介绍下 model。AutoModel 类可以根据 checkpoint 来实例化任何模型。它根据 checkpoint 来确定模型结构，并实例化模型。如果你确切知道你想使用什么类型的模型，你可以直接使用对应的 model 类。\",\"下面将使用 BERT model。\"]},\"162\":{\"h\":\"2.1 创建 Transformer\",\"t\":[\"初始化 BERT 模型的第一步是加载配置对象。\",\"from transformers import BertConfig, BertModel config = BertConfig() model = BertModel(config) \",\"配置中包含很多建立模型要用到的属性。\",\"打印 config 的内容\",\"BertConfig { \\\"attention_probs_dropout_prob\\\": 0.1, \\\"classifier_dropout\\\": null, \\\"hidden_act\\\": \\\"gelu\\\", \\\"hidden_dropout_prob\\\": 0.1, \\\"hidden_size\\\": 768, \\\"initializer_range\\\": 0.02, \\\"intermediate_size\\\": 3072, \\\"layer_norm_eps\\\": 1e-12, \\\"max_position_embeddings\\\": 512, \\\"model_type\\\": \\\"bert\\\", \\\"num_attention_heads\\\": 12, \\\"num_hidden_layers\\\": 12, \\\"pad_token_id\\\": 0, \\\"position_embedding_type\\\": \\\"absolute\\\", \\\"transformers_version\\\": \\\"4.29.1\\\", \\\"type_vocab_size\\\": 2, \\\"use_cache\\\": true, \\\"vocab_size\\\": 30522 } \"]},\"163\":{\"h\":\"2.1.1 不同的加载方法\",\"t\":[\"使用默认的配置来创建 model 时，model 会被随机初始化。\",\"你可以直接使用随机初始化的 model，不过使用效果肯定很差，而重新训练又需要大量的时间和数据。我们不妨加载已经训练好的模型，这要用到 from_pretrained() 方法。\",\"from transformers import BertModel model = BertModel.from_trained(\\\"bert-base-cased\\\") \",\"当然你也可以将 BertModel 替换为 AutoModel\",\"from transformers import AutoModel model = AutoModel.from_trained(\\\"bert-base-cased\\\") \",\"你可以在这个 model card 中查看 BERT 模型的更多细节。\",\"提示\",\"缓存路径为 ~/.cache/huggingface/modules 你可以通过设置 HF_HOME 环境变量来自定义缓存路径。\"]},\"164\":{\"h\":\"2.1.2 保存方法\",\"t\":[\"使用 save_pretrained() 方法来保存模型\",\"model.save_pretrained(\\\"directory_on_my_computer\\\") \",\"这会保存两个文件\",\"ls directory_on_my_computer config.json pytorch_model.bin \",\"你可以在 config.json 中看到建立模型所需的属性。该文件中也有一些 metadata，比如 checkpoint 的来源或路径、你最后一次保存 checkpoint 时使用的 🤗 Transformers 版本\",\"python_model.bin 被称为状态字典（state dictionary）。其中记录了模型的权重。\",\"这两个文件相辅相成，config.json 提供了模型的架构信息，python_model.bin 提供了模型权重。\"]},\"165\":{\"h\":\"2.2 使用 Transformer 进行推理（inference）\",\"t\":[\"在 2.1 中你已经看到了如何加载以及保存使用模型，下面我们来使用模型进行预测。\",\"在 1.1 中，我们已经过如何使用 tokenizer 将文本转化为张量，它将输入的文本转化为数字：\",\"获得 input IDs: model_input\",\"给定文本：\",\"sequences = [\\\"Hello!\\\", \\\"Cool.\\\", \\\"Nice!\\\"] \",\"经 tokenizer 获得 input IDs:\",\"encoded_sequences = [ [101, 7592, 999, 102], [101, 4658, 1012, 102], [101, 3835, 999, 102], ] \",\"Transformer 只接收 tensor，将上面的 list 转化成 tensor：\",\"import torch model_inputs = torch.tensor(encoded_sequences) \",\"现在可以将 model_input 传递给 model 了\",\"output = model(model_inputs) \",\"model 可以接收很多参数，其中 input IDs 只必传的。我们将在未来在讨论其他参数。\"]},\"166\":{\"h\":\"3. Tokenizers\",\"t\":[\"模型只能处理数字，tokenizer 的作用是将文本转化为模型可以处理的数字。它的目标是找到最有意义的表示，并尽可能小。\",\"下面介绍几种 tokenization 算法。\"]},\"167\":{\"h\":\"3.1 tokenization 算法\"},\"168\":{\"h\":\"3.1.1 Word-based\",\"t\":[\"可以使用空格来将句子切分为字词：\",\"tokenized_text = \\\"Jim Henson was a puppeteer\\\".split() print(tokenized_text) # res # ['Jim', 'Henson', 'was', 'a', 'puppeteer'] \",\"也有针对标点符号增加了额外规则的 tokenizer。\",\"使用 word-based tokenizer，我们最终会得到一个非常大的词汇表，此表的大小由语料中的独立 token 数决定。每个字词都被分配了一个 ID，从 0 到整个词表大小。模型使用这些 ID 来表示每个字词。\",\"如果我们想使用这种 tokenizer 来覆盖某门语言，那将会生成大量 token。例如，英语中有 500,000 个单词，于是构建每个单词到 input_id 的映射要有 500,000 个。除此之外，'dog' 和 'dogs', 'run' 和 'running' 会被分别构建不同的 input_id, 没有体现出它们之间的相似与联系。\",\"另外，我们还需要自定义一个 token 来表示不在词表中的字词，也就是 'unknown' token。一般用 '[UNK]' 或 '' 表示。如果某个 tokenizer 产生了大量 unknown token，这意味着它无法检索到一个词的合理表示，且你在这个过程中丢失了信息。我们希望 tokenizer 会将尽量少的字词标记为 unknown token。\",\"下面介绍 character-based tokenizer，它可以减少 unknown token 的产生。\"]},\"169\":{\"h\":\"3.1.2 Character-based\",\"t\":[\"Character-based tokenizer 将文本切分成 characters，而不是 words。这样做有两点好处：\",\"词表将有效地减小\",\"unknown tokens 也会减少（因为每个字词都是通过 character 构建的）\",\"当然，这也会产生一些问题。首先，character 可能本身没有含义（相对于 word 来说。但也因语言而异，比如中文字符会比拉丁系语言的字符携带更多信息）。另外，模型需要处理大量 token（对于 word-based 来说的一个 word 只需要 1 个 token，而使用 character-based，可能有十几个 tokens 要处理）、\",\"考虑到上面两种技术，又提出了第三种方式：subword tokenization\"]},\"170\":{\"h\":\"3.1.3 Subword tokenization\",\"t\":[\"subword tokenization 的原则是：经常使用的词不应该再被切分为更小的子词，比较少用的词可以分解为有意义的子词。\",\"比如：annoyingly 可能被切分成 annoy、ing、ly\",\"以下 tokenization 是 subword tokenization：\",\"Byte-level BPE, GPT-2 使用这种方式\",\"WordPiece, BERT 使用这种方式\",\"SentencePiece or Unigram, 在一些多语言模型中使用\",\"...\"]},\"171\":{\"h\":\"3.2 加载 & 保存\",\"t\":[\"加载和保存 tokenizer 分别使用方法 from_pretrained() 和 save_pretrained(). 使用该方法会加载或保存 tokenizer 使用的算法（类似于 model 的 architecture），还会加载或保存对应的词表（类似于 model 的 weight）\",\"加载 BERT 的 tokenizer\",\"from transformers import BertTokenizer tokenizer = BertTokenizer.from_pretrained(\\\"bert-base-cased\\\") \",\"也可以使用 AutoTokenizer\",\"from transformers import AutoTokenizer tokenizer = AutoTokenizer.from_pretrained(\\\"bert-base-cased\\\") \",\"然后我们就可以使用 tokenizer 将文本转化成 input_ids\",\"tokenizer(\\\"Using a Transformer network is simple\\\") # result: # {'input_ids': [101, 7993, 170, 11303, 1200, 2443, 1110, 3014, 102], # 'token_type_ids': [0, 0, 0, 0, 0, 0, 0, 0, 0], # 'attention_mask': [1, 1, 1, 1, 1, 1, 1, 1, 1]} \",\"保存 tokenizer\",\"tokenizer.save_pretrained(\\\"directory_on_my_computer\\\") \",\"我们将在 Chapter 3 中来讨论 token_type_ids。并在 4.3 中讨论 attention_mask。下面我们先介绍下 input_ids 如何生成，为此我们要查看 tokenizer 的中间方法。\"]},\"172\":{\"h\":\"3.3 编码（Encoding）\",\"t\":[\"将文本转换成数字的过程叫做编码（Encoding）。Encoding 的分为两步：tokenization，然后转化为 input IDs.\",\"第一步是将文本切分为 tokens。实现这一步有不同的规则（见 3.1），所以我们需要用我们所选的模型的名称来实例化 tokenizer，以确保使用和预训练时相同的规则。\",\"第二步是将 tokens 转化为数字表示，所以我们可以用它们构建张量并把张量提供给模型。为了实现这一步骤，tokenizer 需要一个词表（vocabulary），我们在使用 from_pretrained() 来实例化 tokenizer 的时候已经下载好了。同样地，这个词表和预训练时的词表是相同的。\",\"下面分别介绍这两步。注意，在使用过程中直接调用 tokenizer 就可以，下面的分步调用只是为了让大家更清楚 encoding 的两个步骤分别做了什么。\"]},\"173\":{\"h\":\"3.3.1 Tokenization\",\"t\":[\"Tokenization 过程可以使用 tokenizer 的 tokenize() 方法实现：\",\"from transformers import AutoTokenizer tokenizer = AutoTokenizer.from_pretrained(\\\"bert-based-cased\\\") sequence = \\\"Using a Transformer network is simple\\\" tokens = tokenizer.tokenize(sequence) print(tokens) # result: # ['Using', 'a', 'transform', '##er', 'network', 'is', 'simple'] \"]},\"174\":{\"h\":\"3.3.2 将 tokens 转换为 input IDs\",\"t\":[\"该过程通过 convert_tokens_to_ids() 实现。\",\"ids = tokenizer.convert_tokens_to_ids(tokens) print(ids) # result: # [7993, 170, 11303, 1200, 2443, 1110, 3014] \"]},\"175\":{\"h\":\"3.4 解码（Decoding）\",\"t\":[\"解码（decoding）和编码（encoding）的该过程相反，将词表索引转化成字符串，可以使用 decode() 方法来实现\",\"decoded_string = tokenizer.decode([7993, 170, 11303, 1200, 2443, 1110, 3014]) print(decoded_string) # result: # 'Using a Transformer network is simple' \",\"注意，decode() 方不仅将索引转化为了 tokens，还将同一个词中的 tokens 组合在一起了。\"]},\"176\":{\"h\":\"3.5 小结\",\"t\":[\"通过本章的学习，你应该了解 tokenizer 的原子操作：tokenization、将 tokens 转化成 input_ids、将 ids 转化为字符串。\"]},\"177\":{\"h\":\"4. 处理多个序列\",\"t\":[\"在之前的例子中，我们对小长度的序列进行了处理。我们需要思考以下问题：\",\"如何处理多个序列\",\"如何处理不同长度的多个序列\",\"词汇表索引是唯一能够使模型正常工作的输入吗\",\"是否存在序列过长的问题\"]},\"178\":{\"h\":\"4.1 批处理\",\"t\":[\"import torch from transformers import AutoTokenizer, AutoModelForSequenceClassification checkpoint = \\\"distilbert-base-uncased-finetuned-sst-2-english\\\" tokenizer = AutoTokenizer.from_pretrained(checkpoint) model = AutoModelForSequenceClassification.from_pretrained(checkpoint) sequence = \\\"I've been waiting for a HuggingFace course my whole life.\\\" tokens = tokenizer.tokenize(sequence) ids = tokenizer.convert_tokens_to_ids(tokens) input_ids = torch.tensor(ids) # This line will fail. model(input_ids) # IndexError: Dimension out of range (expected to be in range of [-1, 0], but got 1) \",\"为什么会出错呢？🤗 Transformers 模型默认接收多个句子作为输入，但我们只传递来一个序列。\",\"在此之前我们直接调用 tokenizer 时，在顶部加了一个维度：\",\"tokenized_input = tokenizer(sequence, return_tensors=\\\"pt\\\") print(tokenized_inputs[\\\"input_ids\\\"]) # result: # tensor([[ 101, 1045, 1005, 2310, 2042, 3403, 2005, 1037, 17662, 12172, # 2607, 2026, 2878, 2166, 1012, 102]]) \",\"tokenizer 可以将序列转化成特定结构的 tensor，通过 return_tensors 参数设置\",\"sequences = [\\\"I've been waiting for a HuggingFace course my whole life.\\\", \\\"So have I!\\\"] # Returns PyTorch tensors model_inputs = tokenizer(sequences, padding=True, return_tensors=\\\"pt\\\") # Returns TensorFlow tensors model_inputs = tokenizer(sequences, padding=True, return_tensors=\\\"tf\\\") # Returns NumPy arrays model_inputs = tokenizer(sequences, padding=True, return_tensors=\\\"np\\\") \",\"我们对起初的代码进行修改：\",\"import torch from transformers import AutoTokenizer, AutoModelForSequenceClassification checkpoint = \\\"distilbert-base-uncased-finetuned-sst-2-english\\\" tokenizer = AutoTokenizer.from_pretrained(checkpoint) model = AutoModelForSequenceClassification.from_pretrained(checkpoint) sequence = \\\"I've been waiting for a HuggingFace course my whole life.\\\" tokens = tokenizer.tokenize(sequence) ids = tokenizer.convert_tokens_to_ids(tokens) input_ids = torch.tensor([ids]) print(input_ids) # tensor([[ 1045, 1005, 2310, 2042, 3403, 2005, 1037, 17662, 12172, 2607, 2026, 2878, 2166, 1012]]) output = model(input_ids) print(output.logits) # tensor([[-2.7276, 2.8789]], grad_fn=<AddmmBackward0>) \",\"Batching 是指一次向模型传递多个句子\",\"batched_ids = [ids, ids] \"]},\"179\":{\"h\":\"4.2 填充（Padding）\",\"t\":[\"当进行批处理时，如果两个序列的长度不一样怎么办（对于 tensor 来说，它必须是矩阵，即每个序列的表示应该是一样长的），为了解决这个问题，我们将填充（pad）输入。\",\"对于短的序列，我们使用 padding token 来填充，使其和最长的序列一样长。\",\"# 我们无法将这个 batch 转化成 tensor bached_id_origin = [ [200, 200, 200], [200, 200] ] padding_id = 100 # 使用 padding batched_ids = [ [200, 200, 200], [200, 200, padding_id] ] \",\"可以在 tokenizer.pad_token_id 中获取 padding token id。\",\"model = AutoModelForSequenceClassification.from_pretrained(checkpoint) sequence1_ids = [[200, 200, 200]] sequence2_ids = [[200, 200]] batched_ids = [ [200, 200, 200], [200, 200, tokenizer.pad_token_id], ] print(model(torch.tensor(sequence1_ids)).logits) print(model(torch.tensor(sequence2_ids)).logits) print(model(torch.tensor(batched_ids)).logits) \",\"tensor([[ 1.5694, -1.3895]], grad_fn=<AddmmBackward0>) tensor([[ 0.5803, -0.4125]], grad_fn=<AddmmBackward0>) tensor([[ 1.5694, -1.3895], [ 1.3374, -1.2163]], grad_fn=<AddmmBackward0>) \",\"观察上面的结果，batched_ids 的结果的第二行与 sequence2_ids 的结果不一样，这显然是不应该的。\",\"造成不一致是因为，Transformer 中的 attention layers 将每个 token 都作为上下文考虑进去了。那么 padding tokens 也会被考虑进去。如果想让两次的结果相同，需要告诉 attention layer 忽略 padding tokens。这要通过 attention mask 来实现。\"]},\"180\":{\"h\":\"4.3 Attention Masks\",\"t\":[\"attention mask 也是 tensor，它和 input IDs tensor 结构相同，元素只有 0 和 1：0 表示该位置是 padding tokens，attention layers 应该忽略它。\",\"我们将 attention_mask 作为参数传递给 model，再观察结果，和 sequence2_ids 的结果一致了：\",\"batched_ids = [ [200, 200, 200], [200, 200, tokenizer.pad_token_id], ] attention_mask = [ [1, 1, 1], [1, 1, 0] ] print(model(torch.tensor(batched_ids), attention_mask=torch.tensor(attention_mask)).logits) # tensor([[ 1.5694, -1.3895], # [ 0.5803, -0.4125]], grad_fn=<AddmmBackward0>) \",\"sequences = [\\\"I've been waiting for a HuggingFace course my whole life.\\\", \\\"So have I!\\\"] model_inputs = tokenizer(sequences) print(model_inputs) # Will pad the sequences up to the maximum sequence length model_inputs = tokenizer(sequences, padding=\\\"longest\\\") print(model_inputs) # Will pad the sequences up to the model max length # (512 for BERT or DistilBERT) model_inputs = tokenizer(sequences, padding=\\\"max_length\\\") print(model_inputs) # Will pad the sequences up to the specified max length model_inputs = tokenizer(sequences, padding=\\\"max_length\\\", max_length=8) print(model_inputs) \",\"输出\",\"{'input_ids': [[101, 1045, 1005, 2310, 2042, 3403, 2005, 1037, 17662, 12172, 2607, 2026, 2878, 2166, 1012, 102], [101, 2061, 2031, 1045, 999, 102]], 'attention_mask': [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]]} {'input_ids': [[101, 1045, 1005, 2310, 2042, 3403, 2005, 1037, 17662, 12172, 2607, 2026, 2878, 2166, 1012, 102], [101, 2061, 2031, 1045, 999, 102, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], 'attention_mask': [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]} {'input_ids': [[101, 1045, 1005, 2310, 2042, 3403, 2005, 1037, 17662, 12172, 2607, 2026, 2878, 2166, 1012, 102, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [101, 2061, 2031, 1045, 999, 102, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], 'attention_mask': [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]} {'input_ids': [[101, 1045, 1005, 2310, 2042, 3403, 2005, 1037, 17662, 12172, 2607, 2026, 2878, 2166, 1012, 102], [101, 2061, 2031, 1045, 999, 102, 0, 0]], 'attention_mask': [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 0, 0]]} \"]},\"181\":{\"h\":\"4.4 长序列\",\"t\":[\"Transformer 模型能处理的序列长度是有限的，大都在 512 至 1024 个 tokens 之间。如果传入了大于最大限度的序列会崩溃，有两种方式来解决这个问题：\",\"换用支持更长序列的模型。像 Longformer 和 LED 就能处理比较长的序列。\",\"截断序列。\",\"sequence = sequence[:max_sequence_length] \",\"可以使用 tokenizer 进行截断\",\"sequences = [\\\"I've been waiting for a HuggingFace course my whole life.\\\", \\\"So have I!\\\"] # Will truncate the sequences that are longer than the model max length # (512 for BERT or DistilBERT) model_inputs = tokenizer(sequences, truncation=True) print(model_inputs) # Will truncate the sequences that are longer than the specified max length model_inputs = tokenizer(sequences, max_length=8, truncation=True) print(model_inputs) \",\"{'input_ids': [[101, 1045, 1005, 2310, 2042, 3403, 2005, 1037, 17662, 12172, 2607, 2026, 2878, 2166, 1012, 102], [101, 2061, 2031, 1045, 999, 102]], 'attention_mask': [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]]} {'input_ids': [[101, 1045, 1005, 2310, 2042, 3403, 2005, 102], [101, 2061, 2031, 1045, 999, 102]], 'attention_mask': [[1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]]} \"]},\"182\":{\"h\":\"5. Tokenizer API\",\"t\":[\"我们可以使用 tokenizer 来 padding、truncate 序列，也可以指定 return_tensors 的类型（4 中已有对应示例）。\"]},\"183\":{\"h\":\"5.1 特殊 token\",\"t\":[\"sequence = \\\"I've been waiting for a HuggingFace course my whole life.\\\" model_inputs = tokenizer(sequence) print(model_inputs[\\\"input_ids\\\"]) tokens = tokenizer.tokenize(sequence) ids = tokenizer.convert_tokens_to_ids(tokens) print(ids) \",\"[101, 1045, 1005, 2310, 2042, 3403, 2005, 1037, 17662, 12172, 2607, 2026, 2878, 2166, 1012, 102] [1045, 1005, 2310, 2042, 3403, 2005, 1037, 17662, 12172, 2607, 2026, 2878, 2166, 1012] \",\"首位各添加了一个 token ID，我们将其进行 decode：\",\"print(tokenizer.decode(model_inputs[\\\"input_ids\\\"])) print(tokenizer.decode(ids)) \",\"\\\"[CLS] i've been waiting for a huggingface course my whole life. [SEP]\\\" \\\"i've been waiting for a huggingface course my whole life.\\\" \",\"tokenizer 添加了两个特殊词 “[CLS]” 和 “[SEP]”。这是在预训练时使用的，所以我们在使用该模型做推理的时候也应该在首尾加上它们。不同的模型会使用不同的特殊词，有些模型不用特殊词，有些模型只在句首加特殊词，有些模型只在句尾加特殊词。不论如何，tokenizer 总是知道应该是怎样的，并会为你处理好它。\"]},\"184\":{\"h\":\"5.2 小结\",\"t\":[\"最后让我们看一看如何使用 tokenizer 和 model 来进行 inference，我们使用了 padding（为了批处理），使用了 truncate（为了处理长序列）。\",\"import torch from transformers import AutoTokenizer, AutoModelForSequenceClassification checkpoint = \\\"distilbert-base-uncased-finetuned-sst-2-english\\\" tokenizer = AutoTokenizer.from_pretrained(checkpoint) model = AutoModelForSequenceClassification.from_pretrained(checkpoint) sequences = [\\\"I've been waiting for a HuggingFace course my whole life.\\\", \\\"So have I!\\\"] tokens = tokenizer(sequences, padding=True, truncation=True, return_tensors=\\\"pt\\\") output = model(**tokens) \"]},\"185\":{\"h\":\"总结\",\"t\":[\"Transformer 的基本结构\",\"tokenization pipeline 的组成\",\"如何使用 Transformer model\",\"如何利用 tokenizer 将文本转化为 tensor\",\"使用 tokenizer 和 model 来进行推理\",\"input IDs 的限制，了解 attention masks\",\"尝试了多种可配置的 tokenizer 方法\"]},\"186\":{\"h\":\"3. 微调预训练模型\",\"t\":[\"上一篇文章中介绍了如何使用 tokenizer 和预训练模型来进行推理。接下来我们将介绍如何在自己的数据集上进行微调（Fine-tuning）。在本篇文章中，你将了解到：\",\"如何从 Hub 中准备大型数据集\",\"如何使用 high-level API 微调模型\",\"如何使用自定义训练过程\",\"如何利用 🤗 Accelerate 库在任何分布式设备上轻松运行自定义训练过程\"]},\"187\":{\"h\":\"1. 处理数据\",\"t\":[\"注\",\"如果你不想了解这些细节，或者想先运行数据处理的整体代码，请直接从 2 开始阅读\",\"Hub 中不仅有 models，还有很多 datasets.\",\"我们将使用 MRPC（Microsoft Research Paraphrase Corpus）数据集，它是 GLUE benchmark 的十个数据集之一，该 benchmark 用来衡量 ML 模型在 10 个不同文本分类任务中的性能。MRPC 数据集有 5801 个句子对，每个句子对有一个标签来指明两个句子是否同义。\"]},\"188\":{\"h\":\"1.1 从 Hub 中加载数据集\",\"t\":[\"🤗 Datasets 库提供了简单易用的命令来下载并缓存 Hub 中的数据集\",\"from datasets import load_dataset raw_datasets = load_dataset(\\\"glue\\\", \\\"mrpc\\\") raw_datasets \",\"DatasetDict({ train: Dataset({ features: ['sentence1', 'sentence2', 'label', 'idx'], num_rows: 3668 }) validation: Dataset({ features: ['sentence1', 'sentence2', 'label', 'idx'], num_rows: 408 }) test: Dataset({ features: ['sentence1', 'sentence2', 'label', 'idx'], num_rows: 1725 }) }) \",\"我们得到了一个 DatasetDict 对象，它有 training set, validation set, 和 test set。每一个集合中包含这样几列：sentence1、sentence2、label、idx，以及行数（即数据数量）。\",\"提示\",\"缓存路径为 ~/.cache/huggingface/datasets 你可以通过设置 HF_HOME 环境变量来自定义缓存路径。\",\"你可以先看看数据：\",\"raw_train_dataset = raw_datasets[\\\"train\\\"] raw_train_dataset[0] \",\"{'sentence1': 'Amrozi accused his brother , whom he called \\\" the witness \\\" , of deliberately distorting his evidence .', 'sentence2': 'Referring to him as only \\\" the witness \\\" , Amrozi accused his brother of deliberately distorting his evidence .', 'label': 1, 'idx': 0} \",\"可以通过查看 raw_train_dataset 的 features 来查看 label 的含义。0 是 not_equivalent，1 是 equivalent。\",\"raw_train_dataset.features \",\"{'sentence1': Value(dtype='string', id=None), 'sentence2': Value(dtype='string', id=None), 'label': ClassLabel(names=['not_equivalent', 'equivalent'], id=None), 'idx': Value(dtype='int32', id=None)} \"]},\"189\":{\"h\":\"1.2 数据集预处理\",\"t\":[\"我们需要将文本转化成数字表示，这样模型才能进行处理。\",\"from transformers import AutoTokenizer checkpoint = \\\"bert-base-uncased\\\" tokenizer = AutoTokenizer.from_pretrained(checkpoint) tokenized_sentences_1 = tokenizer(raw_datasets[\\\"train\\\"][\\\"sentence1\\\"]) tokenized_sentences_2 = tokenizer(raw_datasets[\\\"train\\\"][\\\"sentence2\\\"]) \",\"上面的代码确实将文本转化成了数字表示，但是我们需要传入句子对\",\"inputs = tokenizer(\\\"This is the first sentence.\\\", \\\"This is the second one.\\\") print(inputs) print(tokenizer.convert_ids_to_tokens(inputs[\\\"input_ids\\\"])) \",\"{'input_ids': [101, 2023, 2003, 1996, 2034, 6251, 1012, 102, 2023, 2003, 1996, 2117, 2028, 1012, 102], 'token_type_ids': [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1], 'attention_mask': [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]} ['[CLS]', 'this', 'is', 'the', 'first', 'sentence', '.', '[SEP]', 'this', 'is', 'the', 'second', 'one', '.', '[SEP]'] \",\"我们在上一篇文章中介绍了 input_ids 和 attention_mask，没有介绍 token_type_ids。在这个例子中，token_type_ids 表示输入的哪部分是第一个句子，哪一个是第二个句子。\",\"我们可以看到模型需要的输入形式是 [CLS] sentence1 [SEP] sentence2 [SEP]（使用不同的 checkpoints 时该结构会不一样），所以 token_type_ids（使用其他的 checkpoints 时，可能不会有 token_type_ids） 的值是\",\"['[CLS]', 'this', 'is', 'the', 'first', 'sentence', '.', '[SEP]', 'this', 'is', 'the', 'second', 'one', '.', '[SEP]'] [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1] \",\"我们可以为 tokenizer 提供句子对列表\",\"tokenized_dataset = tokenizer( raw_datasets[\\\"train\\\"][\\\"sentence1\\\"], raw_datasets[\\\"train\\\"][\\\"sentence2\\\"], padding=True, truncation=True, ) \",\"这是有用的，但是也有一些不足。tokenization 过程中需要在 RAM 中保存整个数据集，如果你的 RAM 空间不足将会有问题。\",\"我们使用 Dataset.map() 方法来构建数据集，它不会将整个 dataset 都加载到内存中，且结果会被缓存，下次执行时不需要重复计算。首先创建函数对输入进行 tokenization：\",\"def tokenized_function(example): return tokenizer(example[\\\"sentence1\\\"], example[\\\"sentence2\\\"], truncation=True) \",\"我们将 padding 参数去掉了，因为将所有的数据 padding 到最大长度效率不高，更好的做法是当我们构建一个 batch 时 pad 该 batch 中的数据，这样我们只需要将长度填充为该 batch 中的最大长度。\",\"# 设置 batched 为 True，使得同时对数据集中的多个元素同时做处理，加速了预处理 tokenized_datasets = raw_datasets.map(tokenized_function, batched=True) tokenized_datasets \",\"DatasetDict({ train: Dataset({ features: ['sentence1', 'sentence2', 'label', 'idx', 'input_ids', 'token_type_ids', 'attention_mask'], num_rows: 3668 }) validation: Dataset({ features: ['sentence1', 'sentence2', 'label', 'idx', 'input_ids', 'token_type_ids', 'attention_mask'], num_rows: 408 }) test: Dataset({ features: ['sentence1', 'sentence2', 'label', 'idx', 'input_ids', 'token_type_ids', 'attention_mask'], num_rows: 1725 }) }) \",\"🤗 Datasets 库用 map() 函数的处理方式是想数据集中添加新的字段，新的字段即预处理函数返回的字典中的每个键。\",\"可以通过传递 num_proc 参数给 map() 以启动多进程。🤗 Tokenizers 库已经使用了多线程，于是这里我们没有启用多进程。\",\"最后一项任务就是在每个 batch 进行 padding，即 dynamic padding.\"]},\"190\":{\"h\":\"1.3 动态填充（Dynamic Padding）\",\"t\":[\"在批处理中这将数据整理到一个 batch 的函数称为 collate function. 它是构建 DataLoader 时的一个参数，默认是一个函数，它把你的数据集转化为 Pytorch tensors，并将它们拼接起来。\",\"🤗 Transformers 库通过 DataCollatorWithPadding 提供了 collate function。它接收一个 tokenizer (以获取 padding token、确定是在输入的左侧还是右侧进行 padding)。\",\"from transformers import DataCollatorWithPadding data_collator = DataCollatorWithPadding(tokenizer=tokenizer) \",\"我们可以验证一下 data_collator 是否能在 batch 上进行正确的 padding\",\"samples = tokenized_datasets[\\\"train\\\"][:8] samples = {k: v for k, v in samples.items() if k not in [\\\"idx\\\", \\\"sentence1\\\", \\\"sentence2\\\"]} [len(x) for x in samples[\\\"input_ids\\\"]] # [50, 59, 47, 67, 59, 50, 62, 32] \",\"我们取了 train set 中前 8 个作为一个 batch，去掉了 idx、sentence1、sentence2 字段。\",\"input_ids 的最大长度为 67，则这个 batch 经过 padding 之后将会被填充到 67\",\"batch = data_collator(samples) {k: v.shape for k, v in batch.items()} \",\"{'attention_mask': torch.Size([8, 67]), 'input_ids': torch.Size([8, 67]), 'token_type_ids': torch.Size([8, 67]), 'labels': torch.Size([8])} \",\"现在，我们已经将原数数据转化成模型可处理的 batches，下面我们要进行微调了。\"]},\"191\":{\"h\":\"2. 使用 Trainer API 进行微调\",\"t\":[\"🤗 Transformers 提供了 Trainer 类来微调各种预训练模型。最难的步骤大概是为 Trainer.train() 配置运行环境。\",\"我们快速回顾一下上一部分的预处理：\",\"from datasets import load_dataset from transformers import AutoTokenizer, DataCollatorWithPadding raw_dataset = load_dataset(\\\"glue\\\", \\\"mrpc\\\") checkpoint = \\\"bert-base-uncased\\\" tokenizer = AutoTokenizer.from_pretrained(checkpoint) def tokenize_function(example): return tokenizer(example[\\\"sentence1\\\"], example[\\\"sentence2\\\"], truncation=True) tokenized_datasets = raw_dataset.map(tokenize_function, batched=True) data_collator = DataCollatorWithPadding(tokenizer=tokenizer) \"]},\"192\":{\"h\":\"2.1 训练（Training）\",\"t\":[\"第一步，在我们定义 Trainer 之前我们要先定义 TrainingArguments 类，它包含 Trainer 训练和评估时所用的全部超参。必须提供的唯一参数是训练模型的存储路径，也是 checkpoints 的路径。其余的参数都可以设置为默认值，对于基础的微调来说表现得也很不错。\",\"from transformers import TrainingArguments training_args = TrainingArguments(\\\"test-trainer\\\") \",\"提示\",\"如果你想在训练过程中自动上传你的模型到 Hub 上，可以在 TrainingArguments 中传递 push_to_hub=True。我们将在 Chapter 4 中详细介绍。\",\"🤗 官方示例 accelerate 版本错误解决方案\",\"在 CoLab 上运行 🤗 官方示例时，如果遇到下面的错误，\",\"ImportError: Using the `Trainer` with `PyTorch` requires `accelerate>=0.20.1`: Please run `pip install transformers[torch]` or `pip install accelerate -U` \",\"可以尝试下面方法，首先更新 accelerate 和 transformers\",\"!pip install -U accelerate !pip install -U transformers \",\"然后 Restart runtime\",\"第二步，定义模型。\",\"from transformers import AutoModelForSequenceClassification model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=2) \",\"在实例化 model 时你会看到 warning，这是因为 BERT 没有对句子对进行过预训练，于是预训练模型的 head 被替换成了做 sequence classification 的 head。\",\"现在我们可以定义 Trainer 了，将我们之前构造的对象（model, training_args, training & validation datasets, data_collator 以及 tokenizer）作为参数传递。\",\"from transformers import Trainer trainer = Trainer( model, training_args, train_dataset=tokenized_datasets[\\\"train\\\"], eval_dataset=tokenized_datasets[\\\"validation\\\"], data_collator=data_collator, tokenizer=tokenizer, ) \",\"注意\",\"当在 Trainer 中传递 tokenizer 时，Trainer 使用的默认 data_collator 和我们之前使用 DataCollatorWithPadding 定义的是一样的。所以我们可以不传递 data_collator。\",\"调用 Trainer 的 train() 方法，我们就可以在自己的数据集上微调模型了。\",\"trainer.train() \",\"运行上面代码后，我们将开始微调，每 500 steps 会输出一次 training loss。但是它不会告诉你这个模型表现得怎么样，因为：\",\"我们没有配置 Trainer 让它在训练时进行评估。想要进行评估可以设置 evaluation_strategy 为 “steps”（每eval_steps 进行评估） 或 “epoch”（在每个 epoch 之后进行评估）。\",\"我们没有为 Trainer 提供评估的方法。我们可以传递通过 compute_metrics() 函数提供计算模型性能的方法。没有提供该方法的话，评估时会直接输出 loss，并不直观。\"]},\"193\":{\"h\":\"2.2 评估（Evaluation）\",\"t\":[\"我们来看一下如何构建 compute_metrics() 函数并在训练时使用它。\",\"可以使用 Trainer.predict() 方法进行预测。\",\"predictions = trainer.predict(tokenized_datasets[\\\"validation\\\"]) print(predictions.predictions.shape, predictions.label_ids.shape) # (408, 2) (408,) import numpy as np # predictions.predictions 的输出是 logits，为了获得预测结果，可以将 logits 的最大值的取出 preds = np.argmax(predictions.predictions, axis=-1) \",\"Trainer.predict() 的输出是一个命名元祖，有三个字段：predictions, label_ids, 和 metrics。metrics 字段包含 loss、时间 metrics（预测用了多长时间，总计时长、平均时长）。如果我们自定义了 compute_metrics() 函数并传递给了 Trainer，那么该字段还会包括 compute_metrics() 函数返回的 metrics。\",\"构建 compute_metrics() 需要用到 🤗 Evaluate 库。我们可以使用 evaluate.load() 函数加载与 MRPC 数据集有关的 metrics，它返回的对象有 compute() 方法，可以用来进行 metric calculation。\",\"import evaluate metric = evaluate.load(\\\"glue\\\", \\\"mrpc\\\") metric.compute(predictions=preds, references=predictions.label_ids) \",\"{'accuracy': 0.8578431372549019, 'f1': 0.8996539792387542} \",\"我们最终得到了 accuracy 和 f1。这是用来衡量 MRPC 的 metrics。\",\"现在我们可以定义 compute_metrics() 函数了：\",\"def compute_metrics(eval_preds): metric = evaluate.load(\\\"glue\\\", \\\"mrpc\\\") logits, labels = eval_preds predictions = np.argmax(logits, axis=-1) return metric.compute(predictions=predictions, references=labels) \",\"如果想要在每个 epoch 之后输出这些 metrics，我们可以在 Trainer 中传递 compute_metrics() 函数\",\"training_args = TrainingArguments(\\\"test-trainer\\\", evaluation_strategy=\\\"epoch\\\") model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=2) trainer = Trainer( model, training_args, train_dataset=tokenized_datasets[\\\"train\\\"], eval_dataset=tokenized_datasets[\\\"validation\\\"], data_collator=data_collator, tokenizer=tokenizer, compute_metrics=compute_metrics, ) \",\"这次我们再执行 trainer.train() 时就会在每个 epoch 结束时输出 validation loss 和 metrics。\",\"Trainer 在多 GPU 和多 TPU 上开箱即用，且提供了很多配置项，比如通过配置 fp16=True 来启动 mixed-precision 训练。我们会在第 10 章介绍这些配置项。\"]},\"194\":{\"h\":\"3. 使用 Pytorch 训练\",\"t\":[\"在 2 中我们介绍了如何使用 Trainer 类进行微调。现在我们不使用 Trainer 来达到同样的目的。\",\"数据预处理的方式和之前介绍的一样，我们假定你已经完成了这步。\",\"数据预处理\",\"from datasets import load_dataset from transformers import AutoTokenizer, DataCollatorWithPadding raw_datasets = load_dataset(\\\"glue\\\", \\\"mrpc\\\") checkpoint = \\\"bert-base-uncased\\\" tokenizer = AutoTokenizer.from_pretrained(checkpoint) def tokenize_function(example): return tokenizer(example[\\\"sentence1\\\"], example[\\\"sentence2\\\"], truncation=True) tokenized_datasets = raw_datasets.map(tokenize_function, batched=True) data_collator = DataCollatorWithPadding(tokenizer=tokenizer) \"]},\"195\":{\"h\":\"3.1 准备\",\"t\":[\"之前我们直接将 tokenized_datasets 传给 Trainer 让它自己处理，现在我们需要手动处理：\",\"tokenized_datasets 中的 sentence1, sentence2, idx 不是 model 需要的输入，需要删掉\",\"将列 label 改为 labels\",\"将 dataset 的格式设为 Pytorch tensor\",\"对应的代码：\",\"tokenized_datasets = tokenized_datasets.remove_columns([\\\"sentence1\\\", \\\"sentence2\\\", \\\"idx\\\"]) tokenized_datasets = tokenized_datasets.rename_column(\\\"label\\\", \\\"labels\\\") tokenized_datasets.set_format(\\\"torch\\\") tokenized_datasets[\\\"train\\\"].column_names \",\"['labels', 'input_ids', 'token_type_ids', 'attention_mask'] \",\"接下来在定义 training loop 之前，还要先定义几个对象：\"]},\"196\":{\"h\":\"3.1.1 数据加载器（dataloader）：用于迭代批次\",\"t\":[\"from torch.utils.data import DataLoader train_dataloader = DataLoader( tokenized_datasets[\\\"train\\\"], shuffle=True, batch_size=8, collate_fn=data_collator ) eval_dataloader = DataLoader( tokenized_datasets[\\\"validation\\\"], batch_size=8, collate_fn=data_collator ) \",\"快速检验下是否有错\",\"for batch in train_dataloader: break {k: v.shape for k, v in batch.items()} \",\"{'labels': torch.Size([8]), 'input_ids': torch.Size([8, 76]), 'token_type_ids': torch.Size([8, 76]), 'attention_mask': torch.Size([8, 76])} \",\"至此，数据预处理完成了。\"]},\"197\":{\"h\":\"3.1.2 model\",\"t\":[\"from transformers import AutoModelForSequenceClassification model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=2) \",\"快速检验下是否有错\",\"我们将上面检验 dataloader 是否出错时使用的 batch 传递给 model\",\"outputs = model(**batch) print(outputs.loss, outputs.logits.shape) \",\"tensor(0.6617, grad_fn=<NllLossBackward0>) torch.Size([8, 2]) \"]},\"198\":{\"h\":\"3.1.3 优化器（optimizer）\",\"t\":[\"我们使用 Trainer 的默认 optimizer：AdamW，它和 Adam 类似，主要差异在于他们的权重衰减正则化（weight decay regularization）不同。\",\"from transformers import AdamW optimizer = AdamW(model.parameters(), lr=5e-5) \"]},\"199\":{\"h\":\"3.1.4 学习率调度器（learning rate scheduler）\",\"t\":[\"默认的 learning rate scheduler 实现的是简单的从 5e-5 到 0 的线性衰减。为了定义学习率调度器，我们需要知道要进行多少 training steps，即 epoch 乘 training batches（training dataloader 的长度）。\",\"from transformers import get_scheduler # Trainer 默认训练 3 轮 num_epochs = 3 num_training_steps = num_epochs * len(train_dataloader) lr_scheduler = get_scheduler( \\\"linear\\\", optimizer=optimizer, num_warmup_steps=0, num_training_steps=num_training_steps, ) print(num_training_steps) # 1377 \"]},\"200\":{\"h\":\"3.2 Training Loop\",\"t\":[\"我们可以设置 device 为 gpu 以让 model在 GPU 上运行：\",\"import torch device = torch.device(\\\"cuda\\\") if torch.cuda.is_available() else torch.device(\\\"cpu\\\") model.to(device) \",\"现在可以开始训练啦！为了让我们知道训练的进度，可以使用进度条（tqdm 库）。\",\"from tqdm.auto import tqdm progress_bar = tqdm(range(num_training_steps)) model.train() for epoch in range(number_epochs): for batch in train_dataloader: batch = {k: v.to(device) for k, v in batch.items()} outputs = model(**batch) loss = outputs.loss loss.backward() optimizer.step() lr_scheduler.step() optimizer.zero_grad() progress_bar.update(1) \",\"下面我们添加一些输出，以在训练过程中查看训练效果\"]},\"201\":{\"h\":\"3.3 Evaluation Loop\",\"t\":[\"我们仍然使用 🤗 Evaluate 库提供的 metric。之前我们用过 metric.compute() 方法了。在 prediction loop 中使用 add_batch() ，metrics 会跟着 batches 累积，当我们将全部 batch 的结果累积后就可以使用 metric.compute() 得到最后的结果。\",\"import evaluate metric = evaluate.load(\\\"glue\\\", \\\"mrpc\\\") model.eval() for batch in eval_dataloader: batch = {k: v.to(device) for k, v in batch.items()} with torch.no_grad(): outputs = model(**batch) logits = outputs.logits predictions = torch.argmax(logits, dim=-1) metric.add_batch(predictions=predictions, references=batch[\\\"labels\\\"]) metric.compute() \",\"{'accuracy': 0.8431372549019608, 'f1': 0.8907849829351535} \"]},\"202\":{\"h\":\"3.4 使用 🤗 Accelerate 进行加速\",\"t\":[\"使用 🤗 Accelerate 我们可以在多个 GPU 或 TPU 上进行分布式训练。\",\"我们在之前的代码上进行简单修改即可完成：\",\"+ from accelerate import Accelerator from transformers import AdamW, AutoModelForSequenceClassification, get_scheduler + accelerator = Accelerator() model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=2) optimizer = AdamW(model.parameters(), lr=3e-5) - device = torch.device(\\\"cuda\\\") if torch.cuda.is_available() else torch.device(\\\"cpu\\\") - model.to(device) + train_dataloader, eval_dataloader, model, optimizer = accelerator.prepare( + train_dataloader, eval_dataloader, model, optimizer + ) num_epochs = 3 num_training_steps = num_epochs * len(train_dataloader) lr_scheduler = get_scheduler( \\\"linear\\\", optimizer=optimizer, num_warmup_steps=0, num_training_steps=num_training_steps, ) progress_bar = tqdm(range(num_training_steps)) model.train() for epoch in range(num_epochs): for batch in train_dataloader: - batch = {k: v.to(device) for k, v in batch.items()} outputs = model(**batch) loss = outputs.loss - loss.backward() + accelerator.backward(loss) optimizer.step() lr_scheduler.step() optimizer.zero_grad() progress_bar.update(1) \",\"🤗 Accelerate 会帮你处理设备的问题，所以你可以删除 device 那段代码（你也可以使用 accelerator.device 来代替 device）。\",\"提示\",\"为了充分利用集群 TPU 的加速，建议把所有的数据填充到固定的长度（配置 tokenizer 的 padding=\\\"max_length\\\"）。\",\"如果你要复制粘贴分布式训练的代码，请看这里\",\"from accelerate import Accelerator from transformers import AdamW, AutoModelForSequenceClassification, get_scheduler accelerator = Accelerator() model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=2) optimizer = AdamW(model.parameters(), lr=3e-5) train_dl, eval_dl, model, optimizer = accelerator.prepare( train_dataloader, eval_dataloader, model, optimizer ) num_epochs = 3 num_training_steps = num_epochs * len(train_dl) lr_scheduler = get_scheduler( \\\"linear\\\", optimizer=optimizer, num_warmup_steps=0, num_training_steps=num_training_steps, ) progress_bar = tqdm(range(num_training_steps)) model.train() for epoch in range(num_epochs): for batch in train_dl: outputs = model(**batch) loss = outputs.loss accelerator.backward(loss) optimizer.step() lr_scheduler.step() optimizer.zero_grad() progress_bar.update(1) \",\"将代码存到 train.py 中，该脚本可以在任何分布式设备上运行。\",\"accelerate config \",\"回答弹出的问题，然后它会将你的答案写入配置文件中。然后你可以使用下面的命令使用该配置文件启动分布式训练。\",\"accelerate launch train.py \",\"如果你想在 Notebook 中尝试，你把代码贴到函数下面（比如 training_function() ），然后在 cell 中执行：\",\"from accelerate import notebook_launcher notebook_launcher(training_function) \",\"更多示例\",\"你可以在 🤗 Accelerate repo 中查看更多示例。\"]},\"203\":{\"h\":\"总结\",\"t\":[\"在前两章中你了解了 model 和 tokenizer，现在你学会了如何微调。回顾本章：\",\"在 Hub 中查看并下载 datasets\",\"学会了如何加载、预处理数据集，包括动态填充和 collator\",\"实现微调以及评估\",\"较底层实现 training loop\",\"使用 🤗 Accelerate 以在 GPU 集群或 TPU 集群上进行训练\"]},\"204\":{\"h\":\"4. 共享 Models 和 Tokenizers\",\"t\":[\"Hugging Face Hub 是主网站，我们可以在里面找到各种最新的模型和数据集，也可以上传自己的模型和数据集。\",\"其中的模型不局限于 🤗 Transformers 或者 NLP。你可以自己去探索。\",\"模型都用 Git 进行托管，允许版本控制和重现。另外，在 Hub 上共享模型会自动为该模型部署托管的推理 API。\"]},\"205\":{\"h\":\"1. 使用预训练模型\",\"t\":[\"如我们要使用 camembert-base checkpoints.\",\"提示\",\"使用预训练模型时，可以在 model card 中查看它是如何训练的，在哪些数据集上训练的，局限性和 bias 。\"]},\"206\":{\"h\":\"2. 共享预训练模型\",\"t\":[\"创建模型仓库的三种方法：\",\"使用 push_to_hub API\",\"使用 huggingface_hub python 库\",\"在 web 页面上创建\",\"创建好仓库后，就可以通过 git 或者 git-lfs 上传文件了。\"]},\"207\":{\"h\":\"2.1 创建模型仓库\"},\"208\":{\"h\":\"2.1.1 使用 push_to_hub API\",\"t\":[\"你需要身份令牌一遍 huggingface_hub 知道你的权限。\",\"如果你使用 Trainer API 训练模型，将模型上传至 Hub 最简单的方式就是在定义 TrainerArguments 时配置 push_to_hub=True\",\"from transformers import TrainerArguments training_args = TrainerArguments( \\\"bert-finetuned-mrpc\\\", save_strategy=\\\"epoch\\\", push_to_hub=True ) \",\"当你调用 trainer.train() 时，Trainer 会在每次保存 model 时（按照上面的配置，是每个 epoch）将你的 model 上传到 Hub 中对应的仓库上。仓库名称为你选择的输出路径（如上面的 bert-finetuned-mrpc），你也可以用 hub_model_id=\\\"a_different_name\\\" 来设置不同的名称。如果要将 model 上传到你所在的组织下，你可以使用 hub_model_id=\\\"my_organization/mu_repo_name\\\"。\",\"训练结束后，使用 trainer.push_to_hub() 上传最后一版 model。它会生成 model card。\",\"在较低层的实现中，我们可以直接通过 models、tokenizers、configuration 对象的 push_to_hub() 方法来访问 Model Hub。这种方式既可以创建仓库，又能将 model 和 tokenizer 文件直接推到仓库中。\",\"首先创建 model 和 tokenizer。\",\"from transformers import AutoModelForMaskedLM, AutoTokenizer checkpoint = \\\"camembert-base\\\" model = AutoModelForMaskedLM.from_pretrained(checkpoint) tokenizer = AutoTokenizer.from_pretrained(checkpoint) \",\"你可以训练模型、对模型进行微调、向 tokenizer 中增加 tokens。做完你想做的事情时候，你可以使用 push_to_hub() 将 model 推到仓库中\",\"model.push_to_hub(\\\"dummy-model\\\") \",\"这将会创建名为 dummy-model 的仓库，其中会填上你的 model 文件。\",\"同样，对 tokenizer 也可做同样的操作。现在你的仓库中有了全部所需的文件。\",\"tokenizer.push_to_hub(\\\"dummy-model\\\") \",\"如果你想将仓库放到组织下：\",\"tokenizer.push_to_hub(\\\"dummy-model\\\", organization=\\\"huggingface\\\") \",\"如果你想使用某个特定的 Hugging Face token：\",\"tokenizer.push_to_hub(\\\"dummy-model\\\", organization=\\\"huggingface\\\", use_auth_token=\\\"<TOKEN>\\\") \"]},\"209\":{\"h\":\"2.1.2 使用 huggingface_hub python 库\",\"t\":[\"你需要使用 CLI 的登录命令\",\"huggingface-cli login \",\"huggingface_hub 库提供了很多方法和类。下面是和仓库创建、删除等有关的方法\",\"from huggingface_hub import ( # User management login, logout, whoami, # Repository creation and management create_repo, delete_repo, update_repo_visibility, # And some methods to retrieve/change information about the content list_models, list_datasets, list_metrics, list_repo_files, upload_file, delete_file, ) \",\"# 创建仓库 from huggingface_hub import create_repo create_repo(\\\"dummy-model\\\") # 可以指定 organization # create_repo(\\\"dummy-model\\\", organization=\\\"huggingface\\\") \",\"除了可以指定 organization，还有一些参数：\",\"private: 是否对其他人可见\",\"token: 是否想用给定的 token 覆盖缓存中的 token\",\"repo_type: 是都要创建 dataset 或 space（而非创建 model）。接受的值可以是 “dataset” 或 “space”\"]},\"210\":{\"h\":\"2.1.3 使用 web 页面\",\"t\":[\"这里不展开介绍，按照页面提示进行即可。\"]},\"211\":{\"h\":\"2.2 上传 model files\",\"t\":[\"Hugging Face Hub 的文件管理系统基于 git（对于 regular files）和 git-lfs（对于大文件，large file storage）。\",\"下面我们将介绍三种上传文件到 Hub 的方法。\"]},\"212\":{\"h\":\"2.3.1 upload_file 方法\",\"t\":[\"使用 upload_file() 不需要 git 或 git-lfs，它使用 http post 请求将文件直接传到 🤗 Hub。但是它没有办法处理 5GB 以上的文件。\",\"from huggingface_hub import upload_file upload_file( \\\"<path_to_file>/config.json\\\", path_in_repo=\\\"config.json\\\", repo_id=\\\"<namespace>/dummy-model\\\", ) \",\"还有一些其他的参数：\",\"token\",\"repo_type\"]},\"213\":{\"h\":\"2.3.2 Repository 类\",\"t\":[\"Repository 类以于 git 的方式管理本地仓库。使用该类需要安装 git 和 git-lfs\",\"安装 git-lfs\",\"参考 Git Large File Storage\",\":::\",\"我们使用刚刚建好的仓库。首先我们克隆远端仓库：\",\"from huggingface_hub import Repository repo = Repository(\\\"<path_to_dummy_folder>\\\", clone_from=\\\"<namespace>/dummy-model\\\") \",\"这将在本地创建文件夹<path_to_dummy_folder>。该文件夹中包含 .gitattributes 文件。\",\"我们还会使用一些传统的 git 方法，参考文档：\",\"repo.git_pull() repo.git_add() repo.git_commit() repo.git_push() repo.git_tag() \",\"现在我们有想要推到 Hub 上的 model 和 tokenizer，并成功 clone 了仓库。\",\"首先，确保我们本地 clone 的版本是最新的：\",\"repo.git_pull() \",\"然后我们就可以保存 model 和 tokenizer files 了：\",\"model.save_pretrained(\\\"<path_to_dummy_folder>\\\") tokenizer.save_pretrained(\\\"<path_to_dummy_folder>\\\") \",\"目前，<path_to_dummy_folder> 中包含了全部的 model 和 tokenizer files。接下来可以使用传统的 git 工作流将他们推到远端 hub：\",\"repo.git_add() repo.git_commit(\\\"Add model and tokenizer files\\\") repo.git_push() \"]},\"214\":{\"h\":\"2.3.3 git-based 方法\",\"t\":[\"直接使用 git 和 git-lfs 来上传文件。请确保安装了 git 和 git-lfs。\",\"首先，初始化 git-lfs\",\"git lfs install \",\"接下来，第一步是克隆 model 仓库：\",\"git clone https://huggingface.co/<namespace>/<your-model-id> \",\"例如，我的 username 是 hanzhuo，使用的 model name 是 dummy-model\",\"git clone https://huggingface.co/hanzhuo/dummy-model \",\"现在我的工作路径中有一个 dummy-model 文件夹，\",\"cd dummy-model && ls \",\"可以使用 git 来添加小文件，对于大文件，需要使用 git-lfs。\",\"回顾一下之前获得 model 和 tokenizer 的方式：\",\"from transformers import AutoModelForMaskedLM, AutoTokenizer checkpoint = \\\"camembert-base\\\" model = AutoModelForMaskedLM.from_pretrained(checkpoint) tokenizer = AutoTokenizer.from_pretrained(checkpoint) # Do whatever with the model, train it, fine-tune it... model.save_pretrained(\\\"<path_to_dummy_folder>\\\") tokenizer.save_pretrained(\\\"<path_to_dummy_folder>\\\") \",\"我们看一下 dummy-model 下的文件目录：\",\"config.json pytorch_model.bin README.md sentencepiece.bpe.model special_tokens_map.json tokenizer_config.json tokenizer.json \",\"如果使用 ls -lh 命令，可以发现 pytorch_model.bin 的大小超过了 400MB。\",\"接下来使用常规的 git 命令：\",\"git add . git status \",\"On branch main Your branch is up to date with 'origin/main'. Changes to be committed: (use \\\"git restore --staged <file>...\\\" to unstage) modified: .gitattributes new file: config.json new file: pytorch_model.bin new file: sentencepiece.bpe.model new file: special_tokens_map.json new file: tokenizer.json new file: tokenizer_config.json \",\"再看一下 git-lfs ：\",\"git lfs status \",\"On branch main Objects to be pushed to origin/main: Objects to be committed: config.json (Git: bc20ff2) pytorch_model.bin (LFS: 35686c2) sentencepiece.bpe.model (LFS: 988bc5a) special_tokens_map.json (Git: cb23931) tokenizer.json (Git: 851ff3e) tokenizer_config.json (Git: f0f7783) Objects not staged for commit: \",\"可以观察到 pytorch_model.bin 和 sentencepiece.bpe.model 使用的 LFS，其余的都是 Git。\",\"最后，commit 并 push\",\"git commit -m \\\"First model version\\\" git push \"]},\"215\":{\"h\":\"3. 建立 model card\",\"t\":[\"建立 model card 是通过 README.md 来完成的。为了理解 model card 的重要作用，你可以阅读 Model Cards for Model Reporting。\",\"model card 通常开篇为简短的概述说明其用途，然后是以下几部分：\",\"Model description 描述\",\"Intended uses & limitations 预期用途和限制\",\"How to use 如何使用\",\"Limitations and bias 局限性和偏见\",\"Training data 训练数据\",\"Training procedure 训练过程\",\"Variable & metrics 评估指标\",\"Evaluation results 评估结果\"]},\"216\":{\"h\":\"Model card metadata\",\"t\":[\"在 Hugging Face Hub 中，有的 model 属于特定的类型，你可以通过 tasks, languages, libraries 等等来筛选。\",\"请查看 camembert-base model card，你能看到在 model card header 中有如下信息：\",\"--- language: fr license: mit datasets: - oscar --- \",\"具体配置可查看 full model card specification。\"]},\"217\":{\"h\":\"5. 🤗 Datasets 库\",\"t\":[\"在第三章中我们初步体验了 🤗 Datasets 库，了解 fine-tune 的基本步骤：\",\"从 Hugging Face Hub 上加载数据集\",\"使用 Dataset.map() 预处理数据\",\"加载并计算 metrics\",\"在本章内容中，我们将深入了解 🤗 Datasets 库，你将能够回答以下问题：\",\"数据集不在 hub 上应该怎么做\",\"如何对数据集进行切片（如果你确实需要使用 Pandas 怎么办）\",\"如果你的数据集很大，会撑爆你的 RAM 应该怎么办\",\"Memory Mapping、Apache Arrow 是什么\",\"如何创建自己的数据集并将其推至 Hub\"]},\"218\":{\"h\":\"1. 处理不在 Hugging Face Hub 上的数据集\",\"t\":[\"🤗 Datasets 提供了加载本地和远程数据集的方法，支持下列格式：\",\"Data format\",\"Loading script\",\"Example\",\"CSV & TSV\",\"csv\",\"load_dataset(\\\"csv\\\", data_files=\\\"my_file.csv\\\")\",\"Text files\",\"text\",\"load_dataset(\\\"text\\\", data_files=\\\"my_file.txt\\\")\",\"JSON & JSON Lines\",\"json\",\"load_dataset(\\\"json\\\", data_files=\\\"my_file.jsonl\\\")\",\"Pickled DataFrames\",\"pandas\",\"load_dataset(\\\"pandas\\\", data_files=\\\"my_dataframe.pkl\\\")\"]},\"219\":{\"h\":\"1.1 加载本地数据集\",\"t\":[\"我们使用 SQuAD-it dataset，它是大规模意大利语问答数据集。\",\"Ubuntu 下载并解压\",\"!wget https://github.com/crux82/squad-it/raw/master/SQuAD_it-train.json.gz !wget https://github.com/crux82/squad-it/raw/master/SQuAD_it-test.json.gz !gzip -dkv SQuAD_it-*.json.gz \",\"from datasets import load_dataset squad_it_dataset = load_dataset(\\\"json\\\", data_files=\\\"SQuAD_it-train.json\\\", field=\\\"data\\\") squad_it_dataset \",\"DatasetDict({ train: Dataset({ features: ['paragraphs', 'title'], num_rows: 442 }) }) \",\"加载本地文件会创建一个带有 train 的 DatasetDict 对象。我们可以通过下标查看几个示例如：squad_it_dataset[\\\"train\\\"][0]。\",\"如何获得同时有 train 和 test 的 DatasetDict 对象呢？\",\"data_files = {\\\"train\\\": \\\"SQuAD_it-train.json\\\", \\\"test\\\": \\\"SQuAD_it-test.json\\\"} squad_it_dataset = load_dataset(\\\"json\\\", data_files=data_files, field=\\\"data\\\") squad_it_dataset \",\"DatasetDict({ train: Dataset({ features: ['paragraphs', 'title'], num_rows: 442 }) test: Dataset({ features: ['paragraphs', 'title'], num_rows: 48 }) }) \",\"提示\",\"data_files 参数很灵活，可以是单个文件路径、文件路径 list、映射名称路径的字典，还可以使用 Unix shell 的匹配规则选择多有满足规则的文件（如 data_files=\\\"*.json\\\" 匹配所有的 json 文件）。\",\"🤗 Datasets 的 loading script 支持自动解压，所以我们可以跳过自己解压的过程，直接使用下面的代码加载数据：\",\"data_files = {\\\"train\\\": \\\"SQuAD_it-train.json.gz\\\", \\\"test\\\": \\\"SQuAD_it-test.json.gz\\\"} squad_it_dataset = load_dataset(\\\"json\\\", data_files=data_files, field=\\\"data\\\") \"]},\"220\":{\"h\":\"1.2 加载远程数据集\",\"t\":[\"将 data_files 设置为 url 即可。\",\"url = \\\"https://github.com/crux82/squad-it/raw/master/\\\" data_files = { \\\"train\\\": url + \\\"SQuAD_it-train.json.gz\\\", \\\"test\\\": url + \\\"SQuAD_it-test.json.gz\\\", } squad_it_dataset = load_dataset(\\\"json\\\", data_files=data_files, field=\\\"data\\\") \"]},\"221\":{\"h\":\"2. 切片\"},\"222\":{\"h\":\"2.1 Slicing and dicing 数据\",\"t\":[\"和 Pandas 类似，🤗 Datasets 也提供了一些函数处理 Dataset 和 DatasetDict 对象。在第三章中我们介绍了 Dataset.map()，本章我们将介绍其他函数。\",\"接下来我们使用的数据集为 Drug Review Dataset。\",\"TSV 是 CSV 的变体，它和 CSV 的区别在于 CSV 用逗号作为分割符，而 TSV 使用制表符作为分隔符。所以我们可以使用 csv 加载的方式并指定 delimiter。\",\"from datasets import load_dataset data_files = {\\\"train\\\": \\\"drugLibTrain_raw.tsv\\\", \\\"test\\\": \\\"drugLibTest_raw.tsv\\\"} drug_dataset = load_dataset(\\\"csv\\\", data_files=data_files, delimiter=\\\"\\\\t\\\") \",\"我们可以抽取一些样本来观察，以对数据有一个直观的认识。可以使用 Dataset.shuffle() 和 Dataset.select() 来随机抽取样本。\",\"drug_sample = drug_dataset[\\\"train\\\"].shuffle().select(range(1000)) # 选取前面几个样本 drug_sample[:3] \",\"运行结果\",\"{'Unnamed: 0': [1468, 3422, 1444], 'urlDrugName': ['cymbalta', 'tazorac', 'tirosint'], 'rating': [9, 5, 4], 'effectiveness': ['Highly Effective', 'Moderately Effective', 'Moderately Effective'], 'sideEffects': ['No Side Effects', 'Severe Side Effects', 'Moderate Side Effects'], 'condition': ['sever depression', 'acne', 'thyroid/total thyroidectomy due to cancer'], 'benefitsReview': [\\\"This medication saved my life. The depression had gotten so sever that I was unable to function properly. It has made me feel like a 'real' person again. It has not done much for the anxiety, panic, or OCD. The Xanax helps with that area. I will be going to the psychiatrist in 2 weeks for the anxiety, panic, and OCD. Hoping to stay on the Cymbalta. I was on Lexapro 30mg from 2000-2006. Then switched to Celexa (cost reasons) 60mg from 2007-2008. The Celexa just about costed me my life. It was ineffective for the Depression. Try not to take Celexa for cost reasons, Lexapro shows much more promise in its effectiveness.\\\", 'It exfoliated my skin.', 'I started taking Tirosint 125mcg 6 weeks ago due to a gluten and caseine allergy. I previously was taking synthroid however, the company couldnt verify the inactive ingredients. So to avoid gluten, caseine, and some really nasty anxiety symptms I switched to the Tirosint. \\\\r\\\\r\\\\n\\\\r\\\\r\\\\nThe anxiety symptoms subsided from 1 attack per day to none. This was great!, but then new symptoms started after three weeks.'], 'sideEffectsReview': ['Weight gain, which is to be expected when you \\\"feel better\\\"', 'My skin became extremely dry, irritated, red, and would peel.', 'I felt dperessed, tired and very sore. My finger joints hurt so bad and to the touch. My back, and legs ached. Then my lower legs, ankles and feet started to swell. it is so bad that I cannot walk upon waking in the morning. If Im on my feet for more than an hour I have to elevate my legs due to the pain and swelling. I also gained alot of weight 8lbs. I\\\\'m a healthy 37 year old woman, I am active with two small boys, and eat an extremley healthy diet due to my Celiacs and Caseine allergies. \\\\r\\\\r\\\\n\\\\r\\\\r\\\\nI recently had my blood levels checked and to my surprise I was taking way too much Tirosint. My Endo said that the swelling and pain wasnt from the Tirosint and that I should see my Primary doctor...REALLY?? I was shocked due to my \\\"hypo\\\" symptoms. Im thinking of returning to Synthroid and switching doctors...'], 'commentsReview': ['Depression and Anxiety', 'Use once daily, at night. Wash face, use toner and leave to dry (10 minutes). Then apply pea size amount of cream all over face, excluding eye area. Let soak in (15 minutes), then layer with moisturizer. Must wear sunscreen daily.', '125 mcg Tirosint per day and doubled on Sat and Sun. \\\\r\\\\r\\\\n\\\\r\\\\r\\\\nListen to your body and be persistent with your doctors.']} \",\"Dataset.select() 需要传入一个可迭代的索引，这里我们传入了 range(1000) 从随机打乱的数据集中选取前 1000 个样本。我们可以看出数据集的一些特点了：\",\"Unnamed: 0: 可能是患者的 ID\",\"condition: 描述健康状况的标签，有大写有小写\",\"各类 review: 长短不一，混有 Python 行分隔符（\\\\r\\\\n）、html 字符编码（见 🤗 官方示例，如&#039;）\",\"下面我们验证一下 Unnamed 0 是患者 ID 的猜想，这里会用到 Dataset.unique()：\",\"for split in drug_dataset.keys(): assert len(drug_dataset[split]) == len(drug_dataset[split].unique(\\\"Unnamed: 0\\\")) \",\"上面的代码没抛出 AssertionError，看来是患者 ID 的这个想法是正确的。我们将该列重命名为 patient_id，这里会用到 DatasetDict.rename_column():\",\"drug_dataset = drug_dataset.rename_column( original_column_name=\\\"Unnamed: 0\\\", new_column_name=\\\"patient_id\\\" ) \",\"我们使用 Dataset.map() 标准化所有的 condition：\",\"def lowercase_condition(example): return {\\\"condition\\\": example[\\\"condition\\\"].lower()} drug_dataset.map(lowercase_condition) \",\"AttributeError: 'NoneType' object has no attribute 'lower' \",\"看来我们还需要把 condition 为 None 的数据过滤掉（使用 Dataset.filter()）：\",\"drug_dataset = drug_dataset.filter(lambda x: x[\\\"condition\\\"] is not None) \"]},\"223\":{\"h\":\"2.2 创建新列\",\"t\":[\"在处理 review 字段时，最好是要统计一下字数。我们就简单基于空格来进行词数统计。\",\"def compute_review_length(example): return {\\\"benefit_review_length\\\": len(example[\\\"benefitsReview\\\"].split())} drug_dataset = drug_dataset.map(compute_review_length) \",\"这样，我们就增加了 benefit_review_length 列。我们还可以使用 Dataset.sort() 以该列为基准做排序\",\"drug_datasets[\\\"train\\\"].sort(\\\"benefit_review_length\\\") \",\"`Dataset.add_column()`\",\"我们还可以使用 Dataset.add_column() 增加列。可以传入 Python list 或 numpy。\",\"review 的词数较少时（极端情况比如只有一个词）对于预测没有提供相对有用的信息。下面我将使用 Dataset.filter() 将少于 30 个词的 review 去掉。\",\"drug_dataset = drug_dataset.filter(lambda x: x[\\\"benefit_review_length\\\"] > 30) print(drug_dataset.num_rows) \",\"{'train': 1445, 'test': 473} \",\"review 中还有一些 html 编码，可以使用 Python 的 html module 来解码：\",\"import html text = \\\"I&#039;m a transformer called BERT\\\" html.unescape(text) \",\"\\\"I'm a transformer called BERT\\\" \",\"drug_dataset = drug_dataset.map(lambda x: { \\\"benefitsReview\\\": html.unescape(x[\\\"benefitsReview\\\"])}) \"]},\"224\":{\"h\":\"2.3 map() 方法\",\"t\":[\"Dataset.map() 有一个参数是 batched。将其设为 True 后，map 函数将一次处理多个数据（成为一批 a batch），batch size 可以配置，默认情况下为 1000.\"]},\"225\":{\"h\":\"第二层到第三层\"},\"226\":{\"h\":\"1. 物理层 & MAC 层\"},\"227\":{\"h\":\"1.1 第一层（物理层）\",\"t\":[\"设备：集线器（Hub），广播\"]},\"228\":{\"h\":\"1.2 第二层（数据链路层）\"},\"229\":{\"h\":\"MAC（Medium Access Control，媒体访问控制）\",\"t\":[\"解决的是谁先发谁后发的问题，学名是多路访问。有很多算法解决这个问题： \",\"信道划分：分多个道，你走你的，我走我的\",\"轮流协议：轮着来\",\"随机接入协议（以太网就用的这种方式）：管他三七二十一，先出门，堵的话就回去\",\"判断发给谁，谁接收 \",\"链路层地址，也被称为 MAC 地址\",\"第二层的网络包格式：\",\"目标 MAC（6 bytes）\",\"源 MAC（6 bytes）\",\"类型（2 bytes）\",\"数据（46-1500 bytes）\",\"CRC（4 bytes）\",\"类型：0800 - IP 数据报，0860 - ARP 请求\",\"CRC 循环冗余检测：通过 XOR 异或来计算整个包是否在发送的过程中出现了了错误\"]},\"230\":{\"h\":\"ARP 协议\",\"t\":[\"问题：如果一个广播网络里面接入了 N 台机器，怎么知道每台机器的 MAC 地址呢？\",\"答案：ARP 协议 - 根据 IP 地址找 MAC 地址的协议。这是一个输出全靠“吼”的阶段。\",\"目标 MAC（6 bytes）\",\"源 MAC（6 bytes）\",\"类型（2 bytes）\",\"ARP 报文\",\"过程：要发送数据的机器发送一个广播包，等目的 IP 对应的机器来回应自己。\",\"ARP 报文格式：\",\"硬件类型（Ethernet）\",\"协议类型（IP）\",\"硬件地址长度（6）\",\"协议地址长度（6）\",\"操作代码（1 request 2 reply）\",\"发送者 MAC\",\"发送者 IP\",\"目标 MAC\",\"目标 IP\",\"ARP 缓存：为了避免每次都用 ARP 请求，机器本地也会进行 ARP 缓存。由于机器会不断上线下线，IP 也可能会变，所以 ARP 的 MAC 地址缓存过一段时间就会过期。\"]},\"231\":{\"h\":\"转发表\",\"t\":[\"机器数少的时候，我们可以用集线器组网。集线器是广播的，每个端口不管是否需要该包，都会接收然后发给主机，然后让主机自己判断是否需要。当机器数多的时候，端口什么都接受什么都转发的话，会更容易产生冲突，而且把不需要的包转发出去纯属浪费。\",\"我们需要稍微智能一点的设备，该设备每个口可以解析 MAC 头，检查下目标 MAC 地址，然后根据策略进行转发。即第二层设备：交换机。\",\"交换机如何知道每个口的电脑的 MAC 地址呢？需要交换机会学习，学习的结果叫做转发表。\",\"电脑 A 向电脑 B 发送一个包，当包到达交换机时，最开始交换机并不知道电脑 B 在哪个口，于是它只能将包发送给除了连接电脑 A 口以外的其他口。交换机聪明之处在于，它会记住，电脑 A（对应的MAC）在哪个口。以后遇到目的地址是电脑 A 的 MAC 地址时，直接发送到对应的口就行。\",\"这样过了一段时间之后，交换机就有了整个网络的结构了，这时基本不用广播了，可以准确转发。\"]},\"232\":{\"h\":\"1.3 交换机与 VLAN\",\"t\":[\"下图是两台交换机连接三个局域网的情况。\",\"当机器 1 向机器 4（已知其 IP）发送包的时候，目的 MAC 还不知道，所以需要先用 ARP 获取目的 MAC。\",\"简述交换机学习网络拓扑信息的过程\",\"现在两台交换机都不了解网络的任何拓扑信息。\",\"机器 1 发起广播。机器 2 能收到，但是没它啥事。交换机 A 也收到了这个广播，此时它不知道网络的拓扑信息，于是它将该广播包转发给除了广播包来的方向之外的其他所有网口。\",\"机器 3 也收到了信息，但是这和它也没啥关系。交换机 B 同样收到了该广播包，它也不知道网络的拓扑信息，于是它也按照广播策略将包转发到 LAN 3。此时，机器 4 和机器 5 都能收到广播信息。机器 4 主动响应，这是找我的，我的 MAC 是 blabla。于是一个 ARP 请求就完成了。\",\"在上面的过程中，两台交换机都学到了这样的信息：机器 1 是在左边的网口。\",\"下次当机器 2 要访问机器 1 时，先通过 ARP 获取机器 1 的 MAC 地址。知道目的 MAC 后，发送数据包。该消息会到达机器 1，也会到交换机 A。交换机已经知道了机器 1 不在右边的网口，于是这个广播信息不会广播到 LAN 2 和 LAN 3。\"]},\"233\":{\"h\":\"环路问题 & STP 协议\",\"t\":[\"环路问题会导致 ARP 请求爆炸，且交换机无法学习到网络的拓扑结构。\",\"数据结构中有最小生成树，有环的我们常称为图。将图中的环破坏了，就生成了树。计算机网络中生成树算法是STP（Spanning Tree Protocol）。\",\"STP 中的概念：\",\"Root Bridge，根交换机\",\"Designated Bridge，指定交换机\",\"Bridge Protocol Data Unit，BPDU，网桥协议数据单元。“互相比较实例”的协议。只有 Root Bridge 可以发，其他交换机只能转。\",\"Priority Vector，优先级向量。[Root Bridge ID, Root Path Cost, Bridge ID, Port ID]。在 BPDU 中。\"]},\"234\":{\"h\":\"广播问题 & 安全问题\",\"t\":[\"物理隔离：使用单独的交换机配置单独的子网\",\"虚拟隔离，虚拟局域网（VLAN）：一个交换机上会连属于多个局域网的机器。\",\"交换机如何区别某个机器属于哪个局域网呢？在原来的二层的头上加一个 TAG，里面有一个 VLAN ID，一共12位（可以划分 4096 个 VLAN）。这样仍然不够，目前云计算厂商例绝对不止 4096 个用户。当然每个用户需要一个 VLAN，后面章节再讲这个问题。\",\"如果我们使用的交换机是支持 VLAN 的，当交换机把二层的头取下来时就可以识别 VLAN ID。这样，只有相同 VLAN 的包才会互相转发，不同 VLAN 的包是看不到的。\",\"对于支持 VLAN 的交换机，有一种口叫 Trunk 口。它可以转发属于任何 VLAN 的数据，交换机之间可以通过这种口互相连接。\"]},\"235\":{\"h\":\"类型\"},\"236\":{\"h\":\"七种类型\",\"t\":[\"Undefined\",\"Null\",\"Boolean\",\"String\",\"Number\",\"Symbol\",\"Object\"]},\"237\":{\"h\":\"1. Undefined、Null\",\"t\":[\"Q：为什么有的编程规范要求用 void 0 代替 undefined？A：局部变量中的 undefined 可以修改（ES5 之后全局变量下的 undefined 只读），为了避免它在无意中被修改，建议使用 void 0 来获取 undefined 值。\"]},\"238\":{\"h\":\"2. String\",\"t\":[\"Q：字符串是否有最大长度？A：String 的最大长度是 253−1\",\"String并非“字符串”，而是是字符串的 UTF16 编码，对 String 的各种操作如 charAt、charCodeAt、length 等，针对的都是 UTF-16 编码，每个 UTF-16 单元被认为是 1 个字符（处理 SP 平面的字符时要注意，SP 上的每个字符对应 4 字节）。所以字符串的最大长度实际上是受字符串的编码长度影响的。\",\"JavaScrip 中的 String 永远无法变更，即字符串具有值类型的特征。\"]},\"239\":{\"h\":\"3. Number\",\"t\":[\"Number 共有 18437736874454810627(即 264−253+3) 个值。\",\"提示\",\"Number 用 64 位表示。\",\"IEEE 754 标准： s（符号位，1）+ e（指数位，11）+ f（尾数，52）\",\"e 全 1 时的特殊值减掉（即 64 - 11 = 53），+3 是指三个特殊值：NaN、Infinity、-Infinity\",\"NaN：e 全 1，f 非 0\",\"Infinity：e 全 1，f = 0，正无穷（S 为 0），负无穷（S 为 1）\",\"JavaScript 中的 Number 类型基本符合 IEEE 754-2008 规定的双精度浮点数规则，但是 JavaScript 为了表达几个额外的语言场景（比如不让除以 0 出错，而引入了无穷大的概念），规定了几个例外情况：\",\"NaN，占用了 9007199254740990，这原本是符合 IEEE 规则的数字\",\"Infinity，无穷大\",\"Infinity，负无穷大\",\"JavaScript 中有 +0 和 -0，区分他们的方法是检验 1/x 是 Infinity 还是 -Infinity\",\"整数范围：-0x1f ffff ffff ffff 至 0x1f ffff ffff ffff\",\"浮点数精度问题：0.1 + 0.2 != 0.3\",\"正确的比较方法应该是使用 JavaScript 提供的最小精度：\",\"Math.abs(0.1 + 0.2 - 0.3) <= Number.EPSILON // true \"]},\"240\":{\"h\":\"4. Symbol\",\"t\":[\"对象的 key 只能是 String 类型或 Symbol 类型。使用字符串做 key 容易造成属性名的冲突，ES 6 引入 Symbol 正是为了防止属性名冲突的。\",\"即使 description 相同，Symbol 也是不同的。\",\"使用 JavaScript 内置的 Symbol.* 修改对象的内建行为。\"]},\"241\":{\"h\":\"5. Object\",\"t\":[\"对于 JavaScript 中的几个基本类型，都在对象类型中有所对应，分别是\",\"Number\",\"String\",\"Boolean\",\"Symbol\",\"要注意，new Number(3) 和数字 3 是不同的类型，前者是对象类型，后者是 Number 类型\",\"new Number(3) == 3; // true new Number(3) === 3; // false \",\"Number、String、Boolean 当跟 new 搭配时，是对应类型的构造器，会产生对象；直接调用表示强制类型转换。\",\"Symbol 是 Symbol 对象构造器，但是用 new 调用会抛出错误。\"]},\"242\":{\"h\":\"6. 类型转换\",\"t\":[\"== 运算会进行跨类型的比较，规则复杂。一般被认为是设计失误，很多实践中推荐禁止使用 ==，而是要求进行显示转换后用 === 进行比较。\"]},\"243\":{\"h\":\"6.1 StringToNumber: Number(str)\",\"t\":[\"数字（十进制、二进制、八进制、十六进制 & 科学计数法 E 或 e）：\",\"30\",\"0b111\",\"0c13\",\"0xFF\",\"1e3\",\"-1e-2\",\"使用 `Number()` 而非 `parseInt()`、`parseFloat`\",\"parseInt 只支持十六进制前缀“0x”，忽略非数字字符，不支持科学计数法 \",\"在比较旧的浏览器中，parseInt 还支持 0 开头的八进制前缀，这会造成错误。所以不论何时，都建议传入 parseInt 的第二个参数\",\"parseFloat 直接把字符串作为十进制进行解析，不能处理其他任何进制\"]},\"244\":{\"h\":\"6.2 NumberToString: String(num)\",\"t\":[\"在较小范围内，数字转字符串完全符合你的直觉\",\"在 Number 的绝对值较大或较小时，字符串表示是用科学计数法\",\"let p = 10000000000000000 console.log(String(p)); // 10000000000000000 console.log(String(p)); // 1e+25 \"]},\"245\":{\"h\":\"6.3 Object to primitive conversion 对象->基本类型的转换（拆箱转换）\",\"t\":[\"布尔转换：没有对应的转换。所有的对象都是 true。\",\"数值转换：当进行数学运算时进行数值转换。例如，Date 对象可以相减。\",\"字符串转换：一般在输出的时候进行。比如 alert(obj)、console.log(obj) 等。\",\"我们可以使用特殊的对象方法来实现字符串和数值转换。\",\"ToFdo\"]},\"246\":{\"h\":\"6.4 基本类型->对象的转换（装箱转换）\",\"t\":[\"Todo\"]},\"247\":{\"h\":\"Post\"},\"248\":{\"h\":\"Ai\"},\"249\":{\"h\":\"Character Encoding\"},\"250\":{\"h\":\"Basic\"},\"251\":{\"h\":\"Code\"},\"252\":{\"h\":\"Section1\"},\"253\":{\"h\":\"Section2\"},\"254\":{\"h\":\"Section1\"},\"255\":{\"h\":\"Javascript\"},\"256\":{\"h\":\"Front End\"}},\"dirtCount\":0,\"index\":[[\"装箱转换\",{\"0\":{\"246\":1}}],[\"装好系统之后自动分配\",{\"1\":{\"80\":1}}],[\"布尔转换\",{\"1\":{\"245\":1}}],[\"拆箱转换\",{\"0\":{\"245\":1}}],[\"开头的八进制前缀\",{\"1\":{\"243\":1}}],[\"开始阅读\",{\"1\":{\"187\":1}}],[\"开始执行该文件\",{\"1\":{\"81\":1}}],[\"开始修改\",{\"1\":{\"21\":1}}],[\"科学计数法\",{\"1\":{\"243\":1}}],[\"八进制\",{\"1\":{\"243\":1}}],[\"二进制\",{\"1\":{\"243\":1}}],[\"二级汉字\",{\"1\":{\"59\":1}}],[\"很多实践中推荐禁止使用\",{\"1\":{\"242\":1}}],[\"很适合采用循环链表\",{\"1\":{\"93\":1}}],[\"搭配时\",{\"1\":{\"241\":1}}],[\"修改对象的内建行为\",{\"1\":{\"240\":1}}],[\"浮点数精度问题\",{\"1\":{\"239\":1}}],[\"区分他们的方法是检验\",{\"1\":{\"239\":1}}],[\"区间的元素复制到新的数组中\",{\"1\":{\"21\":1}}],[\"占用了\",{\"1\":{\"239\":1}}],[\"规定了几个例外情况\",{\"1\":{\"239\":1}}],[\"规定的双精度浮点数规则\",{\"1\":{\"239\":1}}],[\"规则复杂\",{\"1\":{\"242\":1}}],[\"规则的数字\",{\"1\":{\"239\":1}}],[\"规则\",{\"0\":{\"46\":1}}],[\"全\",{\"1\":{\"239\":3}}],[\"全局变量\",{\"1\":{\"115\":1}}],[\"全局注册表中的\",{\"1\":{\"7\":1}}],[\"永远无法变更\",{\"1\":{\"238\":1}}],[\"单元被认为是\",{\"1\":{\"238\":1}}],[\"单链表反转\",{\"1\":{\"106\":1}}],[\"单链表需要从头结点开始找\",{\"1\":{\"94\":1}}],[\"单链表\",{\"0\":{\"92\":1},\"1\":{\"91\":1}}],[\"针对的都是\",{\"1\":{\"238\":1}}],[\"针对响应时间比较敏感的系统\",{\"1\":{\"111\":1}}],[\"局部变量中的\",{\"1\":{\"237\":1}}],[\"局限性和偏见\",{\"1\":{\"215\":1}}],[\"局限性和\",{\"1\":{\"205\":1}}],[\"局限性\",{\"0\":{\"145\":1}}],[\"局限在一个子网里\",{\"1\":{\"71\":1}}],[\"七种类型\",{\"0\":{\"236\":1}}],[\"口\",{\"1\":{\"234\":1}}],[\"口以外的其他口\",{\"1\":{\"231\":1}}],[\"虚拟局域网\",{\"1\":{\"234\":1}}],[\"虚拟隔离\",{\"1\":{\"234\":1}}],[\"物理隔离\",{\"1\":{\"234\":1}}],[\"物理层\",{\"0\":{\"226\":1,\"227\":1}}],[\"物理层面的字节序列\",{\"1\":{\"42\":1}}],[\"安全问题\",{\"0\":{\"234\":1}}],[\"安装\",{\"1\":{\"213\":1}}],[\"互相比较实例\",{\"1\":{\"233\":1}}],[\"根交换机\",{\"1\":{\"233\":1}}],[\"根据\",{\"1\":{\"230\":1}}],[\"根据输入文本生成新的句子\",{\"1\":{\"141\":1}}],[\"根据上下文中提供的信息提取问题的答案\",{\"1\":{\"141\":1}}],[\"根据每一位来排序\",{\"1\":{\"131\":1}}],[\"根据要找的值与\",{\"1\":{\"94\":1}}],[\"根据数组计算单个值\",{\"1\":{\"21\":1}}],[\"电脑\",{\"1\":{\"231\":2}}],[\"端口什么都接受什么都转发的话\",{\"1\":{\"231\":1}}],[\"机器\",{\"1\":{\"232\":6}}],[\"机器数少的时候\",{\"1\":{\"231\":1}}],[\"机器本地也会进行\",{\"1\":{\"230\":1}}],[\"机器学习的评价指标\",{\"0\":{\"36\":1}}],[\"操作代码\",{\"1\":{\"230\":1}}],[\"操作系统给每个线程分配了一块独立的内存空间\",{\"1\":{\"136\":1}}],[\"硬件地址长度\",{\"1\":{\"230\":1}}],[\"硬件类型\",{\"1\":{\"230\":1}}],[\"报文格式\",{\"1\":{\"230\":1}}],[\"报文\",{\"1\":{\"230\":1}}],[\"答案\",{\"1\":{\"230\":1}}],[\"怎么知道每台机器的\",{\"1\":{\"230\":1}}],[\"怎么办\",{\"1\":{\"217\":1}}],[\"台机器\",{\"1\":{\"230\":1}}],[\"异或来计算整个包是否在发送的过程中出现了了错误\",{\"1\":{\"229\":1}}],[\"链路层地址\",{\"1\":{\"229\":1}}],[\"链表中环的检测\",{\"1\":{\"106\":1}}],[\"链表只包含两个结点时\",{\"1\":{\"104\":1}}],[\"链表只包含一个结点时\",{\"1\":{\"104\":1}}],[\"链表为空时\",{\"1\":{\"104\":1}}],[\"链表的典型应用场景\",{\"1\":{\"98\":1}}],[\"链表的结构五花八门\",{\"1\":{\"91\":1}}],[\"链表本身没有大小的限制\",{\"1\":{\"96\":1}}],[\"链表\",{\"0\":{\"90\":1,\"96\":1}}],[\"谁接收\",{\"1\":{\"229\":1}}],[\"谁能租给我个\",{\"1\":{\"75\":1}}],[\"堵的话就回去\",{\"1\":{\"229\":1}}],[\"管他三七二十一\",{\"1\":{\"229\":1}}],[\"信道划分\",{\"1\":{\"229\":1}}],[\"信息技术中文编码字符集\",{\"1\":{\"61\":1}}],[\"信息从一种形式转换为另一种形式的过程\",{\"1\":{\"42\":1}}],[\"媒体访问控制\",{\"0\":{\"229\":1}}],[\"集线器是广播的\",{\"1\":{\"231\":1}}],[\"集线器\",{\"1\":{\"227\":1}}],[\"集群上进行训练\",{\"1\":{\"203\":1}}],[\"集群或\",{\"1\":{\"203\":1}}],[\"成为一批\",{\"1\":{\"224\":1}}],[\"成正比\",{\"1\":{\"85\":1}}],[\"极端情况比如只有一个词\",{\"1\":{\"223\":1}}],[\"极端情况下\",{\"1\":{\"129\":1}}],[\"行分隔符\",{\"1\":{\"222\":1}}],[\"混有\",{\"1\":{\"222\":1}}],[\"各类\",{\"1\":{\"222\":1}}],[\"各国对于\",{\"1\":{\"54\":1}}],[\"切片\",{\"0\":{\"221\":1}}],[\"匹配所有的\",{\"1\":{\"219\":1}}],[\"匹配完之后\",{\"1\":{\"138\":1}}],[\"属于特定的类型\",{\"1\":{\"216\":1}}],[\"属性来查看对应的\",{\"1\":{\"160\":1}}],[\"属性的对象\",{\"1\":{\"15\":1,\"17\":1}}],[\"属性的对象叫类数组\",{\"1\":{\"12\":1}}],[\"属性的顺序\",{\"0\":{\"3\":1}}],[\"属性只能是\",{\"1\":{\"2\":1}}],[\"属性名没有这个限制\",{\"1\":{\"2\":1}}],[\"属性\",{\"1\":{\"2\":1,\"6\":2,\"11\":1,\"13\":1,\"21\":1}}],[\"描述健康状况的标签\",{\"1\":{\"222\":1}}],[\"描述\",{\"1\":{\"215\":1}}],[\"建议使用\",{\"1\":{\"237\":1}}],[\"建议把所有的数据填充到固定的长度\",{\"1\":{\"202\":1}}],[\"建立\",{\"0\":{\"215\":1},\"1\":{\"215\":1}}],[\"命令\",{\"1\":{\"214\":2}}],[\"命令加后面的子命令\",{\"1\":{\"71\":1}}],[\"仓库\",{\"1\":{\"214\":1}}],[\"仓库名称为你选择的输出路径\",{\"1\":{\"208\":1}}],[\"工作流将他们推到远端\",{\"1\":{\"213\":1}}],[\"确保我们本地\",{\"1\":{\"213\":1}}],[\"确定是在输入的左侧还是右侧进行\",{\"1\":{\"190\":1}}],[\"确定句子在语法上是否正确或两个句子在逻辑上是否相关\",{\"1\":{\"141\":1}}],[\"确定数据范围\",{\"1\":{\"130\":1}}],[\"页面\",{\"0\":{\"210\":1}}],[\"页面上创建\",{\"1\":{\"206\":1}}],[\"推到仓库中\",{\"1\":{\"208\":1}}],[\"推荐阅读\",{\"1\":{\"153\":1}}],[\"推荐\",{\"1\":{\"150\":1}}],[\"文件路径\",{\"1\":{\"219\":1}}],[\"文件夹\",{\"1\":{\"214\":1}}],[\"文件夹下其他的\",{\"1\":{\"29\":1}}],[\"文件\",{\"1\":{\"208\":1,\"213\":1,\"219\":1}}],[\"文件直接推到仓库中\",{\"1\":{\"208\":1}}],[\"允许版本控制和重现\",{\"1\":{\"204\":1}}],[\"允许负向索引\",{\"1\":{\"21\":1}}],[\"较底层实现\",{\"1\":{\"203\":1}}],[\"学名是多路访问\",{\"1\":{\"229\":1}}],[\"学会了如何加载\",{\"1\":{\"203\":1}}],[\"学习的结果叫做转发表\",{\"1\":{\"231\":1}}],[\"学习率调度器\",{\"0\":{\"199\":1}}],[\"学习记录\",{\"1\":{\"68\":1}}],[\"回顾一下之前获得\",{\"1\":{\"214\":1}}],[\"回顾本章\",{\"1\":{\"203\":1}}],[\"回答弹出的问题\",{\"1\":{\"202\":1}}],[\"累积\",{\"1\":{\"201\":1}}],[\"累加\",{\"1\":{\"130\":1}}],[\"轮着来\",{\"1\":{\"229\":1}}],[\"轮流协议\",{\"1\":{\"229\":1}}],[\"轮\",{\"1\":{\"199\":1}}],[\"乘\",{\"1\":{\"199\":1}}],[\"改为\",{\"1\":{\"195\":1}}],[\"改变原数组\",{\"1\":{\"21\":1}}],[\"准备\",{\"0\":{\"195\":1}}],[\"准确性\",{\"0\":{\"37\":1}}],[\"章介绍这些配置项\",{\"1\":{\"193\":1}}],[\"构建\",{\"1\":{\"193\":1}}],[\"构建的\",{\"1\":{\"169\":1}}],[\"评估结果\",{\"1\":{\"215\":1}}],[\"评估指标\",{\"1\":{\"215\":1}}],[\"评估\",{\"0\":{\"193\":1}}],[\"评估时会直接输出\",{\"1\":{\"192\":1}}],[\"运算会进行跨类型的比较\",{\"1\":{\"242\":1}}],[\"运算符号等\",{\"1\":{\"53\":1}}],[\"运行结果\",{\"1\":{\"222\":1}}],[\"运行上面代码后\",{\"1\":{\"192\":1}}],[\"定义的是一样的\",{\"1\":{\"192\":1}}],[\"定义的字符较\",{\"1\":{\"60\":1}}],[\"定义模型\",{\"1\":{\"192\":1}}],[\"必须提供的唯一参数是训练模型的存储路径\",{\"1\":{\"192\":1}}],[\"必须使用一个原先称之为\",{\"1\":{\"47\":1}}],[\"配置\",{\"1\":{\"202\":1}}],[\"配置运行环境\",{\"1\":{\"191\":1}}],[\"配置中包含很多建立模型要用到的属性\",{\"1\":{\"162\":1}}],[\"去掉\",{\"1\":{\"223\":1}}],[\"去掉了\",{\"1\":{\"190\":1}}],[\"去初始化操作系统\",{\"1\":{\"80\":1}}],[\"默认情况下为\",{\"1\":{\"224\":1}}],[\"默认情况下按照字符串进行排序\",{\"1\":{\"21\":1}}],[\"默认训练\",{\"1\":{\"199\":1}}],[\"默认的\",{\"1\":{\"199\":1}}],[\"默认是一个函数\",{\"1\":{\"190\":1}}],[\"哪一个是第二个句子\",{\"1\":{\"189\":1}}],[\"哪怕牺牲一部分recall\",{\"1\":{\"40\":1}}],[\"哪怕牺牲一部分precision\",{\"1\":{\"40\":1}}],[\"尝试了多种可配置的\",{\"1\":{\"185\":1}}],[\"特殊\",{\"0\":{\"183\":1}}],[\"特征\",{\"1\":{\"150\":1}}],[\"截断序列\",{\"1\":{\"181\":1}}],[\"像\",{\"1\":{\"181\":1}}],[\"换用支持更长序列的模型\",{\"1\":{\"181\":1}}],[\"至此\",{\"1\":{\"196\":1}}],[\"至\",{\"1\":{\"181\":1,\"239\":1}}],[\"长短不一\",{\"1\":{\"222\":1}}],[\"长序列\",{\"0\":{\"181\":1}}],[\"长度非\",{\"1\":{\"34\":1}}],[\"长度为\",{\"1\":{\"34\":1}}],[\"元素只有\",{\"1\":{\"180\":1}}],[\"元素满足\",{\"1\":{\"21\":1}}],[\"忽略非数字字符\",{\"1\":{\"243\":1}}],[\"忽略\",{\"1\":{\"179\":1}}],[\"造成不一致是因为\",{\"1\":{\"179\":1}}],[\"造字码位\",{\"1\":{\"60\":1}}],[\"观察上面的结果\",{\"1\":{\"179\":1}}],[\"观察结果\",{\"1\":{\"145\":1}}],[\"批处理\",{\"0\":{\"178\":1}}],[\"词汇表索引是唯一能够使模型正常工作的输入吗\",{\"1\":{\"177\":1}}],[\"词表将有效地减小\",{\"1\":{\"169\":1}}],[\"处理\",{\"1\":{\"238\":1}}],[\"处理不在\",{\"0\":{\"218\":1}}],[\"处理数据\",{\"0\":{\"187\":1}}],[\"处理多个序列\",{\"0\":{\"177\":1}}],[\"处理头结点\",{\"1\":{\"104\":1}}],[\"方不仅将索引转化为了\",{\"1\":{\"175\":1}}],[\"方法了\",{\"1\":{\"201\":1}}],[\"方法进行预测\",{\"1\":{\"193\":1}}],[\"方法来访问\",{\"1\":{\"208\":1}}],[\"方法来构建数据集\",{\"1\":{\"189\":1}}],[\"方法来实现\",{\"1\":{\"175\":1}}],[\"方法来保存模型\",{\"1\":{\"164\":1}}],[\"方法实现\",{\"1\":{\"173\":1}}],[\"方法上加锁\",{\"1\":{\"110\":1}}],[\"方法不能正确处理\",{\"1\":{\"16\":1}}],[\"方法返回的结果的搁置必须是\",{\"1\":{\"13\":1}}],[\"方法的对象\",{\"1\":{\"13\":1,\"15\":1}}],[\"方法\",{\"0\":{\"212\":1,\"214\":1,\"224\":1},\"1\":{\"5\":1,\"13\":2,\"17\":1,\"157\":1,\"163\":1,\"185\":1,\"192\":1,\"193\":1,\"213\":1}}],[\"过程\",{\"1\":{\"230\":1}}],[\"过程中需要在\",{\"1\":{\"189\":1}}],[\"过程可以使用\",{\"1\":{\"173\":1}}],[\"过多的函数调用会耗时等问题\",{\"1\":{\"117\":1}}],[\"考虑到上面两种技术\",{\"1\":{\"169\":1}}],[\"考虑到一个字节能够表示的编码实际上有\",{\"1\":{\"54\":1}}],[\"产生了大量\",{\"1\":{\"168\":1}}],[\"英语中有\",{\"1\":{\"168\":1}}],[\"英文字母的排列是不连续的\",{\"1\":{\"52\":1}}],[\"算法\",{\"0\":{\"167\":1},\"1\":{\"166\":1}}],[\"经常使用的词不应该再被切分为更小的子词\",{\"1\":{\"170\":1}}],[\"经\",{\"1\":{\"165\":1}}],[\"经过\",{\"1\":{\"190\":1}}],[\"经过内核处理后直接返回\",{\"1\":{\"71\":1}}],[\"经过编码后的字符能在计算机中进行处理\",{\"1\":{\"47\":1}}],[\"版本错误解决方案\",{\"1\":{\"192\":1}}],[\"版本\",{\"1\":{\"164\":1}}],[\"提示\",{\"1\":{\"163\":1,\"188\":1,\"192\":1,\"202\":1,\"205\":1,\"219\":1,\"239\":1}}],[\"提供的最小精度\",{\"1\":{\"239\":1}}],[\"提供评估的方法\",{\"1\":{\"192\":1}}],[\"提供句子对列表\",{\"1\":{\"189\":1}}],[\"提供了加载本地和远程数据集的方法\",{\"1\":{\"218\":1}}],[\"提供了\",{\"1\":{\"190\":1,\"191\":1}}],[\"提供了模型权重\",{\"1\":{\"164\":1}}],[\"提供了模型的架构信息\",{\"1\":{\"164\":1}}],[\"提供了系统\",{\"1\":{\"4\":1,\"11\":1}}],[\"提供此租约的\",{\"1\":{\"77\":1}}],[\"提供一个函数作为\",{\"1\":{\"21\":1}}],[\"替换为\",{\"1\":{\"163\":1}}],[\"得到最后的结果\",{\"1\":{\"201\":1}}],[\"得到最终的结论\",{\"1\":{\"160\":1}}],[\"得到的输入传递给\",{\"1\":{\"158\":1}}],[\"序列\",{\"1\":{\"182\":1}}],[\"序列的数字表示的长度\",{\"1\":{\"158\":1}}],[\"序列到序列\",{\"1\":{\"146\":1}}],[\"架构\",{\"1\":{\"157\":1}}],[\"架构于\",{\"1\":{\"146\":1}}],[\"部分\",{\"1\":{\"157\":1}}],[\"模块输出的张量通常很大\",{\"1\":{\"158\":1}}],[\"模块\",{\"1\":{\"157\":1}}],[\"模型都用\",{\"1\":{\"204\":1}}],[\"模型都是语言模型\",{\"1\":{\"147\":1}}],[\"模型在\",{\"1\":{\"187\":1}}],[\"模型能处理的序列长度是有限的\",{\"1\":{\"181\":1}}],[\"模型默认接收多个句子作为输入\",{\"1\":{\"178\":1}}],[\"模型需要处理大量\",{\"1\":{\"169\":1}}],[\"模型需要关注\",{\"1\":{\"151\":1}}],[\"模型使用这些\",{\"1\":{\"168\":1}}],[\"模型只能处理数字\",{\"1\":{\"166\":1}}],[\"模型只接收\",{\"1\":{\"156\":1}}],[\"模型的更多细节\",{\"1\":{\"163\":1}}],[\"模型的第一步是加载配置对象\",{\"1\":{\"162\":1}}],[\"模型输出的都是\",{\"1\":{\"160\":1}}],[\"模型不能直接处理原始文本\",{\"1\":{\"156\":1}}],[\"模型一般都很大\",{\"1\":{\"154\":1}}],[\"模型分为三类\",{\"1\":{\"146\":1}}],[\"模型中发生的每个操作的定义\",{\"1\":{\"142\":1}}],[\"模型框架\",{\"1\":{\"142\":1}}],[\"模型\",{\"1\":{\"109\":1,\"146\":3,\"150\":3,\"154\":1}}],[\"名称\",{\"1\":{\"156\":1}}],[\"名词\",{\"1\":{\"141\":1}}],[\"映射名称路径的字典\",{\"1\":{\"219\":1}}],[\"映射到一个数字上\",{\"1\":{\"156\":1}}],[\"映射的结果就是编号字符集\",{\"1\":{\"45\":1}}],[\"负无穷大\",{\"1\":{\"239\":1}}],[\"负无穷\",{\"1\":{\"239\":1}}],[\"负责将文本转成数字表示\",{\"1\":{\"154\":1}}],[\"负数表示小于\",{\"1\":{\"21\":1}}],[\"负数\",{\"1\":{\"19\":1}}],[\"训练过程\",{\"1\":{\"215\":1}}],[\"训练数据\",{\"1\":{\"215\":1}}],[\"训练结束后\",{\"1\":{\"208\":1}}],[\"训练模型\",{\"1\":{\"208\":1}}],[\"训练和评估时所用的全部超参\",{\"1\":{\"192\":1}}],[\"训练\",{\"0\":{\"192\":1,\"194\":1},\"1\":{\"154\":1,\"193\":1}}],[\"训练或者部署是一项复杂的任务\",{\"1\":{\"154\":1}}],[\"训练的初始权重\",{\"1\":{\"142\":1}}],[\"按照页面提示进行即可\",{\"1\":{\"210\":1}}],[\"按照上面的配置\",{\"1\":{\"208\":1}}],[\"按照\",{\"1\":{\"153\":1}}],[\"按照其顺序\",{\"1\":{\"139\":1}}],[\"填充\",{\"0\":{\"179\":1}}],[\"填充的内容无意义\",{\"1\":{\"152\":1}}],[\"填充数组\",{\"1\":{\"21\":1}}],[\"完整的目标\",{\"1\":{\"152\":1}}],[\"完全不可能\",{\"1\":{\"72\":1}}],[\"完全兼容\",{\"1\":{\"62\":1}}],[\"连同\",{\"1\":{\"152\":1}}],[\"看来我们还需要把\",{\"1\":{\"222\":1}}],[\"看来是患者\",{\"1\":{\"222\":1}}],[\"看看它的输出\",{\"1\":{\"158\":1}}],[\"看一看\",{\"1\":{\"154\":1}}],[\"看到\",{\"1\":{\"152\":1}}],[\"看是否能将较高时间复杂度那次操作的耗时\",{\"1\":{\"89\":1}}],[\"关注\",{\"1\":{\"151\":1}}],[\"关键在于写出递推公式\",{\"1\":{\"114\":1}}],[\"翻译\",{\"1\":{\"151\":1}}],[\"翻译成中文\",{\"1\":{\"151\":1}}],[\"适用于需要根据输入进行生成的任务\",{\"1\":{\"150\":1}}],[\"适用于需要理解输入的任务\",{\"1\":{\"150\":1}}],[\"适用于生成任务\",{\"1\":{\"150\":1}}],[\"适用于普通对象并做了对应优化\",{\"1\":{\"19\":1}}],[\"扩展阅读\",{\"1\":{\"150\":1}}],[\"扩展二进制编码的十进制交换码\",{\"1\":{\"52\":1}}],[\"设备\",{\"1\":{\"227\":1}}],[\"设备成本\",{\"1\":{\"149\":1}}],[\"设置为\",{\"1\":{\"220\":1}}],[\"设置\",{\"1\":{\"189\":1}}],[\"设置一个合理的队列大小\",{\"1\":{\"111\":1}}],[\"花费长达数周的时间\",{\"1\":{\"149\":1}}],[\"迁移学习\",{\"0\":{\"149\":1}}],[\"女性工作\",{\"1\":{\"145\":1}}],[\"妓女成为了\",{\"1\":{\"145\":1}}],[\"研究员们会收集尽可能多的数据\",{\"1\":{\"145\":1}}],[\"偏见\",{\"0\":{\"145\":1}}],[\"见\",{\"1\":{\"144\":1,\"172\":1,\"222\":1}}],[\"结束时输出\",{\"1\":{\"193\":1}}],[\"结构相同\",{\"1\":{\"180\":1}}],[\"结构如下\",{\"1\":{\"152\":1}}],[\"结构\",{\"0\":{\"150\":1}}],[\"结果\",{\"1\":{\"144\":2}}],[\"结点\",{\"1\":{\"92\":1}}],[\"库提供的\",{\"1\":{\"201\":1}}],[\"库提供了很多方法和类\",{\"1\":{\"209\":1}}],[\"库提供了简单易用的命令来下载并缓存\",{\"1\":{\"188\":1}}],[\"库提供了简单的api\",{\"1\":{\"154\":1}}],[\"库提供了\",{\"1\":{\"144\":1}}],[\"库通过\",{\"1\":{\"190\":1}}],[\"库已经使用了多线程\",{\"1\":{\"189\":1}}],[\"库用\",{\"1\":{\"189\":1}}],[\"库在任何分布式设备上轻松运行自定义训练过程\",{\"1\":{\"186\":1}}],[\"库还提供了\",{\"1\":{\"157\":1}}],[\"库\",{\"0\":{\"144\":1,\"209\":1,\"217\":1},\"1\":{\"193\":1,\"200\":1,\"206\":1,\"217\":2}}],[\"库来创建并使用公开的模型\",{\"1\":{\"143\":1}}],[\"能收到\",{\"1\":{\"232\":1}}],[\"能做什么\",{\"0\":{\"143\":1}}],[\"能够接收来自各个地方的包\",{\"1\":{\"71\":1}}],[\"团队为\",{\"1\":{\"142\":1}}],[\"范语\",{\"1\":{\"142\":1}}],[\"你走你的\",{\"1\":{\"229\":1}}],[\"你能看到在\",{\"1\":{\"216\":1}}],[\"你需要使用\",{\"1\":{\"209\":1}}],[\"你需要使用预训练模型以及针对特定任务的数据集再次进行训练\",{\"1\":{\"149\":1}}],[\"你需要身份令牌一遍\",{\"1\":{\"208\":1}}],[\"你把代码贴到函数下面\",{\"1\":{\"202\":1}}],[\"你也可以用\",{\"1\":{\"208\":1}}],[\"你也可以使用\",{\"1\":{\"202\":1}}],[\"你也可以在\",{\"1\":{\"143\":1}}],[\"你将能够回答以下问题\",{\"1\":{\"217\":1}}],[\"你将了解到\",{\"1\":{\"186\":1}}],[\"你将会看到\",{\"1\":{\"142\":1}}],[\"你应该了解\",{\"1\":{\"176\":1}}],[\"你最后一次保存\",{\"1\":{\"164\":1}}],[\"你可以通过\",{\"1\":{\"216\":1}}],[\"你可以通过设置\",{\"1\":{\"163\":1,\"188\":1}}],[\"你可以阅读\",{\"1\":{\"215\":1}}],[\"你可以训练模型\",{\"1\":{\"208\":1}}],[\"你可以使用\",{\"1\":{\"208\":2}}],[\"你可以使用🤗\",{\"1\":{\"143\":1}}],[\"你可以自己去探索\",{\"1\":{\"204\":1}}],[\"你可以先看看数据\",{\"1\":{\"188\":1}}],[\"你可以在\",{\"1\":{\"164\":1,\"202\":1}}],[\"你可以在这个\",{\"1\":{\"163\":1}}],[\"你可以在模型中心中查找模型\",{\"1\":{\"153\":1}}],[\"你可以在模型中心中查找预训练模型\",{\"1\":{\"143\":1}}],[\"你可以直接使用随机初始化的\",{\"1\":{\"163\":1}}],[\"你可以直接使用对应的\",{\"1\":{\"161\":1}}],[\"你可以用\",{\"1\":{\"5\":1}}],[\"生成上下文\",{\"1\":{\"141\":1}}],[\"生产者\",{\"1\":{\"109\":2}}],[\"组合在一起了\",{\"1\":{\"175\":1}}],[\"组织\",{\"1\":{\"141\":1}}],[\"组播地址\",{\"1\":{\"70\":1}}],[\"地点\",{\"1\":{\"141\":1}}],[\"地址时\",{\"1\":{\"231\":1}}],[\"地址缓存过一段时间就会过期\",{\"1\":{\"230\":1}}],[\"地址找\",{\"1\":{\"230\":1}}],[\"地址呢\",{\"1\":{\"230\":1,\"231\":1}}],[\"地址以外\",{\"1\":{\"80\":1}}],[\"地址回收和续租\",{\"0\":{\"79\":1}}],[\"地址的协议\",{\"1\":{\"230\":1}}],[\"地址的合法租用信息和其他的配置信息都放入该广播包\",{\"1\":{\"78\":1}}],[\"地址的上一行是\",{\"1\":{\"71\":1}}],[\"地址租用期等信息\",{\"1\":{\"76\":1}}],[\"地址是这个\",{\"1\":{\"75\":1}}],[\"地址是唯一的标识\",{\"1\":{\"71\":1}}],[\"地址里申请\",{\"1\":{\"73\":1}}],[\"地址不是它的\",{\"1\":{\"72\":1}}],[\"地址配置\",{\"0\":{\"72\":1}}],[\"地址就不行了\",{\"1\":{\"71\":1}}],[\"地址具有一定定位功能\",{\"1\":{\"71\":1}}],[\"地址次具有远程定位功能\",{\"1\":{\"71\":1}}],[\"地址全局全局唯一\",{\"1\":{\"71\":1}}],[\"地址\",{\"0\":{\"101\":1},\"1\":{\"70\":3,\"71\":3,\"72\":3,\"73\":1,\"75\":3,\"76\":3,\"77\":6,\"80\":5,\"81\":1,\"229\":1,\"231\":1,\"232\":1}}],[\"地址分为两部分\",{\"1\":{\"70\":1}}],[\"地址范围\",{\"1\":{\"70\":2}}],[\"人\",{\"1\":{\"141\":1}}],[\"动态填充\",{\"0\":{\"190\":1}}],[\"动态主机配置协议\",{\"0\":{\"73\":1}}],[\"动词\",{\"1\":{\"141\":1}}],[\"识别句子的语法成分\",{\"1\":{\"141\":1}}],[\"检查下目标\",{\"1\":{\"231\":1}}],[\"检查是否\",{\"1\":{\"21\":1}}],[\"检测电子邮件是否为垃圾邮件\",{\"1\":{\"141\":1}}],[\"说明不能再前进了\",{\"1\":{\"139\":1}}],[\"说明不能再回退了\",{\"1\":{\"139\":1}}],[\"压入栈\",{\"1\":{\"139\":1}}],[\"压缩字节序列的值\",{\"1\":{\"48\":1}}],[\"浏览器回退\",{\"0\":{\"139\":1}}],[\"判定括号不匹配\",{\"1\":{\"138\":1}}],[\"判断发给谁\",{\"1\":{\"229\":1}}],[\"判断每个句子是\",{\"1\":{\"159\":1}}],[\"判断能否匹配\",{\"1\":{\"138\":1}}],[\"判断环的起点\",{\"1\":{\"99\":1}}],[\"判断是否有环\",{\"1\":{\"99\":1}}],[\"判断\",{\"1\":{\"21\":1}}],[\"判断属性是否存在\",{\"1\":{\"2\":1}}],[\"括号匹配\",{\"0\":{\"138\":1}}],[\"继续比较当前运算符和新的栈顶运算符\",{\"1\":{\"137\":1}}],[\"继续以癌症诊断场景为\",{\"1\":{\"40\":1}}],[\"遇到运算符时\",{\"1\":{\"137\":1}}],[\"遇到数字时\",{\"1\":{\"137\":1}}],[\"五数取中\",{\"1\":{\"133\":1}}],[\"尾数\",{\"1\":{\"239\":1}}],[\"尾\",{\"1\":{\"133\":1}}],[\"尾结点时\",{\"1\":{\"104\":1}}],[\"尾结点\",{\"1\":{\"92\":1}}],[\"三数取中法\",{\"1\":{\"133\":1}}],[\"优先级向量\",{\"1\":{\"233\":1}}],[\"优化器\",{\"0\":{\"198\":1}}],[\"优化排序\",{\"0\":{\"133\":1}}],[\"优点\",{\"1\":{\"93\":1,\"117\":1}}],[\"赋初值\",{\"1\":{\"130\":1}}],[\"申请数组\",{\"1\":{\"130\":1}}],[\"省掉了桶内排序的时间\",{\"1\":{\"130\":1}}],[\"省掉的一个比较语句积累的时间会比较明显\",{\"1\":{\"103\":1}}],[\"才会退化到\",{\"1\":{\"126\":1}}],[\"才出栈\",{\"1\":{\"115\":1}}],[\"退化到了\",{\"1\":{\"126\":1}}],[\"递推公式\",{\"1\":{\"126\":1}}],[\"递归代码的时间复杂度分析\",{\"1\":{\"125\":1}}],[\"递归代码要警惕堆栈溢出\",{\"0\":{\"115\":1}}],[\"递归需要满足的\",{\"0\":{\"113\":1}}],[\"递归\",{\"0\":{\"112\":1},\"1\":{\"117\":2}}],[\"右边的数据\",{\"1\":{\"126\":1}}],[\"右边是数组\",{\"1\":{\"20\":1}}],[\"左边的数据和\",{\"1\":{\"126\":1}}],[\"左边是基本类型\",{\"1\":{\"20\":1}}],[\"选取前面几个样本\",{\"1\":{\"222\":1}}],[\"选取最后一个元素做\",{\"1\":{\"127\":1}}],[\"选取要排序数组中的任意一个元素最为\",{\"1\":{\"126\":1}}],[\"选择任务\",{\"1\":{\"144\":1}}],[\"选择这三个数的中间值作为分区点\",{\"1\":{\"133\":1}}],[\"选择排序\",{\"1\":{\"123\":1,\"132\":1}}],[\"选择排序不稳定\",{\"1\":{\"123\":1}}],[\"选择\",{\"0\":{\"119\":1},\"1\":{\"118\":1}}],[\"带入上式得\",{\"1\":{\"125\":1}}],[\"解决的是谁先发谁后发的问题\",{\"1\":{\"229\":1}}],[\"解决了在把二者的结果合并成\",{\"1\":{\"125\":1}}],[\"解码器使用编码器的表示\",{\"1\":{\"150\":1}}],[\"解码器\",{\"1\":{\"150\":1}}],[\"解码\",{\"0\":{\"175\":1},\"1\":{\"42\":1,\"47\":1,\"175\":1}}],[\"合并两个有序子数组的时间复杂度已知是\",{\"1\":{\"125\":1}}],[\"合并\",{\"1\":{\"125\":1}}],[\"整数范围\",{\"1\":{\"239\":1}}],[\"整数属性\",{\"1\":{\"3\":1}}],[\"整数属性会进行排序\",{\"1\":{\"3\":1}}],[\"整个数组就有序了\",{\"1\":{\"125\":1}}],[\"归并排序的处理过程是由下到上的\",{\"1\":{\"127\":1}}],[\"归并排序和快速排序用的都是分治思想\",{\"1\":{\"127\":1}}],[\"归并排序和快速排序都用到了分治思想\",{\"1\":{\"124\":1}}],[\"归并排序不是原地排序算法\",{\"1\":{\"125\":1}}],[\"归并排序使用的是分治思想\",{\"1\":{\"125\":1}}],[\"归并排序\",{\"0\":{\"124\":1},\"1\":{\"132\":1}}],[\"移动数据\",{\"1\":{\"121\":1}}],[\"移动的次数是固定的\",{\"1\":{\"121\":1}}],[\"移动\",{\"1\":{\"121\":1}}],[\"初始化\",{\"1\":{\"162\":1,\"214\":1}}],[\"初始已排序区间是数组的第一个元素\",{\"1\":{\"121\":1}}],[\"初始有序度是\",{\"1\":{\"120\":1}}],[\"直到区间缩小为\",{\"1\":{\"126\":1,\"127\":1}}],[\"直到未排序区间为空\",{\"1\":{\"121\":1}}],[\"直接把字符串作为十进制进行解析\",{\"1\":{\"243\":1}}],[\"直接调用表示强制类型转换\",{\"1\":{\"241\":1}}],[\"直接发送到对应的口就行\",{\"1\":{\"231\":1}}],[\"直接使用下面的代码加载数据\",{\"1\":{\"219\":1}}],[\"直接使用\",{\"1\":{\"214\":1}}],[\"直接入栈\",{\"1\":{\"137\":1}}],[\"直接返回报错\",{\"1\":{\"115\":1}}],[\"直接拒绝任务请求\",{\"1\":{\"111\":1}}],[\"直接启动就能用了\",{\"1\":{\"80\":1}}],[\"直接向为其提供\",{\"1\":{\"79\":1}}],[\"直接填入\",{\"1\":{\"72\":1}}],[\"直接在变量\",{\"1\":{\"24\":1}}],[\"直接成为一个迭代器\",{\"1\":{\"13\":1}}],[\"已知其\",{\"1\":{\"232\":1}}],[\"已经生成了3个单词\",{\"1\":{\"152\":1}}],[\"已经有序\",{\"1\":{\"120\":1}}],[\"已排序区间和未排序区间\",{\"1\":{\"121\":1}}],[\"​=c\",{\"1\":{\"125\":1}}],[\"​\",{\"1\":{\"120\":3}}],[\"​−初始有序度\",{\"1\":{\"120\":1}}],[\"​o\",{\"1\":{\"88\":1}}],[\"满序度\",{\"1\":{\"120\":1}}],[\"逆序度\",{\"1\":{\"120\":1}}],[\"倒序\",{\"1\":{\"120\":1,\"121\":1}}],[\"稳定\",{\"1\":{\"120\":1,\"121\":1,\"123\":1,\"125\":1,\"132\":1}}],[\"稳定性\",{\"1\":{\"118\":1}}],[\"交换机之间可以通过这种口互相连接\",{\"1\":{\"234\":1}}],[\"交换机如何区别某个机器属于哪个局域网呢\",{\"1\":{\"234\":1}}],[\"交换机如何知道每个口的电脑的\",{\"1\":{\"231\":1}}],[\"交换机已经知道了机器\",{\"1\":{\"232\":1}}],[\"交换机与\",{\"0\":{\"232\":1}}],[\"交换机就有了整个网络的结构了\",{\"1\":{\"231\":1}}],[\"交换机聪明之处在于\",{\"1\":{\"231\":1}}],[\"交换机\",{\"1\":{\"231\":1,\"232\":2}}],[\"交换次数=逆序度=2n\",{\"1\":{\"120\":1}}],[\"交换\",{\"1\":{\"120\":1,\"122\":1,\"126\":1}}],[\"低阶\",{\"1\":{\"118\":1}}],[\"✗\",{\"1\":{\"118\":1,\"123\":1,\"132\":6}}],[\"计数排序只能对非负数进行排序\",{\"1\":{\"130\":1}}],[\"计数排序只能用在数据范围不大的场景中\",{\"1\":{\"130\":1}}],[\"计数排序算是桶排序的一种特殊情况\",{\"1\":{\"130\":1}}],[\"计数排序\",{\"0\":{\"128\":1},\"1\":{\"132\":1}}],[\"计数\",{\"1\":{\"118\":1}}],[\"计算\",{\"1\":{\"116\":1}}],[\"计算加权平均\",{\"1\":{\"88\":1}}],[\"计算出现后\",{\"1\":{\"54\":1}}],[\"计算机网络中生成树算法是stp\",{\"1\":{\"233\":1}}],[\"计算机启动是\",{\"1\":{\"80\":1}}],[\"计算机普遍采用8位作为一个字节来进行存取与处理\",{\"1\":{\"53\":1}}],[\"计算机才能够正确地进行处理\",{\"1\":{\"47\":1}}],[\"计算机可以最高效处理的数据大小应该与其字长相同\",{\"1\":{\"42\":1}}],[\"桶与桶之间有着天然的大小顺序\",{\"1\":{\"129\":1}}],[\"桶排序比较适合用在外部排序中\",{\"1\":{\"129\":1}}],[\"桶排序\",{\"0\":{\"128\":1},\"1\":{\"132\":1}}],[\"桶\",{\"1\":{\"118\":1}}],[\"✓\",{\"1\":{\"118\":2,\"123\":5,\"132\":10}}],[\"冒泡中元素交换\",{\"1\":{\"123\":1}}],[\"冒泡排序\",{\"1\":{\"123\":1,\"132\":1}}],[\"冒泡排序要进行\",{\"1\":{\"123\":1}}],[\"冒泡排序的元素交换次数是固定值\",{\"1\":{\"123\":1}}],[\"冒泡排序有两个原子操作\",{\"1\":{\"120\":1}}],[\"冒泡和插入排序都是稳定的\",{\"1\":{\"123\":1}}],[\"冒泡\",{\"0\":{\"119\":1},\"1\":{\"118\":1}}],[\"手动\",{\"1\":{\"117\":1}}],[\"缺点\",{\"1\":{\"117\":1}}],[\"写起来很简洁\",{\"1\":{\"117\":1}}],[\"写代码时不必写成第二段那样\",{\"1\":{\"103\":1}}],[\"空间不足将会有问题\",{\"1\":{\"189\":1}}],[\"空间上也要考虑压栈出栈的开销\",{\"1\":{\"116\":1}}],[\"空间复杂度高\",{\"1\":{\"117\":1}}],[\"空间复杂度\",{\"0\":{\"85\":1},\"1\":{\"85\":1,\"118\":1,\"125\":1,\"126\":1}}],[\"警惕重复计算\",{\"0\":{\"116\":1}}],[\"警惕指针丢失和内存泄漏\",{\"0\":{\"102\":1}}],[\"事先无法计算\",{\"1\":{\"115\":1}}],[\"终止条件\",{\"1\":{\"114\":1,\"125\":1,\"126\":1}}],[\"加速了预处理\",{\"1\":{\"189\":1}}],[\"加载的方式并指定\",{\"1\":{\"222\":1}}],[\"加载远程数据集\",{\"0\":{\"220\":1}}],[\"加载本地文件会创建一个带有\",{\"1\":{\"219\":1}}],[\"加载本地数据集\",{\"0\":{\"219\":1}}],[\"加载并计算\",{\"1\":{\"217\":1}}],[\"加载和保存\",{\"1\":{\"171\":1}}],[\"加载\",{\"0\":{\"171\":1},\"1\":{\"171\":1}}],[\"加上先走\",{\"1\":{\"114\":1}}],[\"加入了少数民族的文字\",{\"1\":{\"58\":1}}],[\"阶后\",{\"1\":{\"114\":2}}],[\"阶乘阶\",{\"1\":{\"85\":1}}],[\"请查看\",{\"1\":{\"216\":1}}],[\"请确保安装了\",{\"1\":{\"214\":1}}],[\"请看这里\",{\"1\":{\"202\":1}}],[\"请直接从\",{\"1\":{\"187\":1}}],[\"请问走\",{\"1\":{\"114\":1}}],[\"请求爆炸\",{\"1\":{\"233\":1}}],[\"请求就完成了\",{\"1\":{\"232\":1}}],[\"请求将文件直接传到\",{\"1\":{\"212\":1}}],[\"请求处理的时间过长\",{\"1\":{\"111\":1}}],[\"请求\",{\"1\":{\"72\":1,\"80\":1,\"229\":1,\"230\":1}}],[\"求解思路完全一样\",{\"1\":{\"113\":1}}],[\"求链表的中间结点\",{\"1\":{\"106\":1}}],[\"接下来我们使用的数据集为\",{\"1\":{\"222\":1}}],[\"接下来我们将介绍如何在自己的数据集上进行微调\",{\"1\":{\"186\":1}}],[\"接下来使用常规的\",{\"1\":{\"214\":1}}],[\"接下来\",{\"1\":{\"214\":1}}],[\"接下来可以使用传统的\",{\"1\":{\"213\":1}}],[\"接下来在定义\",{\"1\":{\"195\":1}}],[\"接下来还有\",{\"1\":{\"154\":1}}],[\"接下来的请求就会被拒绝\",{\"1\":{\"111\":1}}],[\"接近数据个数\",{\"1\":{\"129\":1}}],[\"接受的值可以是\",{\"1\":{\"209\":1}}],[\"接受的租约中的\",{\"1\":{\"77\":1}}],[\"接受某个\",{\"1\":{\"77\":1}}],[\"接受任意数量的参数\",{\"1\":{\"21\":1}}],[\"先通过\",{\"1\":{\"232\":1}}],[\"先出门\",{\"1\":{\"229\":1}}],[\"先分区\",{\"1\":{\"127\":1}}],[\"先处理子问题\",{\"1\":{\"127\":1}}],[\"先写递推公式\",{\"1\":{\"125\":1}}],[\"先去散列表中取\",{\"1\":{\"116\":1}}],[\"先进者先服务\",{\"1\":{\"111\":1}}],[\"先后接\",{\"1\":{\"102\":1}}],[\"取出栈顶的左括号\",{\"1\":{\"138\":1}}],[\"取出排队的请求继续处理\",{\"1\":{\"111\":1}}],[\"取决于\",{\"1\":{\"125\":1}}],[\"取决于用户使用的字体文件\",{\"1\":{\"65\":1}}],[\"取未排序区间中的元素\",{\"1\":{\"121\":1}}],[\"取中间值\",{\"1\":{\"120\":1}}],[\"另一类是第一步走了\",{\"1\":{\"114\":1}}],[\"另一种是阻塞的处理方式\",{\"1\":{\"111\":1}}],[\"另外两个几乎包含了整个第\",{\"1\":{\"65\":1}}],[\"另外\",{\"1\":{\"65\":1,\"116\":1,\"168\":1,\"169\":1,\"204\":1}}],[\"底层申请锁资源\",{\"1\":{\"110\":1}}],[\"避免真正去\",{\"1\":{\"110\":1}}],[\"避免数据搬移\",{\"1\":{\"110\":1}}],[\"原始模型\",{\"0\":{\"152\":1}}],[\"原始模型中很容易掺杂性别歧视\",{\"1\":{\"145\":1}}],[\"原数组有序\",{\"1\":{\"126\":1}}],[\"原地\",{\"1\":{\"123\":1,\"126\":1,\"132\":1}}],[\"原地排序\",{\"1\":{\"118\":1}}],[\"原子操作\",{\"1\":{\"110\":1}}],[\"原位\",{\"1\":{\"21\":1}}],[\"利用分治思想解决非排序问题\",{\"1\":{\"127\":1}}],[\"利用数组实现的有界队列\",{\"1\":{\"111\":1}}],[\"利用链表实现的队列\",{\"1\":{\"111\":1}}],[\"利用\",{\"1\":{\"110\":1}}],[\"利用哨兵简化变成难度\",{\"1\":{\"103\":1}}],[\"利用哨兵简化实现难度\",{\"0\":{\"103\":1}}],[\"线程池该如何处理\",{\"0\":{\"111\":1}}],[\"线程池没有空闲线程时\",{\"0\":{\"111\":1}}],[\"线程安全的队列叫并发队列\",{\"1\":{\"110\":1}}],[\"线性排序的使用场景特殊\",{\"1\":{\"132\":1}}],[\"线性排序\",{\"0\":{\"128\":1}}],[\"线性对数阶\",{\"1\":{\"85\":1}}],[\"线性阶\",{\"1\":{\"85\":1}}],[\"线性判别分析\",{\"1\":{\"33\":1}}],[\"消费者\",{\"1\":{\"109\":2}}],[\"消息包\",{\"1\":{\"78\":1,\"79\":2}}],[\"知道目的\",{\"1\":{\"232\":1}}],[\"知道你的权限\",{\"1\":{\"208\":1}}],[\"知道队列中有空闲位置后再插入数据\",{\"1\":{\"109\":1}}],[\"知道队列中有了数据才能返回\",{\"1\":{\"109\":1}}],[\"知道来了个\",{\"1\":{\"76\":1}}],[\"环路问题会导致\",{\"1\":{\"233\":1}}],[\"环路问题\",{\"0\":{\"233\":1}}],[\"环境变量来自定义缓存路径\",{\"1\":{\"163\":1,\"188\":1}}],[\"环形缓存\",{\"1\":{\"108\":1}}],[\"环回接口\",{\"1\":{\"71\":1}}],[\"阻塞队列是在队列的基础上增加了阻塞操作\",{\"1\":{\"109\":1}}],[\"阻塞队列\",{\"0\":{\"109\":1},\"1\":{\"108\":1}}],[\"队满\",{\"1\":{\"108\":1}}],[\"队空\",{\"1\":{\"108\":1}}],[\"队首出队\",{\"1\":{\"108\":1}}],[\"队尾入队\",{\"1\":{\"108\":1}}],[\"队列可以应用在任何有限资源池中\",{\"1\":{\"111\":1}}],[\"队列太小会导致无法充分利用系统资源\",{\"1\":{\"111\":1}}],[\"队列太大导致等待的请求太多\",{\"1\":{\"111\":1}}],[\"队列大小有限\",{\"1\":{\"111\":1}}],[\"队列\",{\"0\":{\"107\":1},\"1\":{\"108\":1,\"111\":1}}],[\"出错\",{\"1\":{\"239\":1}}],[\"出队\",{\"1\":{\"108\":1}}],[\"出栈\",{\"1\":{\"108\":1}}],[\"入队\",{\"1\":{\"108\":1}}],[\"入栈\",{\"1\":{\"108\":1}}],[\"栈为空\",{\"1\":{\"138\":1}}],[\"栈的应用\",{\"0\":{\"135\":1}}],[\"栈\",{\"0\":{\"134\":1},\"1\":{\"108\":1,\"136\":1,\"139\":2}}],[\"固定步数差值\",{\"1\":{\"106\":1}}],[\"固件\",{\"1\":{\"80\":1}}],[\"两台交换机都学到了这样的信息\",{\"1\":{\"232\":1}}],[\"两个有序链表的合并\",{\"1\":{\"106\":1}}],[\"两边一个是对象\",{\"1\":{\"20\":1}}],[\"辅助思考\",{\"0\":{\"105\":1}}],[\"举例画图\",{\"0\":{\"105\":1}}],[\"重点留意边界条件处理\",{\"0\":{\"104\":1}}],[\"重新编码为多字节\",{\"1\":{\"58\":1}}],[\"恢复\",{\"1\":{\"103\":1}}],[\"少了\",{\"1\":{\"103\":1}}],[\"做完你想做的事情时候\",{\"1\":{\"208\":1}}],[\"做哨兵\",{\"1\":{\"103\":1}}],[\"做一些其他的操作\",{\"1\":{\"14\":1}}],[\"||\",{\"1\":{\"103\":2}}],[\"查找插入位置\",{\"1\":{\"121\":1}}],[\"查找\",{\"1\":{\"103\":1}}],[\"查看\",{\"1\":{\"71\":1}}],[\"给定文本\",{\"1\":{\"165\":1}}],[\"给定问题和上下文\",{\"1\":{\"141\":1}}],[\"给定数组\",{\"1\":{\"103\":1}}],[\"给它分配一个地址\",{\"1\":{\"80\":1}}],[\"任何情况下都是\",{\"1\":{\"125\":1}}],[\"任何可以在\",{\"1\":{\"12\":1}}],[\"任务以及如何使用\",{\"1\":{\"153\":1}}],[\"任务有很多\",{\"1\":{\"141\":1}}],[\"任务\",{\"1\":{\"103\":1,\"153\":1}}],[\"记录每个元素的个数\",{\"1\":{\"130\":1}}],[\"记录链表的基地址\",{\"1\":{\"92\":1}}],[\"记得手动释放内存空间\",{\"1\":{\"102\":1}}],[\"理解指针或引用的含义\",{\"0\":{\"101\":1}}],[\"下次当机器\",{\"1\":{\"232\":1}}],[\"下次执行时不需要重复计算\",{\"1\":{\"189\":1}}],[\"下图是两台交换机连接三个局域网的情况\",{\"1\":{\"232\":1}}],[\"下载并解压\",{\"1\":{\"219\":1}}],[\"下的文件目录\",{\"1\":{\"214\":1}}],[\"下一次分区时\",{\"1\":{\"127\":1}}],[\"下中点\",{\"1\":{\"99\":1}}],[\"下面我将使用\",{\"1\":{\"223\":1}}],[\"下面我们验证一下\",{\"1\":{\"222\":1}}],[\"下面我们将介绍三种上传文件到\",{\"1\":{\"211\":1}}],[\"下面我们添加一些输出\",{\"1\":{\"200\":1}}],[\"下面我们要进行微调了\",{\"1\":{\"190\":1}}],[\"下面我们先介绍下\",{\"1\":{\"171\":1}}],[\"下面我们来使用模型进行预测\",{\"1\":{\"165\":1}}],[\"下面我们直接使用迭代器本身来进行\",{\"1\":{\"14\":1}}],[\"下面的分步调用只是为了让大家更清楚\",{\"1\":{\"172\":1}}],[\"下面分别介绍这两步\",{\"1\":{\"172\":1}}],[\"下面介绍\",{\"1\":{\"168\":1}}],[\"下面介绍几种\",{\"1\":{\"166\":1}}],[\"下面介绍三种最常见的列表结构\",{\"1\":{\"91\":1}}],[\"下面将使用\",{\"1\":{\"161\":1}}],[\"下面列举了一部分\",{\"1\":{\"157\":1}}],[\"下面是和仓库创建\",{\"1\":{\"209\":1}}],[\"下面是\",{\"1\":{\"133\":1}}],[\"下面是一个\",{\"1\":{\"80\":1}}],[\"下面是完整的语法\",{\"1\":{\"21\":1}}],[\"找中点\",{\"1\":{\"99\":1}}],[\"找到最小元素的时间复杂度是\",{\"1\":{\"122\":1}}],[\"找到最小值和目标位置做交换\",{\"1\":{\"122\":1}}],[\"找到合适的位置插入\",{\"1\":{\"121\":1}}],[\"找到终止条件\",{\"1\":{\"114\":1}}],[\"找到\",{\"1\":{\"21\":1}}],[\"快排\",{\"1\":{\"118\":1}}],[\"快慢指针\",{\"0\":{\"99\":1},\"1\":{\"106\":2}}],[\"快速检验下是否有错\",{\"1\":{\"196\":1,\"197\":1}}],[\"快速体验\",{\"0\":{\"144\":1}}],[\"快速排序在最坏情况下的时间复杂度是\",{\"1\":{\"133\":1}}],[\"快速排序最差情况下的时间复杂度是\",{\"1\":{\"125\":1}}],[\"快速排序\",{\"0\":{\"124\":1},\"1\":{\"85\":1,\"132\":1}}],[\"快速介绍\",{\"0\":{\"2\":1,\"19\":1}}],[\"越靠近链表尾部的结点是越早之前访问的\",{\"1\":{\"98\":1}}],[\"缓存\",{\"1\":{\"230\":2}}],[\"缓存路径为\",{\"1\":{\"163\":1,\"188\":1}}],[\"缓存淘汰算法\",{\"1\":{\"98\":1}}],[\"缓存不友好\",{\"1\":{\"96\":1}}],[\"垃圾回收\",{\"1\":{\"96\":1}}],[\"垃圾邮件分类的目标是\",{\"1\":{\"40\":1}}],[\"垃圾邮件分类时\",{\"1\":{\"40\":1}}],[\"垃圾邮件为positive\",{\"1\":{\"40\":1}}],[\"容易造成内存碎片\",{\"1\":{\"96\":1}}],[\"容易造成属性名的冲突\",{\"1\":{\"4\":1,\"240\":1}}],[\"天然地支持动态扩容\",{\"1\":{\"96\":1}}],[\"导致\",{\"1\":{\"96\":1}}],[\"导出了\",{\"1\":{\"29\":2}}],[\"导出时\",{\"1\":{\"28\":1}}],[\"预期用途和限制\",{\"1\":{\"215\":1}}],[\"预测用了多长时间\",{\"1\":{\"193\":1}}],[\"预处理数据\",{\"1\":{\"217\":1}}],[\"预处理数据集\",{\"1\":{\"203\":1}}],[\"预处理\",{\"1\":{\"155\":1}}],[\"预训练这类模型可以使用\",{\"1\":{\"150\":1}}],[\"预训练\",{\"1\":{\"149\":1}}],[\"预读数组中的数据\",{\"1\":{\"96\":1}}],[\"预启动执行环境\",{\"0\":{\"80\":1}}],[\"决定往前找还是往后找\",{\"1\":{\"94\":1}}],[\"决定了\",{\"1\":{\"42\":1}}],[\"随机接入协议\",{\"1\":{\"229\":1}}],[\"随机法\",{\"1\":{\"133\":1}}],[\"随机访问的性能不如数组\",{\"1\":{\"92\":1}}],[\"随机变量\",{\"1\":{\"34\":1}}],[\"头\",{\"1\":{\"231\":1}}],[\"头结点\",{\"1\":{\"92\":1}}],[\"头中的一个字段\",{\"1\":{\"71\":1}}],[\"双指针\",{\"1\":{\"106\":1}}],[\"双向循环链表\",{\"0\":{\"95\":1}}],[\"双向链表的按值查询的效率要比单链表高一些\",{\"1\":{\"94\":1}}],[\"双向链表可以支持\",{\"1\":{\"94\":1}}],[\"双向链表\",{\"0\":{\"94\":1},\"1\":{\"91\":1}}],[\"双字\",{\"1\":{\"42\":1}}],[\"几十万次时\",{\"1\":{\"103\":1}}],[\"几种常见的链表结构\",{\"0\":{\"91\":1}}],[\"几乎所有函数的数组方法\",{\"1\":{\"21\":1}}],[\"摊还分析\",{\"1\":{\"89\":1}}],[\"期望\",{\"1\":{\"88\":1}}],[\"假设在数组中的概率和不在数组中的概率都是\",{\"1\":{\"88\":1}}],[\"种族歧视等问题\",{\"1\":{\"145\":1}}],[\"种\",{\"1\":{\"88\":1}}],[\"种情况\",{\"1\":{\"88\":1}}],[\"种处理方式\",{\"1\":{\"58\":1}}],[\"步\",{\"1\":{\"87\":1}}],[\"均摊时间复杂度\",{\"0\":{\"86\":1,\"89\":1}}],[\"次桶排序或者计数排序\",{\"1\":{\"131\":1}}],[\"次分区\",{\"1\":{\"126\":1}}],[\"次插入操作\",{\"1\":{\"121\":1}}],[\"次交换\",{\"1\":{\"120\":1}}],[\"次数\",{\"1\":{\"118\":1}}],[\"次方阶\",{\"1\":{\"85\":1}}],[\"次广播\",{\"1\":{\"74\":1}}],[\"立方阶\",{\"1\":{\"85\":1}}],[\"遍\",{\"1\":{\"85\":1}}],[\"遍历数组\",{\"1\":{\"126\":1,\"130\":1}}],[\"遍历呢\",{\"1\":{\"12\":1}}],[\"遍历\",{\"1\":{\"6\":1,\"11\":1,\"14\":1}}],[\"渐进\",{\"1\":{\"85\":2}}],[\"复杂度的上限是\",{\"1\":{\"120\":1}}],[\"复杂度分析\",{\"0\":{\"84\":1}}],[\"复制参数本身\",{\"1\":{\"21\":1}}],[\"点此查看\",{\"1\":{\"82\":1}}],[\"平摊到其他那些时间复杂度比较低的操作上\",{\"1\":{\"89\":1}}],[\"平均时长\",{\"1\":{\"193\":1}}],[\"平均时间复杂度是\",{\"1\":{\"121\":1}}],[\"平均每个桶\",{\"1\":{\"129\":1}}],[\"平均都是\",{\"1\":{\"122\":1}}],[\"平均情况下\",{\"1\":{\"120\":1}}],[\"平均情况时间复杂度\",{\"0\":{\"88\":1}}],[\"平均情况时间复杂度为\",{\"1\":{\"82\":1}}],[\"平均\",{\"0\":{\"86\":1},\"1\":{\"118\":1,\"120\":1,\"121\":1,\"123\":1}}],[\"平方阶\",{\"1\":{\"85\":1}}],[\"平面的字符时要注意\",{\"1\":{\"238\":1}}],[\"平面和第\",{\"1\":{\"65\":1}}],[\"平面中有一个私用区\",{\"1\":{\"65\":1}}],[\"平面上的\",{\"1\":{\"65\":1}}],[\"平面\",{\"1\":{\"65\":2}}],[\"插入排序\",{\"1\":{\"123\":1,\"132\":1}}],[\"插入排序中的元素移动\",{\"1\":{\"123\":1}}],[\"插入排序的元素移动次数也是固定值\",{\"1\":{\"123\":1}}],[\"插入数据\",{\"1\":{\"121\":1}}],[\"插入点之后的元素都需要往后移动腾出位置\",{\"1\":{\"121\":1}}],[\"插入第一个结点\",{\"1\":{\"103\":1}}],[\"插入第一个节点\",{\"1\":{\"103\":1}}],[\"插入\",{\"0\":{\"119\":1},\"1\":{\"82\":1,\"92\":1,\"103\":1,\"118\":1}}],[\"插入和删除比较低效\",{\"1\":{\"82\":1}}],[\"插入都可以完成\",{\"1\":{\"21\":1}}],[\"向机器\",{\"1\":{\"232\":1}}],[\"向电脑\",{\"1\":{\"231\":1}}],[\"向\",{\"1\":{\"81\":1,\"208\":1}}],[\"向后完全兼容\",{\"1\":{\"60\":1}}],[\"启动\",{\"1\":{\"81\":1}}],[\"启动文件\",{\"1\":{\"81\":1}}],[\"启动之后才能安装操作系统\",{\"1\":{\"80\":1}}],[\"租给他一个\",{\"1\":{\"81\":1}}],[\"租用期更新就完成了\",{\"1\":{\"79\":1}}],[\"租用请求者\",{\"1\":{\"77\":1}}],[\"那段代码\",{\"1\":{\"202\":1}}],[\"那将会生成大量\",{\"1\":{\"168\":1}}],[\"那就退化为\",{\"1\":{\"129\":1}}],[\"那数组就更适合你\",{\"1\":{\"96\":1}}],[\"那它怎么知道\",{\"1\":{\"80\":1}}],[\"那么该字段还会包括\",{\"1\":{\"193\":1}}],[\"那么该对象会被转换为原始类型\",{\"1\":{\"20\":1}}],[\"那么就需要\",{\"1\":{\"131\":1}}],[\"那么到\",{\"1\":{\"127\":2}}],[\"那么插入数据的操作会被阻塞\",{\"1\":{\"109\":1}}],[\"那么出现在每个位置的概率为\",{\"1\":{\"88\":1}}],[\"那么需要将整个数组遍历一遍\",{\"1\":{\"87\":1}}],[\"那么循环只执行\",{\"1\":{\"87\":1}}],[\"那么可以将要插入位置的元素插入到最后\",{\"1\":{\"82\":1}}],[\"那么包完全发不出去\",{\"1\":{\"72\":1}}],[\"那么这个字节的含义与\",{\"1\":{\"58\":1}}],[\"那么\",{\"1\":{\"21\":1,\"127\":1,\"179\":1}}],[\"那么会将数组的第一个元素作为初始值\",{\"1\":{\"21\":1}}],[\"那么它在之前已经被缓存了\",{\"1\":{\"157\":1}}],[\"那么它会企图把包发送到网关\",{\"1\":{\"72\":1}}],[\"那么它会被当做一个数组来处理\",{\"1\":{\"21\":1}}],[\"那么它就是整数属性\",{\"1\":{\"3\":1}}],[\"那么我们会很自然地想使用\",{\"1\":{\"12\":1}}],[\"让它自己处理\",{\"1\":{\"195\":1}}],[\"让它在训练时进行评估\",{\"1\":{\"192\":1}}],[\"让\",{\"1\":{\"80\":1}}],[\"让大家都知道\",{\"1\":{\"78\":1}}],[\"啥都没有\",{\"1\":{\"80\":1}}],[\"更多示例\",{\"1\":{\"202\":1}}],[\"更多的是逻辑意义上的中间编码\",{\"1\":{\"47\":1}}],[\"更好的做法是当我们构建一个\",{\"1\":{\"189\":1}}],[\"更新自己的配置\",{\"1\":{\"79\":1}}],[\"参数很灵活\",{\"1\":{\"219\":1}}],[\"参数给\",{\"1\":{\"189\":1}}],[\"参数去掉了\",{\"1\":{\"189\":1}}],[\"参数设置\",{\"1\":{\"178\":1}}],[\"参数传递对应的模型名称\",{\"1\":{\"144\":1}}],[\"参数\",{\"1\":{\"79\":1}}],[\"参考文档\",{\"1\":{\"213\":1}}],[\"参考\",{\"1\":{\"40\":1,\"213\":1}}],[\"客户端会请求这些文件\",{\"1\":{\"81\":1}}],[\"客户端一个配置文件\",{\"1\":{\"81\":1}}],[\"客户端向\",{\"1\":{\"81\":1}}],[\"客户端去\",{\"1\":{\"81\":1}}],[\"客户端启动\",{\"1\":{\"81\":1}}],[\"客户端启动后\",{\"1\":{\"80\":1}}],[\"客户端启动的时候\",{\"1\":{\"80\":1}}],[\"客户端有了自己的地址\",{\"1\":{\"80\":1}}],[\"客户端自己需要有\",{\"1\":{\"80\":1}}],[\"客户端\",{\"1\":{\"80\":1,\"81\":1}}],[\"客户端调入内存里\",{\"1\":{\"80\":1}}],[\"客户端仍然使用\",{\"1\":{\"77\":1}}],[\"客户机接收到该服务器回应的\",{\"1\":{\"79\":1}}],[\"客户机在租期过去\",{\"1\":{\"79\":1}}],[\"欢迎它加入网络大家庭\",{\"1\":{\"78\":1}}],[\"收到了这个文件\",{\"1\":{\"81\":1}}],[\"收到客户机的\",{\"1\":{\"78\":1}}],[\"收录的汉字不足\",{\"1\":{\"58\":1}}],[\"收录了西欧常用字符\",{\"1\":{\"56\":1}}],[\"此表的大小由语料中的独立\",{\"1\":{\"168\":1}}],[\"此时它不知道网络的拓扑信息\",{\"1\":{\"232\":1}}],[\"此时\",{\"1\":{\"77\":1,\"232\":1}}],[\"此过程不可逆\",{\"1\":{\"19\":1}}],[\"谢谢你们的接纳\",{\"1\":{\"77\":1}}],[\"服务器会给\",{\"1\":{\"81\":1}}],[\"服务器请求计算机的配置信息\",{\"1\":{\"81\":1}}],[\"服务器请求下载这个文件\",{\"1\":{\"81\":1}}],[\"服务器将文件传给它\",{\"1\":{\"81\":1}}],[\"服务器上\",{\"1\":{\"81\":1}}],[\"服务器上下载某个文件\",{\"1\":{\"80\":1}}],[\"服务器下载启动文件\",{\"1\":{\"81\":1}}],[\"服务器在哪\",{\"1\":{\"80\":1}}],[\"服务器在哪呢\",{\"1\":{\"80\":1}}],[\"服务器的地址\",{\"1\":{\"80\":1,\"81\":1}}],[\"服务器\",{\"1\":{\"77\":1,\"81\":1}}],[\"服务器地址等\",{\"1\":{\"77\":1}}],[\"告诉其他\",{\"1\":{\"77\":1}}],[\"仍然使用广播地址作为目的地址\",{\"1\":{\"76\":1}}],[\"仍然表示之前的\",{\"1\":{\"55\":1}}],[\"新的字段即预处理函数返回的字典中的每个键\",{\"1\":{\"189\":1}}],[\"新的任务请求线程资源时\",{\"0\":{\"111\":1}}],[\"新人\",{\"1\":{\"76\":1,\"81\":1}}],[\"新来的机器使用\",{\"1\":{\"75\":1}}],[\"封装了\",{\"1\":{\"75\":1}}],[\"发起广播\",{\"1\":{\"232\":1}}],[\"发挥最大性能\",{\"1\":{\"111\":1}}],[\"发送数据包\",{\"1\":{\"232\":1}}],[\"发送包的时候\",{\"1\":{\"232\":1}}],[\"发送一个包\",{\"1\":{\"231\":1}}],[\"发送者\",{\"1\":{\"230\":2}}],[\"发送\",{\"1\":{\"79\":1,\"80\":1}}],[\"发送了一个广播包\",{\"1\":{\"75\":1}}],[\"发给客户机\",{\"1\":{\"78\":1}}],[\"发行版已经停止支持\",{\"1\":{\"71\":1}}],[\"我走我的\",{\"1\":{\"229\":1}}],[\"我来了\",{\"1\":{\"81\":1}}],[\"我来啦\",{\"1\":{\"75\":1}}],[\"我是\",{\"1\":{\"81\":1}}],[\"我是新来的\",{\"1\":{\"75\":1}}],[\"我没\",{\"1\":{\"75\":1}}],[\"我的\",{\"1\":{\"75\":1,\"214\":1,\"232\":1}}],[\"我们就增加了\",{\"1\":{\"223\":1}}],[\"我们就简单基于空格来进行词数统计\",{\"1\":{\"223\":1}}],[\"我们就可以在自己的数据集上微调模型了\",{\"1\":{\"192\":1}}],[\"我们就可以把数据划分成\",{\"1\":{\"130\":1}}],[\"我们就可以将这一组操作放在一块儿分析\",{\"1\":{\"89\":1}}],[\"我们看一下\",{\"1\":{\"214\":1}}],[\"我们仍然使用\",{\"1\":{\"201\":1}}],[\"我们假定你已经完成了这步\",{\"1\":{\"194\":1}}],[\"我们最终得到了\",{\"1\":{\"193\":1}}],[\"我们最终会得到一个非常大的词汇表\",{\"1\":{\"168\":1}}],[\"我们来看一下如何构建\",{\"1\":{\"193\":1}}],[\"我们来看一下代码实现\",{\"1\":{\"13\":1}}],[\"我们没有为\",{\"1\":{\"192\":1}}],[\"我们没有配置\",{\"1\":{\"192\":1}}],[\"我们快速回顾一下上一部分的预处理\",{\"1\":{\"191\":1}}],[\"我们已经将原数数据转化成模型可处理的\",{\"1\":{\"190\":1}}],[\"我们已经过如何使用\",{\"1\":{\"165\":1}}],[\"我们取了\",{\"1\":{\"190\":1}}],[\"我们得到了一个\",{\"1\":{\"188\":1}}],[\"我们无法将这个\",{\"1\":{\"179\":1}}],[\"我们对起初的代码进行修改\",{\"1\":{\"178\":1}}],[\"我们对小长度的序列进行了处理\",{\"1\":{\"177\":1}}],[\"我们在之前的代码上进行简单修改即可完成\",{\"1\":{\"202\":1}}],[\"我们在上一篇文章中介绍了\",{\"1\":{\"189\":1}}],[\"我们在使用\",{\"1\":{\"172\":1}}],[\"我们在拷贝或者合并对象时是希望对所有的属性做操作的\",{\"1\":{\"6\":1}}],[\"我们详细介绍下\",{\"1\":{\"161\":1}}],[\"我们通过三个步骤\",{\"1\":{\"160\":1}}],[\"我们通常可以选择\",{\"1\":{\"36\":1}}],[\"我们预测的是\",{\"1\":{\"160\":1}}],[\"我们分析的是两个句子\",{\"1\":{\"159\":1}}],[\"我们分别排序\",{\"1\":{\"126\":1}}],[\"我们将该列重命名为\",{\"1\":{\"222\":1}}],[\"我们将深入了解\",{\"1\":{\"217\":1}}],[\"我们将上面检验\",{\"1\":{\"197\":1}}],[\"我们将上面使用\",{\"1\":{\"158\":1}}],[\"我们将开始微调\",{\"1\":{\"192\":1}}],[\"我们将其进行\",{\"1\":{\"183\":1}}],[\"我们将\",{\"1\":{\"180\":1,\"189\":1}}],[\"我们将填充\",{\"1\":{\"179\":1}}],[\"我们将在\",{\"1\":{\"171\":1,\"192\":1}}],[\"我们将在未来在讨论其他参数\",{\"1\":{\"165\":1}}],[\"我们将使用\",{\"1\":{\"154\":1,\"187\":1}}],[\"我们使用刚刚建好的仓库\",{\"1\":{\"213\":1}}],[\"我们使用\",{\"1\":{\"159\":1,\"179\":1,\"189\":1,\"198\":1,\"219\":1,\"222\":1}}],[\"我们使用了\",{\"1\":{\"156\":1,\"184\":1}}],[\"我们使用人工标注的数据以有监督的方式进行精调\",{\"1\":{\"147\":1}}],[\"我们还会使用一些传统的\",{\"1\":{\"213\":1}}],[\"我们还会展示如何批处理多个句子\",{\"1\":{\"154\":1}}],[\"我们还需要自定义一个\",{\"1\":{\"168\":1}}],[\"我们还可以使用\",{\"1\":{\"223\":2}}],[\"我们还可以使用注意力遮罩层\",{\"1\":{\"152\":1}}],[\"我们还可以通过协调\",{\"1\":{\"109\":1}}],[\"我们简单介绍了\",{\"1\":{\"153\":1}}],[\"我们不妨加载已经训练好的模型\",{\"1\":{\"163\":1}}],[\"我们不希望模型关注它\",{\"1\":{\"152\":1}}],[\"我们不能使用同时运行两个\",{\"1\":{\"13\":1}}],[\"我们正在预测第4个单词\",{\"1\":{\"152\":1}}],[\"我们会在第\",{\"1\":{\"193\":1}}],[\"我们会喂给\",{\"1\":{\"152\":1}}],[\"我们会把前三个单词也作为输入\",{\"1\":{\"152\":1}}],[\"我们会将所有的功能在统一的位置进行\",{\"1\":{\"29\":1}}],[\"我们要尽量避免\",{\"1\":{\"133\":1}}],[\"我们希望\",{\"1\":{\"168\":1}}],[\"我们希望公平地处理每个排队的需求\",{\"1\":{\"111\":1}}],[\"我们希望遍历该对象获取该数字区间的值\",{\"1\":{\"13\":1}}],[\"我们遍历得到这个数据对应的结点\",{\"1\":{\"98\":1}}],[\"我们从链表头开始顺序遍历链表\",{\"1\":{\"98\":1}}],[\"我们维护一个有序单链表\",{\"1\":{\"98\":1}}],[\"我们才会使用这三种复杂度表示法来区分\",{\"1\":{\"88\":1}}],[\"我们循环执行\",{\"1\":{\"85\":1}}],[\"我们再出发执行一次真正的删除操作\",{\"1\":{\"82\":1}}],[\"我们需要稍微智能一点的设备\",{\"1\":{\"231\":1}}],[\"我们需要知道要进行多少\",{\"1\":{\"199\":1}}],[\"我们需要将文本转化成数字表示\",{\"1\":{\"189\":1}}],[\"我们需要思考以下问题\",{\"1\":{\"177\":1}}],[\"我们需要一个有序列分类\",{\"1\":{\"159\":1}}],[\"我们需要自动配置的协议\",{\"1\":{\"73\":1}}],[\"我们需要使用全局\",{\"1\":{\"7\":1}}],[\"我们平常用到的大多数常见字符\",{\"1\":{\"65\":1}}],[\"我们宁可把垃圾邮件标记为正常邮件\",{\"1\":{\"40\":1}}],[\"我们宁可把健康人误诊为癌症\",{\"1\":{\"40\":1}}],[\"我们应该使用\",{\"1\":{\"29\":1}}],[\"我们可能会很自然地想到\",{\"1\":{\"15\":1}}],[\"我们可以用集线器组网\",{\"1\":{\"231\":1}}],[\"我们可以用它们来微调对象的各个方面\",{\"1\":{\"10\":1}}],[\"我们可以看出数据集的一些特点了\",{\"1\":{\"222\":1}}],[\"我们可以看到模型需要的输入形式是\",{\"1\":{\"189\":1}}],[\"我们可以抽取一些样本来观察\",{\"1\":{\"222\":1}}],[\"我们可以直接通过\",{\"1\":{\"208\":1}}],[\"我们可以设置\",{\"1\":{\"200\":1}}],[\"我们可以在里面找到各种最新的模型和数据集\",{\"1\":{\"204\":1}}],[\"我们可以在多个\",{\"1\":{\"202\":1}}],[\"我们可以在\",{\"1\":{\"193\":1}}],[\"我们可以传递通过\",{\"1\":{\"192\":1}}],[\"我们可以验证一下\",{\"1\":{\"190\":1}}],[\"我们可以为\",{\"1\":{\"189\":1}}],[\"我们可以说\",{\"1\":{\"142\":1}}],[\"我们可以通过下标查看几个示例如\",{\"1\":{\"219\":1}}],[\"我们可以通过查看\",{\"1\":{\"160\":1}}],[\"我们可以通过一个数据结构\",{\"1\":{\"116\":1}}],[\"我们可以通过在代码中限制递归调用的最大深度的方式来解决这个问题\",{\"1\":{\"115\":1}}],[\"我们可以实现一个支持无限排队的无界队列\",{\"1\":{\"111\":1}}],[\"我们可以记录上次查找的位置\",{\"1\":{\"94\":1}}],[\"我们可以利用\",{\"1\":{\"16\":1}}],[\"我们可以迭代一部分\",{\"1\":{\"14\":1}}],[\"我们可以使用特殊的对象方法来实现字符串和数值转换\",{\"1\":{\"245\":1}}],[\"我们可以使用\",{\"1\":{\"13\":1,\"156\":1,\"182\":1,\"193\":1}}],[\"我们为对象增加一个名为\",{\"1\":{\"13\":1}}],[\"我们有这样一个对象\",{\"1\":{\"13\":1}}],[\"我们定义对象的时候\",{\"1\":{\"6\":1}}],[\"吼\",{\"1\":{\"75\":1,\"230\":1}}],[\"每eval\",{\"1\":{\"192\":1}}],[\"每\",{\"1\":{\"192\":1}}],[\"每一个集合中包含这样几列\",{\"1\":{\"188\":1}}],[\"每一层的定义\",{\"1\":{\"142\":1}}],[\"每一台新接入的机器都通过\",{\"1\":{\"73\":1}}],[\"每进入一个函数\",{\"1\":{\"136\":1}}],[\"每交换一次\",{\"1\":{\"120\":1}}],[\"每调用一个函数\",{\"1\":{\"115\":1}}],[\"每次处理的序列长度\",{\"1\":{\"158\":1}}],[\"每次从要排序的区间中随机选择一个元素作为分区点\",{\"1\":{\"133\":1}}],[\"每次从未排序区间中找到最小的元素\",{\"1\":{\"122\":1}}],[\"每次分区平均要扫描约\",{\"1\":{\"126\":1}}],[\"每次选择最后一个元素作为\",{\"1\":{\"126\":1}}],[\"每次遇到下雨\",{\"1\":{\"126\":1}}],[\"每次进行一次比较就可以确定插入位置\",{\"1\":{\"121\":1}}],[\"每次可以跨\",{\"1\":{\"114\":1}}],[\"每次查询是\",{\"1\":{\"94\":1}}],[\"每次删除并不进行数据的移动\",{\"1\":{\"82\":1}}],[\"每个\",{\"1\":{\"238\":1}}],[\"每个端口不管是否需要该包\",{\"1\":{\"231\":1}}],[\"每个句子对有一个标签来指明两个句子是否同义\",{\"1\":{\"187\":1}}],[\"每个字词都被分配了一个\",{\"1\":{\"168\":1}}],[\"每个模型输入的张量维度\",{\"1\":{\"158\":1}}],[\"每个桶内的数据值都是相同的\",{\"1\":{\"130\":1}}],[\"每个网络的主机数\",{\"1\":{\"70\":1}}],[\"每个平面上的编号空间有\",{\"1\":{\"64\":1}}],[\"源\",{\"1\":{\"72\":1,\"229\":1,\"230\":1}}],[\"周围的机器都是\",{\"1\":{\"72\":1}}],[\"包中包含客户端的\",{\"1\":{\"77\":1}}],[\"包就无法发送出去了\",{\"1\":{\"72\":1}}],[\"包括动态填充和\",{\"1\":{\"203\":1}}],[\"包括德法两国的字母\",{\"1\":{\"56\":1}}],[\"包括\",{\"1\":{\"6\":1,\"11\":2,\"147\":1}}],[\"他会选择其中一个\",{\"1\":{\"77\":1}}],[\"他才会发送\",{\"1\":{\"72\":1}}],[\"他的队列包括三个波段\",{\"1\":{\"71\":1}}],[\"他们对应的单字节编码的\",{\"1\":{\"59\":1}}],[\"稍微复杂一点\",{\"1\":{\"71\":1}}],[\"数值转换\",{\"1\":{\"245\":1}}],[\"数值上等于数组初始状态的逆序度\",{\"1\":{\"123\":1}}],[\"数字转字符串完全符合你的直觉\",{\"1\":{\"244\":1}}],[\"数字\",{\"1\":{\"243\":1}}],[\"数决定\",{\"1\":{\"168\":1}}],[\"数据结构中有最小生成树\",{\"1\":{\"233\":1}}],[\"数据报\",{\"1\":{\"229\":1}}],[\"数据链路层\",{\"0\":{\"228\":1}}],[\"数据\",{\"0\":{\"222\":1},\"1\":{\"229\":1}}],[\"数据加载器\",{\"0\":{\"196\":1}}],[\"数据预处理完成了\",{\"1\":{\"196\":1}}],[\"数据预处理\",{\"1\":{\"194\":1}}],[\"数据预处理的方式和之前介绍的一样\",{\"1\":{\"194\":1}}],[\"数据集不在\",{\"1\":{\"217\":1}}],[\"数据集预处理\",{\"0\":{\"189\":1}}],[\"数据集有关的\",{\"1\":{\"193\":1}}],[\"数据集有\",{\"1\":{\"187\":1}}],[\"数据集\",{\"1\":{\"187\":1}}],[\"数据量比较大\",{\"1\":{\"129\":1}}],[\"数据在各个桶之间的分布是比较均匀的\",{\"1\":{\"129\":1}}],[\"数据中心的管理员肯呢个一下子拿到几百台控的机器\",{\"1\":{\"80\":1}}],[\"数据包按照服务类型\",{\"1\":{\"71\":1}}],[\"数据包采用先进先出的方式通过队列\",{\"1\":{\"71\":1}}],[\"数组排序之后的数组\",{\"1\":{\"130\":1}}],[\"数组被分为三部分\",{\"1\":{\"127\":1}}],[\"数组的缺点是大小固定\",{\"1\":{\"96\":1}}],[\"数组的方法\",{\"0\":{\"21\":1}}],[\"数组简单易用\",{\"1\":{\"96\":1}}],[\"数组\",{\"0\":{\"82\":1,\"96\":1},\"1\":{\"130\":1}}],[\"数组本身\",{\"1\":{\"21\":1}}],[\"数组或值都行\",{\"1\":{\"21\":1}}],[\"数组可以逐项比较\",{\"1\":{\"20\":1}}],[\"数组没有\",{\"1\":{\"19\":1}}],[\"数组和字符串都是可迭代的\",{\"1\":{\"12\":1}}],[\"排队规则\",{\"1\":{\"71\":2}}],[\"排序算法\",{\"1\":{\"118\":1}}],[\"排序\",{\"0\":{\"118\":1},\"1\":{\"21\":1}}],[\"层\",{\"0\":{\"226\":1}}],[\"层中\",{\"1\":{\"160\":1}}],[\"层填好\",{\"1\":{\"72\":1}}],[\"层的概念\",{\"1\":{\"71\":1}}],[\"层面\",{\"1\":{\"45\":1}}],[\"该消息会到达机器\",{\"1\":{\"232\":1}}],[\"该设备每个口可以解析\",{\"1\":{\"231\":1}}],[\"该文件夹中包含\",{\"1\":{\"213\":1}}],[\"该文件中也有一些\",{\"1\":{\"164\":1}}],[\"该脚本可以在任何分布式设备上运行\",{\"1\":{\"202\":1}}],[\"该\",{\"1\":{\"187\":1,\"189\":1}}],[\"该过程通过\",{\"1\":{\"174\":1}}],[\"该句子中的全部字词\",{\"1\":{\"152\":1}}],[\"该网卡有广播地址\",{\"1\":{\"71\":1}}],[\"该属性值是个函数\",{\"1\":{\"12\":1}}],[\"呢\",{\"1\":{\"71\":1,\"72\":1}}],[\"往往会被分配到\",{\"1\":{\"71\":1}}],[\"套接字接口与内核通讯\",{\"1\":{\"71\":1}}],[\"旨在取代\",{\"1\":{\"71\":1}}],[\"社区已经对其停止维护\",{\"1\":{\"71\":1}}],[\"自编码\",{\"1\":{\"146\":1}}],[\"自回归\",{\"1\":{\"146\":1}}],[\"自\",{\"1\":{\"71\":1}}],[\"起源于\",{\"1\":{\"71\":1}}],[\"公有\",{\"1\":{\"70\":1}}],[\"网桥协议数据单元\",{\"1\":{\"233\":1}}],[\"网关和\",{\"1\":{\"76\":1}}],[\"网关需要和当前的网络至少一个网卡是同一个网段的\",{\"1\":{\"72\":1}}],[\"网卡可以发送多播包\",{\"1\":{\"71\":1}}],[\"网卡处于启动状态\",{\"1\":{\"71\":1}}],[\"网路号\",{\"1\":{\"70\":1}}],[\"网络管理员不仅能自动分配\",{\"1\":{\"80\":1}}],[\"网络管理员只需要配置一段共享的\",{\"1\":{\"73\":1}}],[\"网络设备的状态标识\",{\"1\":{\"71\":1}}],[\"网络号\",{\"1\":{\"70\":1}}],[\"网络数\",{\"1\":{\"70\":1}}],[\"网络地址位数\",{\"1\":{\"70\":1}}],[\"子问题解决了\",{\"1\":{\"125\":1}}],[\"子网掩码\",{\"1\":{\"70\":2,\"72\":1}}],[\"子集\",{\"1\":{\"45\":1}}],[\"广播问题\",{\"0\":{\"234\":1}}],[\"广播\",{\"1\":{\"227\":1}}],[\"广播数据包\",{\"1\":{\"77\":1}}],[\"广播包内容如下\",{\"1\":{\"75\":1}}],[\"广播包封装了\",{\"1\":{\"75\":1}}],[\"广播地址和网关地址\",{\"1\":{\"72\":1}}],[\"广播地址\",{\"1\":{\"70\":1}}],[\"广义加性模型\",{\"1\":{\"33\":1}}],[\"主动响应\",{\"1\":{\"232\":1}}],[\"主要差异在于他们的权重衰减正则化\",{\"1\":{\"198\":1}}],[\"主要由两部分组成\",{\"1\":{\"150\":1}}],[\"主要原因是\",{\"1\":{\"125\":1}}],[\"主要围绕以下四部分展开\",{\"1\":{\"30\":1}}],[\"主机号\",{\"1\":{\"70\":1}}],[\"保存\",{\"0\":{\"171\":1},\"1\":{\"171\":1}}],[\"保存方法\",{\"0\":{\"164\":1}}],[\"保存所有的\",{\"1\":{\"154\":1}}],[\"保留\",{\"1\":{\"70\":1}}],[\"保持\",{\"1\":{\"58\":1}}],[\"群播\",{\"1\":{\"70\":1}}],[\"私有\",{\"1\":{\"70\":2}}],[\"私用区相当于是可以由\",{\"1\":{\"65\":1}}],[\"剩余的位数\",{\"1\":{\"70\":1}}],[\"顺序\",{\"0\":{\"69\":1}}],[\"语言使用快速排序来实现排序函数\",{\"1\":{\"132\":1}}],[\"语言\",{\"1\":{\"96\":1}}],[\"语义\",{\"0\":{\"69\":1}}],[\"语法\",{\"0\":{\"69\":1},\"1\":{\"21\":1,\"29\":1}}],[\"协议地址长度\",{\"1\":{\"230\":1}}],[\"协议类型\",{\"1\":{\"230\":1}}],[\"协议告诉\",{\"1\":{\"81\":1}}],[\"协议分为客户端和服务器端\",{\"1\":{\"80\":1}}],[\"协议中还有个细节\",{\"1\":{\"80\":1}}],[\"协议\",{\"0\":{\"230\":1,\"233\":1},\"1\":{\"73\":1,\"74\":1,\"75\":1,\"81\":1,\"230\":1}}],[\"协议会涉及到\",{\"1\":{\"70\":1}}],[\"协议三要素\",{\"0\":{\"69\":1}}],[\"协议的设计仅能传输\",{\"1\":{\"48\":1}}],[\"趣谈网络协议\",{\"1\":{\"68\":1}}],[\"专栏\",{\"1\":{\"68\":1}}],[\"跟\",{\"1\":{\"67\":1}}],[\"跟ascii字符集\",{\"1\":{\"67\":1}}],[\"之前\",{\"1\":{\"195\":1}}],[\"之前我们用过\",{\"1\":{\"201\":1}}],[\"之前我们直接将\",{\"1\":{\"195\":1}}],[\"之前我们要先定义\",{\"1\":{\"192\":1}}],[\"之间\",{\"1\":{\"181\":1}}],[\"之间进行转换\",{\"1\":{\"66\":1}}],[\"之后全局变量下的\",{\"1\":{\"237\":1}}],[\"之后输出这些\",{\"1\":{\"193\":1}}],[\"之后进行评估\",{\"1\":{\"192\":1}}],[\"之后将会被填充到\",{\"1\":{\"190\":1}}],[\"之后\",{\"1\":{\"13\":1,\"70\":1,\"78\":1}}],[\"高维张量\",{\"0\":{\"158\":1}}],[\"高性能的排序函数\",{\"0\":{\"132\":1}}],[\"高\",{\"1\":{\"66\":1}}],[\"高端显卡等\",{\"1\":{\"42\":1}}],[\"代替\",{\"1\":{\"237\":1}}],[\"代码\",{\"1\":{\"120\":1,\"121\":1,\"122\":1,\"125\":1,\"126\":1,\"130\":1}}],[\"代码易理解\",{\"1\":{\"117\":1}}],[\"代码过于复杂\",{\"1\":{\"115\":1}}],[\"代码页\",{\"1\":{\"44\":1}}],[\"代理\",{\"1\":{\"65\":1}}],[\"官方示例时\",{\"1\":{\"192\":1}}],[\"官方示例\",{\"1\":{\"192\":1,\"222\":1}}],[\"官方之外的个人和机构自由定义字符的特殊区域\",{\"1\":{\"65\":1}}],[\"官方未将之分配给任何\",{\"1\":{\"65\":1}}],[\"分多个道\",{\"1\":{\"229\":1}}],[\"分别是\",{\"1\":{\"241\":1}}],[\"分别使用方法\",{\"1\":{\"171\":1}}],[\"分别接收两种语言的同一个句子\",{\"1\":{\"152\":1}}],[\"分别为\",{\"1\":{\"65\":1}}],[\"分区平衡\",{\"1\":{\"126\":1}}],[\"分区\",{\"1\":{\"126\":1}}],[\"分区点\",{\"1\":{\"126\":1}}],[\"分解成两个子数组排序的时间都是\",{\"1\":{\"125\":1}}],[\"分解成子问题\",{\"1\":{\"125\":1}}],[\"分治是一种处理思想\",{\"1\":{\"125\":1}}],[\"分治算法一般都用递归来实现\",{\"1\":{\"125\":1}}],[\"分排序空间和未排序空间\",{\"1\":{\"122\":1}}],[\"分析\",{\"1\":{\"114\":1,\"120\":1,\"121\":1}}],[\"分配的\",{\"1\":{\"77\":1}}],[\"分类\",{\"1\":{\"70\":1}}],[\"分数\",{\"0\":{\"40\":1}}],[\"共有\",{\"1\":{\"239\":1}}],[\"共享预训练模型\",{\"0\":{\"206\":1}}],[\"共享\",{\"0\":{\"204\":1}}],[\"共\",{\"1\":{\"65\":1,\"74\":1}}],[\"共6400个码点\",{\"1\":{\"65\":1}}],[\"共收录汉字\",{\"1\":{\"60\":1}}],[\"zone\",{\"1\":{\"65\":2}}],[\"zero\",{\"1\":{\"33\":1,\"47\":1,\"200\":1,\"202\":2}}],[\"称为码点名称或字符名称\",{\"1\":{\"67\":1}}],[\"称为为按字节编址\",{\"1\":{\"42\":1}}],[\"称之为保留区\",{\"1\":{\"65\":1}}],[\"尚未被分配字符\",{\"1\":{\"65\":1}}],[\"尚未涉及到物理层面上\",{\"1\":{\"46\":1}}],[\"远古时期的文字等\",{\"1\":{\"65\":1}}],[\"增加列\",{\"1\":{\"223\":1}}],[\"增加了大约一百个汉字及四位元组编码空间\",{\"1\":{\"61\":1}}],[\"增补平面要么用来表示一些非常特殊的字符\",{\"1\":{\"65\":1}}],[\"覆盖缓存中的\",{\"1\":{\"209\":1}}],[\"覆盖当今世界上正在使用中的常用字符\",{\"1\":{\"65\":1}}],[\"覆盖现有元素\",{\"1\":{\"21\":1}}],[\"概述\",{\"0\":{\"64\":1}}],[\"概念\",{\"0\":{\"33\":1}}],[\"除此之外\",{\"1\":{\"168\":1}}],[\"除保留全部\",{\"1\":{\"61\":1}}],[\"除了可以指定\",{\"1\":{\"209\":1}}],[\"除了数据规模不同\",{\"1\":{\"113\":1}}],[\"除了有后继指针\",{\"1\":{\"94\":1}}],[\"除了能得到\",{\"1\":{\"80\":1}}],[\"除了分配\",{\"1\":{\"80\":1}}],[\"除了需要确定的地址\",{\"1\":{\"71\":1}}],[\"除了汉字\",{\"1\":{\"59\":1}}],[\"除了最基本的美国使用的那\",{\"1\":{\"54\":1}}],[\"除了字符码点之外\",{\"1\":{\"45\":1}}],[\"除了\",{\"1\":{\"21\":1}}],[\"日推出了\",{\"1\":{\"61\":1}}],[\"日文\",{\"1\":{\"60\":1}}],[\"日文平假名及片假名字符\",{\"1\":{\"59\":1}}],[\"月推出\",{\"1\":{\"146\":1}}],[\"月\",{\"1\":{\"61\":1}}],[\"年起\",{\"1\":{\"71\":1}}],[\"年\",{\"1\":{\"61\":2,\"146\":1}}],[\"年被\",{\"1\":{\"53\":1}}],[\"微调模型\",{\"1\":{\"186\":1}}],[\"微调预训练模型\",{\"0\":{\"186\":1}}],[\"微调\",{\"1\":{\"149\":1}}],[\"微调对象\",{\"1\":{\"10\":1}}],[\"微软也为gb18030定义了专门的代码页\",{\"1\":{\"61\":1}}],[\"微软的cp936通常被视为等同于gbk\",{\"1\":{\"60\":1}}],[\"繁体字融于一体\",{\"1\":{\"60\":1}}],[\"符号位\",{\"1\":{\"239\":1}}],[\"符号\",{\"1\":{\"60\":1}}],[\"里面有一个\",{\"1\":{\"234\":1}}],[\"里面有给新人分配的地址\",{\"1\":{\"76\":1}}],[\"里面会指明内核在哪里\",{\"1\":{\"81\":1}}],[\"里面\",{\"1\":{\"77\":1,\"80\":1}}],[\"里\",{\"1\":{\"71\":1}}],[\"里的码点\",{\"1\":{\"64\":1}}],[\"里的码点数量要大于抽象字符表\",{\"1\":{\"45\":1}}],[\"里本来就有的数字\",{\"1\":{\"59\":1}}],[\"俄语西里尔字母在内的\",{\"1\":{\"59\":1}}],[\"希腊字母\",{\"1\":{\"59\":1}}],[\"希望尽量避免产生\",{\"1\":{\"40\":2}}],[\"同样收到了该广播包\",{\"1\":{\"232\":1}}],[\"同样\",{\"1\":{\"208\":1}}],[\"同样地\",{\"1\":{\"172\":1}}],[\"同一时刻仅允许一个存或取操作\",{\"1\":{\"110\":1}}],[\"同一个码元序列\",{\"1\":{\"49\":1}}],[\"同一个字符\",{\"1\":{\"49\":1}}],[\"同时也给它\",{\"1\":{\"81\":1}}],[\"同时为每个码点赋予了一个正式的名称\",{\"1\":{\"67\":1}}],[\"同时\",{\"1\":{\"59\":1}}],[\"后者是\",{\"1\":{\"241\":1}}],[\"后面章节再讲这个问题\",{\"1\":{\"234\":1}}],[\"后面的\",{\"1\":{\"71\":1}}],[\"后面的为低字节\",{\"1\":{\"59\":1}}],[\"后处理\",{\"0\":{\"160\":1},\"1\":{\"155\":1,\"160\":1}}],[\"后继指针\",{\"1\":{\"92\":1}}],[\"后\",{\"1\":{\"70\":1,\"139\":1,\"224\":1,\"232\":1}}],[\"后接十六进制数字表示\",{\"1\":{\"67\":1}}],[\"后来称为了英文字符编码工业标准\",{\"1\":{\"53\":1}}],[\"后来\",{\"1\":{\"53\":1}}],[\"前者是对象类型\",{\"1\":{\"241\":1}}],[\"前进\",{\"0\":{\"139\":1}}],[\"前缀位\",{\"1\":{\"70\":1}}],[\"前一字节为高字节\",{\"1\":{\"59\":1}}],[\"前面加\",{\"1\":{\"24\":1}}],[\"问题\",{\"1\":{\"58\":1,\"125\":1,\"230\":1}}],[\"冲突\",{\"1\":{\"58\":1}}],[\"指数位\",{\"1\":{\"239\":1}}],[\"指数阶\",{\"1\":{\"85\":1}}],[\"指定交换机\",{\"1\":{\"233\":1}}],[\"指从头开始训练模型\",{\"1\":{\"149\":1}}],[\"指针都会指向这个哨兵结点\",{\"1\":{\"103\":1}}],[\"指针指向空地址\",{\"1\":{\"92\":1}}],[\"指向\",{\"1\":{\"80\":1}}],[\"指的是\",{\"1\":{\"71\":1}}],[\"指的是前22位是网络号\",{\"1\":{\"70\":1}}],[\"指扩展\",{\"1\":{\"58\":1}}],[\"指二进制数中的一位\",{\"1\":{\"42\":1}}],[\"万\",{\"1\":{\"58\":1}}],[\"系在启动文件使用的是\",{\"1\":{\"81\":1}}],[\"系列虽然除\",{\"1\":{\"58\":1}}],[\"系列编码方案每次扩展都完全保留之前版本的编码\",{\"1\":{\"58\":1}}],[\"系列编码方案中\",{\"1\":{\"58\":1}}],[\"系统栈或者虚拟机栈空间一般都不大\",{\"1\":{\"115\":1}}],[\"系统可能没有足够的连续内存空间分配给它\",{\"1\":{\"96\":1}}],[\"系统调用去访问和改变内核网络配置\",{\"1\":{\"71\":1}}],[\"系统中没有\",{\"1\":{\"71\":1}}],[\"系统\",{\"0\":{\"10\":1}}],[\"首位各添加了一个\",{\"1\":{\"183\":1}}],[\"首位为\",{\"1\":{\"58\":1}}],[\"首先我们克隆远端仓库\",{\"1\":{\"213\":1}}],[\"首先创建\",{\"1\":{\"208\":1}}],[\"首先创建函数对输入进行\",{\"1\":{\"189\":1}}],[\"首先更新\",{\"1\":{\"192\":1}}],[\"首先\",{\"1\":{\"169\":1,\"213\":1,\"214\":1}}],[\"首先会判断\",{\"1\":{\"72\":1}}],[\"首字母\",{\"1\":{\"58\":1}}],[\"首页\",{\"0\":{\"0\":1}}],[\"国标\",{\"1\":{\"58\":1}}],[\"国际化和标准化程度不够\",{\"1\":{\"55\":1}}],[\"汉语\",{\"1\":{\"58\":1}}],[\"背景知识\",{\"0\":{\"146\":1}}],[\"背景\",{\"0\":{\"58\":1}}],[\"简述交换机学习网络拓扑信息的过程\",{\"1\":{\"232\":1}}],[\"简称平均时间复杂度\",{\"1\":{\"88\":1}}],[\"简称为进本平面\",{\"1\":{\"65\":1}}],[\"简\",{\"1\":{\"60\":1}}],[\"简体汉字编码方案\",{\"0\":{\"57\":1}}],[\"简介\",{\"0\":{\"32\":1}}],[\"未定义\",{\"1\":{\"56\":1,\"70\":8}}],[\"与栈顶的运算符进行比较\",{\"1\":{\"137\":1}}],[\"与插入点位置的元素交换\",{\"1\":{\"122\":1}}],[\"与\",{\"1\":{\"56\":1,\"85\":1,\"157\":1}}],[\"与特定计算机系统平台有关的存储方式\",{\"1\":{\"46\":1}}],[\"与特定的计算机系统平台无关的编码方式\",{\"1\":{\"46\":1}}],[\"十六进制\",{\"1\":{\"243\":1}}],[\"十数取中\",{\"1\":{\"133\":1}}],[\"十进制55296~57343\",{\"1\":{\"65\":1}}],[\"十进制\",{\"1\":{\"56\":1,\"65\":1,\"243\":1}}],[\"十字\",{\"1\":{\"42\":1}}],[\"目的\",{\"1\":{\"72\":1,\"75\":1,\"232\":1}}],[\"目的是用基本平面bmp中的两个码点\",{\"1\":{\"65\":1}}],[\"目前云计算厂商例绝对不止\",{\"1\":{\"234\":1}}],[\"目前支持的\",{\"1\":{\"144\":1}}],[\"目前unicode字符集的17个平面中尚有大量的保留区编号空间未被使用\",{\"1\":{\"65\":1}}],[\"目前共\",{\"1\":{\"65\":1}}],[\"目前\",{\"1\":{\"64\":1,\"213\":1}}],[\"目前使用最为普遍的是\",{\"1\":{\"56\":1}}],[\"目前已经被\",{\"1\":{\"55\":1}}],[\"目标\",{\"1\":{\"13\":1,\"229\":1,\"230\":3}}],[\"中有\",{\"1\":{\"239\":1}}],[\"中有如下信息\",{\"1\":{\"216\":1}}],[\"中还有一些\",{\"1\":{\"223\":1}}],[\"中还有一个被称为代理区\",{\"1\":{\"65\":1}}],[\"中包含了全部的\",{\"1\":{\"213\":1}}],[\"中增加\",{\"1\":{\"208\":1}}],[\"中对应的仓库上\",{\"1\":{\"208\":1}}],[\"中执行\",{\"1\":{\"202\":1}}],[\"中尝试\",{\"1\":{\"202\":1}}],[\"中使用\",{\"1\":{\"201\":1}}],[\"中我们介绍了如何使用\",{\"1\":{\"194\":1}}],[\"中详细介绍\",{\"1\":{\"192\":1}}],[\"中传递\",{\"1\":{\"192\":2,\"193\":1}}],[\"中前\",{\"1\":{\"190\":1}}],[\"中保存整个数据集\",{\"1\":{\"189\":1}}],[\"中加载数据集\",{\"0\":{\"188\":1}}],[\"中不仅有\",{\"1\":{\"187\":1}}],[\"中准备大型数据集\",{\"1\":{\"186\":1}}],[\"中已有对应示例\",{\"1\":{\"182\":1}}],[\"中获取\",{\"1\":{\"179\":1}}],[\"中讨论\",{\"1\":{\"171\":1}}],[\"中来讨论\",{\"1\":{\"171\":1}}],[\"中你已经看到了如何加载以及保存使用模型\",{\"1\":{\"165\":1}}],[\"中看到建立模型所需的属性\",{\"1\":{\"164\":1}}],[\"中查看它是如何训练的\",{\"1\":{\"205\":1}}],[\"中查看并下载\",{\"1\":{\"203\":1}}],[\"中查看更多示例\",{\"1\":{\"202\":1}}],[\"中查看\",{\"1\":{\"163\":1}}],[\"中心\",{\"1\":{\"144\":1}}],[\"中上传你自己的模型\",{\"1\":{\"143\":1}}],[\"中分别取出一个数\",{\"1\":{\"133\":1}}],[\"中采用堆排序来实现排序函数\",{\"1\":{\"132\":1}}],[\"中都是非负数\",{\"1\":{\"130\":1}}],[\"中递归查找\",{\"1\":{\"127\":1}}],[\"中继续递归查找\",{\"1\":{\"127\":1}}],[\"中点\",{\"1\":{\"99\":1}}],[\"中找指定元素\",{\"1\":{\"87\":1}}],[\"中\",{\"1\":{\"80\":1,\"139\":1,\"152\":1,\"165\":1,\"202\":1,\"216\":1,\"233\":1}}],[\"中工具的名字比较杂乱\",{\"1\":{\"71\":1}}],[\"中将\",{\"1\":{\"66\":1}}],[\"中日韩统一表意文字扩充\",{\"1\":{\"61\":2}}],[\"中国国家质量技术监督局于\",{\"1\":{\"61\":1}}],[\"中文繁体\",{\"1\":{\"60\":1}}],[\"中文汉字多达10万+\",{\"1\":{\"58\":1}}],[\"中闲置的最高位利用起来\",{\"1\":{\"55\":1}}],[\"中的几个基本类型\",{\"1\":{\"241\":1}}],[\"中的概念\",{\"1\":{\"233\":1}}],[\"中的最大长度\",{\"1\":{\"189\":1}}],[\"中的数据\",{\"1\":{\"189\":1}}],[\"中的数据集\",{\"1\":{\"188\":1}}],[\"中的数组提供的功能\",{\"1\":{\"82\":1}}],[\"中的说明或者使用页面上的\",{\"1\":{\"153\":1}}],[\"中的字符\",{\"1\":{\"65\":1}}],[\"中的字符数量\",{\"1\":{\"45\":1}}],[\"中的码点值\",{\"1\":{\"46\":1}}],[\"中的每个抽象字符表示为\",{\"1\":{\"45\":1}}],[\"中的\",{\"1\":{\"29\":1,\"153\":1,\"179\":1,\"195\":1,\"238\":1,\"239\":1}}],[\"形容词\",{\"1\":{\"141\":1}}],[\"形成了多个\",{\"1\":{\"54\":1}}],[\"形式\",{\"0\":{\"46\":1}}],[\"~\",{\"1\":{\"54\":1,\"163\":1,\"188\":1}}],[\"逐渐从美国发展到了欧洲\",{\"1\":{\"54\":1}}],[\"及\",{\"0\":{\"54\":1}}],[\"感觉上似乎有点怪\",{\"1\":{\"53\":1}}],[\"总计时长\",{\"1\":{\"193\":1}}],[\"总是知道应该是怎样的\",{\"1\":{\"183\":1}}],[\"总的时间复杂度是\",{\"1\":{\"131\":1}}],[\"总共\",{\"1\":{\"53\":1}}],[\"总结文本\",{\"1\":{\"141\":1}}],[\"总结\",{\"0\":{\"11\":1,\"17\":1,\"185\":1,\"203\":1}}],[\"制定为\",{\"1\":{\"53\":1}}],[\"采用的是多字节码元\",{\"1\":{\"58\":1}}],[\"采用\",{\"1\":{\"53\":1}}],[\"于1968年正式制定\",{\"1\":{\"53\":1}}],[\"于是这个广播信息不会广播到\",{\"1\":{\"232\":1}}],[\"于是这里我们没有启用多进程\",{\"1\":{\"189\":1}}],[\"于是一个\",{\"1\":{\"232\":1}}],[\"于是它也按照广播策略将包转发到\",{\"1\":{\"232\":1}}],[\"于是它将该广播包转发给除了广播包来的方向之外的其他所有网口\",{\"1\":{\"232\":1}}],[\"于是它只能将包发送给除了连接电脑\",{\"1\":{\"231\":1}}],[\"于是预训练模型的\",{\"1\":{\"192\":1}}],[\"于是构建每个单词到\",{\"1\":{\"168\":1}}],[\"于是我们将它输入至\",{\"1\":{\"160\":1}}],[\"于是我们不用\",{\"1\":{\"159\":1}}],[\"于是我们需要进行迁移学习\",{\"1\":{\"147\":1}}],[\"于是要先将文本输入转换成数字表示\",{\"1\":{\"156\":1}}],[\"于是双向链表在某些情况下的插入\",{\"1\":{\"94\":1}}],[\"于是平均时间复杂度的全称是加权平均时间复杂度或期望时间复杂度\",{\"1\":{\"88\":1}}],[\"于是又引入了平均情况时间复杂度\",{\"1\":{\"88\":1}}],[\"于是又有了\",{\"1\":{\"61\":1}}],[\"于是后来又设计了\",{\"1\":{\"66\":1}}],[\"于是后来又进行了扩展\",{\"1\":{\"58\":1}}],[\"于是欧洲各国纷纷打起了后面\",{\"1\":{\"54\":1}}],[\"于是\",{\"1\":{\"21\":1,\"40\":1}}],[\"于是数组被转换成了基本类型\",{\"1\":{\"20\":1}}],[\"美国信息交换标准码\",{\"1\":{\"53\":1}}],[\"大都在\",{\"1\":{\"181\":1}}],[\"大体上可以将\",{\"1\":{\"146\":1}}],[\"大很多\",{\"1\":{\"130\":1}}],[\"大的元素\",{\"1\":{\"127\":1}}],[\"大元素\",{\"1\":{\"127\":1}}],[\"大概满足\",{\"1\":{\"126\":1}}],[\"大问题也就解决了\",{\"1\":{\"125\":1}}],[\"大部分情况下时间复杂度都很低\",{\"1\":{\"89\":1}}],[\"大端\",{\"1\":{\"49\":1}}],[\"大写\",{\"1\":{\"34\":1}}],[\"大写粗体\",{\"1\":{\"34\":1}}],[\"小模型可能是768\",{\"1\":{\"158\":1}}],[\"小规模数据的排序可以用时间复杂度为\",{\"1\":{\"132\":1}}],[\"小端\",{\"1\":{\"49\":1}}],[\"小结\",{\"0\":{\"49\":1,\"62\":1,\"123\":1,\"153\":1,\"176\":1,\"184\":1}}],[\"小写\",{\"1\":{\"34\":2}}],[\"小写加粗\",{\"1\":{\"34\":1}}],[\"进一步进行适应性编码\",{\"1\":{\"48\":1}}],[\"进行托管\",{\"1\":{\"204\":1}}],[\"进行加速\",{\"0\":{\"202\":1}}],[\"进行评估\",{\"1\":{\"192\":1}}],[\"进行微调\",{\"0\":{\"191\":1}}],[\"进行微调可以有效降低时间\",{\"1\":{\"149\":1}}],[\"进行\",{\"1\":{\"189\":1}}],[\"进行截断\",{\"1\":{\"181\":1}}],[\"进行推理\",{\"0\":{\"165\":1}}],[\"进行预处理\",{\"0\":{\"156\":1},\"1\":{\"160\":1}}],[\"进行使用\",{\"1\":{\"153\":1}}],[\"进行运算后\",{\"1\":{\"137\":1}}],[\"进行原地分区\",{\"1\":{\"127\":1}}],[\"进行的\",{\"1\":{\"29\":1}}],[\"进行比较\",{\"1\":{\"21\":1,\"242\":1}}],[\"进行转换\",{\"1\":{\"19\":1}}],[\"进行操作\",{\"1\":{\"13\":1}}],[\"进行遍历的对象\",{\"1\":{\"17\":1}}],[\"进行遍历的都是\",{\"1\":{\"12\":1}}],[\"进行遍历时\",{\"1\":{\"12\":1}}],[\"进行访问\",{\"1\":{\"4\":1,\"11\":1}}],[\"打印\",{\"1\":{\"162\":1}}],[\"打破原来设计的几类地址的做法\",{\"1\":{\"70\":1}}],[\"打交道机会也比较少\",{\"1\":{\"47\":1}}],[\"打包到一起并进行优化以加速\",{\"1\":{\"25\":1}}],[\"第二层的网络包格式\",{\"1\":{\"229\":1}}],[\"第二层\",{\"0\":{\"228\":1}}],[\"第二层到第三层\",{\"0\":{\"225\":1}}],[\"第二步\",{\"1\":{\"192\":1}}],[\"第二步是将\",{\"1\":{\"172\":1}}],[\"第二个句子\",{\"1\":{\"160\":1}}],[\"第二个注意力层\",{\"1\":{\"152\":1}}],[\"第一层\",{\"0\":{\"227\":1}}],[\"第一步是克隆\",{\"1\":{\"214\":1}}],[\"第一步是将文本切分为\",{\"1\":{\"172\":1}}],[\"第一步\",{\"1\":{\"192\":1}}],[\"第一个句子\",{\"1\":{\"160\":1}}],[\"第一个注意力层关注所有\",{\"1\":{\"152\":1}}],[\"第一次需要遍历\",{\"1\":{\"127\":1}}],[\"第一次等于\",{\"1\":{\"21\":1}}],[\"第一类是第一步走了\",{\"1\":{\"114\":1}}],[\"第一种是非阻塞的处理方式\",{\"1\":{\"111\":1}}],[\"第\",{\"1\":{\"65\":1}}],[\"第五层的\",{\"1\":{\"47\":1}}],[\"程序员更多接触到的是\",{\"1\":{\"47\":1}}],[\"零宽度不中断空格\",{\"1\":{\"47\":1}}],[\"常数\",{\"1\":{\"118\":1}}],[\"常见\",{\"1\":{\"85\":1}}],[\"常量阶\",{\"1\":{\"85\":1}}],[\"常用的字符编码方式\",{\"1\":{\"46\":1}}],[\"常简称为字符集\",{\"1\":{\"45\":1}}],[\"虽然不能保证每次分区点都选得很好\",{\"1\":{\"133\":1}}],[\"虽然路过它的这个包\",{\"1\":{\"72\":1}}],[\"虽然也是多字节编码\",{\"1\":{\"58\":1}}],[\"虽然也被称为存储格式\",{\"1\":{\"46\":1}}],[\"虽然这不致命\",{\"1\":{\"40\":1}}],[\"要访问机器\",{\"1\":{\"232\":1}}],[\"要发送数据的机器发送一个广播包\",{\"1\":{\"230\":1}}],[\"要处理\",{\"1\":{\"169\":1}}],[\"要进行微调\",{\"1\":{\"149\":1}}],[\"要将其转化为非负整数\",{\"1\":{\"130\":1}}],[\"要比排序的数据\",{\"1\":{\"130\":1}}],[\"要排序的数据需要很容易就能划分成\",{\"1\":{\"129\":1}}],[\"要考虑的指标\",{\"1\":{\"118\":1}}],[\"要\",{\"1\":{\"92\":1}}],[\"要么被留作扩展之用\",{\"1\":{\"65\":1}}],[\"要解决的问题\",{\"1\":{\"46\":1}}],[\"要注意\",{\"1\":{\"15\":1,\"241\":1}}],[\"格式\",{\"0\":{\"46\":1}}],[\"ˋ\",{\"1\":{\"45\":1}}],[\"凉\",{\"1\":{\"45\":1}}],[\"标记法表示为\",{\"1\":{\"125\":1}}],[\"标点\",{\"1\":{\"59\":1}}],[\"标准化所有的\",{\"1\":{\"222\":1}}],[\"标准到目前为止实际上共定义了三个私用区\",{\"1\":{\"65\":1}}],[\"标准共收录\",{\"1\":{\"59\":1}}],[\"标准\",{\"1\":{\"53\":1,\"61\":1,\"67\":1,\"239\":1}}],[\"标准中\",{\"1\":{\"45\":1}}],[\"标量值\",{\"1\":{\"45\":1}}],[\"标量\",{\"1\":{\"33\":1,\"34\":2}}],[\"需要交换机会学习\",{\"1\":{\"231\":1}}],[\"需要传入一个可迭代的索引\",{\"1\":{\"222\":1}}],[\"需要使用\",{\"1\":{\"214\":1}}],[\"需要删掉\",{\"1\":{\"195\":1}}],[\"需要的输入\",{\"1\":{\"195\":1}}],[\"需要用到\",{\"1\":{\"193\":1}}],[\"需要用到全局注册表\",{\"1\":{\"4\":1,\"11\":1}}],[\"需要告诉\",{\"1\":{\"179\":1}}],[\"需要一个词表\",{\"1\":{\"172\":1}}],[\"需要与已排序空间的元素依次比较大小\",{\"1\":{\"121\":1}}],[\"需要进行大概\",{\"1\":{\"126\":1}}],[\"需要进行\",{\"1\":{\"120\":1}}],[\"需要考虑这部分的时间开销\",{\"1\":{\"116\":1}}],[\"需要更多的空间来存储前驱指针\",{\"1\":{\"94\":1}}],[\"需要配置\",{\"1\":{\"80\":1}}],[\"需要租给它一个\",{\"1\":{\"76\":1}}],[\"需要费一番功夫\",{\"1\":{\"72\":1}}],[\"需要对\",{\"1\":{\"48\":1}}],[\"需要根据上下文进行判断\",{\"1\":{\"45\":1}}],[\"还不知道\",{\"1\":{\"232\":1}}],[\"还将同一个词中的\",{\"1\":{\"175\":1}}],[\"还会加载或保存对应的词表\",{\"1\":{\"171\":1}}],[\"还会导致频繁的内存申请和释放\",{\"1\":{\"96\":1}}],[\"还提供了不同的架构\",{\"1\":{\"157\":1}}],[\"还需要有一个\",{\"1\":{\"81\":1}}],[\"还需要定位功能\",{\"1\":{\"71\":1}}],[\"还能知道\",{\"1\":{\"80\":1}}],[\"还能帮你自动安装操作系统\",{\"1\":{\"80\":1}}],[\"还要先定义几个对象\",{\"1\":{\"195\":1}}],[\"还要配置初始启动文件\",{\"1\":{\"80\":1}}],[\"还要自动安装系统\",{\"1\":{\"80\":1}}],[\"还可以使用\",{\"1\":{\"219\":1}}],[\"还可以做一些其他的事情\",{\"1\":{\"80\":1}}],[\"还可扩展为更多平面\",{\"1\":{\"64\":1}}],[\"还是\",{\"1\":{\"159\":1,\"239\":1}}],[\"还是上面查找元素在数组中的位置\",{\"1\":{\"88\":1}}],[\"还是需要广播一下\",{\"1\":{\"78\":1}}],[\"还是很罕见的\",{\"1\":{\"13\":1}}],[\"还回去\",{\"1\":{\"73\":1}}],[\"还支持\",{\"1\":{\"60\":1,\"243\":1}}],[\"还收录了包括拉丁字母\",{\"1\":{\"59\":1}}],[\"还有一些其他的参数\",{\"1\":{\"212\":1}}],[\"还有一些参数\",{\"1\":{\"209\":1}}],[\"还有很多\",{\"1\":{\"187\":1}}],[\"还有很多衍生的拉丁字母等字符\",{\"1\":{\"54\":1}}],[\"还有\",{\"1\":{\"142\":1}}],[\"还有前驱指针\",{\"1\":{\"94\":1}}],[\"还有非字符码点和保留码点\",{\"1\":{\"45\":1}}],[\"还经常会用\",{\"1\":{\"45\":1}}],[\"面\",{\"1\":{\"45\":1}}],[\"列\",{\"1\":{\"45\":1,\"223\":1}}],[\"存放小于\",{\"1\":{\"126\":1}}],[\"存储和传输\",{\"1\":{\"47\":2}}],[\"存储单元尺寸\",{\"1\":{\"45\":1}}],[\"存在重复计算\",{\"1\":{\"117\":1}}],[\"存在递归终止条件\",{\"1\":{\"113\":1}}],[\"存在\",{\"1\":{\"21\":1}}],[\"码的长度由\",{\"1\":{\"66\":1}}],[\"码的基础上利用了最高位\",{\"1\":{\"56\":1}}],[\"码中原本就有的单字节编码的字符\",{\"1\":{\"59\":1}}],[\"码混用时\",{\"1\":{\"58\":1}}],[\"码相同\",{\"1\":{\"58\":1}}],[\"码基本上被废弃了\",{\"1\":{\"55\":1}}],[\"码之外\",{\"1\":{\"54\":1}}],[\"码\",{\"0\":{\"51\":1,\"52\":1},\"1\":{\"53\":1,\"54\":1,\"58\":1}}],[\"码与\",{\"0\":{\"51\":1}}],[\"码元\",{\"1\":{\"46\":1}}],[\"码点名称\",{\"0\":{\"67\":1}}],[\"码点编号\",{\"1\":{\"46\":1,\"49\":1}}],[\"码点值\",{\"1\":{\"45\":2,\"49\":1,\"64\":1}}],[\"码点\",{\"1\":{\"45\":2}}],[\"码点空间中的位置\",{\"1\":{\"45\":1}}],[\"码点空间\",{\"1\":{\"45\":1,\"64\":1}}],[\"码空间\",{\"1\":{\"45\":1,\"64\":1}}],[\"由美国国家标准学会ansi\",{\"1\":{\"53\":1}}],[\"由于机器会不断上线下线\",{\"1\":{\"230\":1}}],[\"由于递归需要在内存栈中进行压栈出栈操作\",{\"1\":{\"116\":1}}],[\"由于没有操作系统\",{\"1\":{\"80\":1}}],[\"由于还没有得到\",{\"1\":{\"77\":1}}],[\"由于\",{\"1\":{\"76\":1}}],[\"由于历史原因\",{\"1\":{\"58\":1}}],[\"由于硬件平台与操作系统设计上的历史原因\",{\"1\":{\"47\":1}}],[\"由于它不是数组\",{\"1\":{\"21\":1}}],[\"由码点编号为u+0061的基本字符字母\",{\"1\":{\"45\":1}}],[\"由此产生了编号空间\",{\"1\":{\"45\":1}}],[\"非\",{\"1\":{\"239\":1}}],[\"非常费时\",{\"1\":{\"96\":1}}],[\"非多项式量级\",{\"1\":{\"85\":1}}],[\"非负整数值对\",{\"1\":{\"45\":1}}],[\"非数值大小\",{\"1\":{\"3\":1}}],[\"个值\",{\"1\":{\"239\":1}}],[\"个用户\",{\"1\":{\"234\":1}}],[\"个词的\",{\"1\":{\"223\":1}}],[\"个样本\",{\"1\":{\"222\":1}}],[\"个作为一个\",{\"1\":{\"190\":1}}],[\"个句子对\",{\"1\":{\"187\":1}}],[\"个不同文本分类任务中的性能\",{\"1\":{\"187\":1}}],[\"个不同的字节序列\",{\"1\":{\"49\":1}}],[\"个不同的字符编码模式\",{\"1\":{\"49\":1}}],[\"个单词\",{\"1\":{\"168\":1}}],[\"个操作数\",{\"1\":{\"137\":1}}],[\"个常用的比较简单的分区算法\",{\"1\":{\"133\":1}}],[\"个桶\",{\"1\":{\"129\":2,\"130\":1}}],[\"个数据\",{\"1\":{\"129\":2,\"130\":1}}],[\"个赋值操作\",{\"1\":{\"123\":1}}],[\"个或\",{\"1\":{\"114\":1}}],[\"个台阶的走法\",{\"1\":{\"114\":2}}],[\"个台阶的走法就等于先走\",{\"1\":{\"114\":1}}],[\"个台阶有多少种走法\",{\"1\":{\"114\":1}}],[\"个台阶\",{\"1\":{\"114\":4}}],[\"个条件\",{\"0\":{\"113\":1}}],[\"个结点\",{\"1\":{\"106\":1}}],[\"个增补平面\",{\"1\":{\"65\":1}}],[\"个平面称为基本多语言平面\",{\"1\":{\"65\":1}}],[\"个码点\",{\"1\":{\"64\":1,\"65\":1}}],[\"个字节长的\",{\"1\":{\"59\":1}}],[\"个字符中还包括了\",{\"1\":{\"59\":1}}],[\"个字符集大致上包括了欧洲各国所使用到的字符\",{\"1\":{\"56\":1}}],[\"个字符集\",{\"1\":{\"56\":1}}],[\"个字符\",{\"1\":{\"53\":1,\"58\":1,\"59\":1,\"238\":1}}],[\"个汉字\",{\"1\":{\"59\":1}}],[\"个大于\",{\"1\":{\"59\":1}}],[\"个大写英文字母\",{\"1\":{\"53\":1}}],[\"个编码定义了字符\",{\"1\":{\"56\":1}}],[\"个编码的主意\",{\"1\":{\"54\":1}}],[\"个\",{\"1\":{\"54\":2,\"56\":1,\"59\":1,\"60\":3,\"71\":1,\"168\":1,\"169\":1,\"181\":1,\"234\":1}}],[\"个坐标\",{\"1\":{\"45\":1}}],[\"个非负整数\",{\"1\":{\"45\":1}}],[\"个元素进行遍历\",{\"1\":{\"127\":1}}],[\"个元素进行分区操作\",{\"1\":{\"127\":1}}],[\"个元素所需要的时间是\",{\"1\":{\"125\":1}}],[\"个元素\",{\"1\":{\"21\":1,\"126\":1}}],[\"抽象\",{\"1\":{\"44\":1}}],[\"抽象字符表\",{\"0\":{\"44\":1}}],[\"具体配置可查看\",{\"1\":{\"216\":1}}],[\"具体是哪个字符\",{\"1\":{\"65\":1}}],[\"具体\",{\"1\":{\"44\":1}}],[\"无穷大\",{\"1\":{\"239\":1}}],[\"无穷迭代器\",{\"1\":{\"13\":1}}],[\"无法将数据全部加载到内存中\",{\"1\":{\"129\":1}}],[\"无论怎么优化\",{\"1\":{\"123\":1}}],[\"无论是半角的英文字母还是全角的汉字\",{\"1\":{\"66\":1}}],[\"无类型域间选路\",{\"1\":{\"70\":1}}],[\"无需指明字节序\",{\"1\":{\"47\":1}}],[\"无序\",{\"1\":{\"44\":1}}],[\"明确字符的范围\",{\"1\":{\"44\":1}}],[\"核心思想\",{\"1\":{\"42\":1}}],[\"再看一下\",{\"1\":{\"214\":1}}],[\"再观察结果\",{\"1\":{\"180\":1}}],[\"再将排好序的两部分合并在一起\",{\"1\":{\"125\":1}}],[\"再前接\",{\"1\":{\"102\":1}}],[\"再如\",{\"1\":{\"45\":1}}],[\"再进一步将字节序列进行适应性编码处理\",{\"1\":{\"42\":1}}],[\"再次读取\",{\"1\":{\"8\":1}}],[\"统一码\",{\"1\":{\"42\":1}}],[\"统计学习导论\",{\"0\":{\"31\":1}}],[\"编译器可以通过两个栈来实现四则运算\",{\"1\":{\"137\":1}}],[\"编号空间可以用以下方式进行描述\",{\"1\":{\"45\":1}}],[\"编号字符集\",{\"0\":{\"45\":1},\"1\":{\"46\":1}}],[\"编号就是该字符的编码\",{\"1\":{\"42\":1}}],[\"编码器接收输入并构建其表示\",{\"1\":{\"150\":1}}],[\"编码器\",{\"1\":{\"150\":1}}],[\"编码汉字之外\",{\"1\":{\"61\":1}}],[\"编码版本\",{\"1\":{\"59\":1}}],[\"编码方案在\",{\"1\":{\"61\":1}}],[\"编码方案\",{\"0\":{\"63\":1},\"1\":{\"54\":1,\"58\":1}}],[\"编码方案中\",{\"1\":{\"45\":1}}],[\"编码或者\",{\"1\":{\"48\":1}}],[\"编码后得到的码元序列\",{\"1\":{\"47\":1}}],[\"编码的完全兼容\",{\"1\":{\"66\":1}}],[\"编码的码元序列与字节序列都是相同的\",{\"1\":{\"47\":1}}],[\"编码的逆过程\",{\"1\":{\"42\":1}}],[\"编码\",{\"0\":{\"172\":1},\"1\":{\"42\":1,\"47\":2,\"48\":1,\"223\":1,\"238\":2}}],[\"传给\",{\"1\":{\"195\":1}}],[\"传递给\",{\"1\":{\"165\":1,\"197\":1}}],[\"传输的\",{\"1\":{\"48\":1}}],[\"传输编码语法\",{\"0\":{\"48\":1}}],[\"传统字符编码模型\",{\"1\":{\"42\":1}}],[\"传入多个句子\",{\"1\":{\"144\":1}}],[\"传入一个句子\",{\"1\":{\"144\":1}}],[\"传入\",{\"1\":{\"5\":1}}],[\"反应字符编码系统的构成特点和个构成部分之间相互关系的模型框架\",{\"1\":{\"42\":1}}],[\"嵌入式平台\",{\"1\":{\"42\":1}}],[\"桌面平台的处理器字长基本是\",{\"1\":{\"42\":1}}],[\"通信协议综述\",{\"0\":{\"68\":1}}],[\"通常开篇为简短的概述说明其用途\",{\"1\":{\"215\":1}}],[\"通常有一层或多层线性层组成\",{\"1\":{\"159\":1}}],[\"通常很大\",{\"1\":{\"158\":1}}],[\"通常也称为\",{\"1\":{\"80\":1}}],[\"通常用于指示字符串的结束\",{\"1\":{\"53\":1}}],[\"通常分为若干字节\",{\"1\":{\"42\":1}}],[\"通用字符集\",{\"1\":{\"42\":1}}],[\"通过本章的学习\",{\"1\":{\"176\":1}}],[\"通过\",{\"1\":{\"9\":2,\"47\":1,\"71\":1,\"81\":1,\"178\":1,\"229\":1}}],[\"因为将所有的数据\",{\"1\":{\"189\":1}}],[\"因为每个字词都是通过\",{\"1\":{\"169\":1}}],[\"因为需要遍历找到最小元素\",{\"1\":{\"122\":1}}],[\"因为最大允许的递归深度跟当前线程剩余的栈空间大小有关\",{\"1\":{\"115\":1}}],[\"因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针\",{\"1\":{\"96\":1}}],[\"因为可能要大量移动数据\",{\"1\":{\"82\":1}}],[\"因为此时请求分配\",{\"1\":{\"76\":1}}],[\"因为\",{\"1\":{\"66\":1,\"192\":1}}],[\"因为同时进行循环的情况下他们共享迭代状态\",{\"1\":{\"13\":1}}],[\"因而可根据需要由合作者之间私下协商将其分配给私有字符\",{\"1\":{\"65\":1}}],[\"因此它能够获得完整的输入句子来对当前词语进行最佳预测\",{\"1\":{\"152\":1}}],[\"因此私用区中的同一个码点\",{\"1\":{\"65\":1}}],[\"因此才既不可显示也不可能打印\",{\"1\":{\"53\":1}}],[\"因此剩下最高位的那1比特一般为0\",{\"1\":{\"53\":1}}],[\"因此字节一般也是存储器的最小存取单位以及处理器的最小寻址单位\",{\"1\":{\"42\":1}}],[\"因\",{\"1\":{\"49\":1}}],[\"因多个不同的字符编码方式\",{\"1\":{\"49\":1}}],[\"现在两台交换机都不了解网络的任何拓扑信息\",{\"1\":{\"232\":1}}],[\"现在我的工作路径中有一个\",{\"1\":{\"214\":1}}],[\"现在我们需要手动处理\",{\"1\":{\"195\":1}}],[\"现在我们不使用\",{\"1\":{\"194\":1}}],[\"现在我们可以定义\",{\"1\":{\"192\":1,\"193\":1}}],[\"现在我们有想要推到\",{\"1\":{\"213\":1}}],[\"现在我们有\",{\"1\":{\"29\":1}}],[\"现在你的仓库中有了全部所需的文件\",{\"1\":{\"208\":1}}],[\"现在你学会了如何微调\",{\"1\":{\"203\":1}}],[\"现在可以开始训练啦\",{\"1\":{\"200\":1}}],[\"现在可以将\",{\"1\":{\"165\":1}}],[\"现在来\",{\"1\":{\"72\":1}}],[\"现在\",{\"1\":{\"55\":1,\"190\":1}}],[\"现代字符编码模型分为了5个层次\",{\"1\":{\"43\":1}}],[\"现代字符编码模型\",{\"0\":{\"43\":1},\"1\":{\"42\":2}}],[\"现代\",{\"1\":{\"42\":1}}],[\"q++\",{\"1\":{\"125\":2}}],[\"q+1\",{\"1\":{\"125\":1}}],[\"q\",{\"0\":{\"111\":1},\"1\":{\"125\":5,\"127\":1,\"237\":1,\"238\":1}}],[\"qlen\",{\"1\":{\"71\":1}}],[\"qdisc\",{\"1\":{\"71\":5}}],[\"quick\",{\"0\":{\"126\":1},\"1\":{\"126\":8}}],[\"queue\",{\"1\":{\"111\":2}}],[\"queueing\",{\"1\":{\"71\":1}}],[\"quoted\",{\"1\":{\"48\":1}}],[\"quad\",{\"1\":{\"42\":1}}],[\"qualitative\",{\"1\":{\"33\":1}}],[\"quantitative\",{\"1\":{\"33\":1}}],[\"qword\",{\"1\":{\"42\":1}}],[\"四字\",{\"1\":{\"42\":1}}],[\"半字节\",{\"1\":{\"42\":1}}],[\"又能将\",{\"1\":{\"208\":1}}],[\"又提出了第三种方式\",{\"1\":{\"169\":1}}],[\"又可以分为两种情况\",{\"1\":{\"98\":1}}],[\"又编入了\",{\"1\":{\"59\":1}}],[\"又进一步引发了更为麻烦的字节序\",{\"1\":{\"58\":1}}],[\"又支持各国所使用的那些衍生字段的单字节编码方案\",{\"1\":{\"54\":1}}],[\"又先后设计了两套统一的技能兼容\",{\"1\":{\"54\":1}}],[\"又称位元组\",{\"1\":{\"42\":1}}],[\"又有命名实体\",{\"0\":{\"28\":1}}],[\"字段时\",{\"1\":{\"223\":1}}],[\"字段包含\",{\"1\":{\"193\":1}}],[\"字段\",{\"1\":{\"190\":1}}],[\"字母等字符\",{\"1\":{\"59\":1}}],[\"字符串转换\",{\"1\":{\"245\":1}}],[\"字符串表示是用科学计数法\",{\"1\":{\"244\":1}}],[\"字符串\",{\"1\":{\"238\":1}}],[\"字符串是否有最大长度\",{\"1\":{\"238\":1}}],[\"字符串迭代器可以正确处理\",{\"1\":{\"17\":1}}],[\"字符就是半角字符\",{\"1\":{\"59\":1}}],[\"字符外的其余字符位多字节编码\",{\"1\":{\"58\":1}}],[\"字符为单字节编码\",{\"1\":{\"58\":1}}],[\"字符编号\",{\"1\":{\"46\":1,\"49\":1}}],[\"字符编号不完全等同于码点编号\",{\"1\":{\"45\":1}}],[\"字符编码之处\",{\"1\":{\"66\":1}}],[\"字符编码方案包括了一组字符集\",{\"1\":{\"56\":1}}],[\"字符编码方案只包括单个独立的字符集不同\",{\"1\":{\"56\":1}}],[\"字符编码方案取代了\",{\"1\":{\"55\":1}}],[\"字符编码方案\",{\"0\":{\"54\":1}}],[\"字符编码方式\",{\"0\":{\"46\":1},\"1\":{\"66\":1}}],[\"字符编码模式ces\",{\"0\":{\"47\":1}}],[\"字符编码模型\",{\"1\":{\"42\":1}}],[\"字符编码等早期广泛应用的编码方案\",{\"1\":{\"46\":1}}],[\"字符编码\",{\"0\":{\"50\":1},\"1\":{\"42\":1,\"46\":1,\"222\":1}}],[\"字符码点又称为\",{\"1\":{\"45\":1}}],[\"字符表可以是封闭的\",{\"1\":{\"44\":1}}],[\"字符不具有特定的字形\",{\"1\":{\"44\":1}}],[\"字符\",{\"1\":{\"44\":1,\"48\":1,\"53\":2,\"55\":1,\"65\":1,\"66\":1}}],[\"字符集为每个字符根据其所在的码点分配了唯一的码点值\",{\"1\":{\"67\":1}}],[\"字符集\",{\"1\":{\"42\":1,\"46\":1,\"56\":1,\"67\":1}}],[\"字的长度\",{\"1\":{\"42\":1}}],[\"字长由\",{\"1\":{\"42\":1}}],[\"字长\",{\"1\":{\"42\":1}}],[\"字与字长\",{\"1\":{\"42\":1}}],[\"字\",{\"1\":{\"42\":2}}],[\"字节序列\",{\"1\":{\"47\":1}}],[\"字节序的大端序与小端序等\",{\"1\":{\"42\":1}}],[\"字节流\",{\"1\":{\"47\":1,\"48\":1}}],[\"字节\",{\"1\":{\"42\":2,\"58\":1,\"71\":1,\"238\":1}}],[\"亦称二进制位\",{\"1\":{\"42\":1}}],[\"位表示\",{\"1\":{\"239\":1}}],[\"位是主机号\",{\"1\":{\"70\":1}}],[\"位永远是\",{\"1\":{\"66\":1}}],[\"位扩展为\",{\"1\":{\"66\":1}}],[\"位二进制表示一个字符\",{\"1\":{\"53\":1}}],[\"位数\",{\"1\":{\"42\":1}}],[\"位组\",{\"1\":{\"42\":1}}],[\"位串\",{\"1\":{\"42\":1}}],[\"位元组顺序\",{\"1\":{\"47\":1}}],[\"位元\",{\"1\":{\"42\":1}}],[\"位\",{\"1\":{\"42\":3,\"48\":1,\"66\":1,\"131\":1}}],[\"位置\",{\"1\":{\"21\":1}}],[\"刨根问底字符编码\",{\"1\":{\"41\":1,\"50\":1,\"63\":1}}],[\"术语\",{\"0\":{\"41\":1,\"142\":1}}],[\"尽可能提高precision值\",{\"1\":{\"40\":1}}],[\"尽可能提高recall值\",{\"1\":{\"40\":1}}],[\"癌症诊断系统的目标是\",{\"1\":{\"40\":1}}],[\"癌症诊断场景中\",{\"1\":{\"40\":1}}],[\"应该怎么办\",{\"1\":{\"217\":1}}],[\"应该忽略它\",{\"1\":{\"180\":1}}],[\"应该着重考虑提高precision指标\",{\"1\":{\"40\":1}}],[\"应该着重考虑提高recall指标\",{\"1\":{\"40\":1}}],[\"应该是\",{\"1\":{\"6\":1}}],[\"^first\",{\"1\":{\"40\":1}}],[\"使得同时对数据集中的多个元素同时做处理\",{\"1\":{\"189\":1}}],[\"使得用户可以通过它来加载\",{\"1\":{\"154\":1}}],[\"使其和最长的序列一样长\",{\"1\":{\"179\":1}}],[\"使其成为准确性指标的替代方案\",{\"1\":{\"40\":1}}],[\"使用单独的交换机配置单独的子网\",{\"1\":{\"234\":1}}],[\"使用制表符作为分隔符\",{\"1\":{\"222\":1}}],[\"使用预训练模型时\",{\"1\":{\"205\":1}}],[\"使用预训练模型\",{\"0\":{\"205\":1}}],[\"使用的\",{\"1\":{\"214\":2}}],[\"使用的默认\",{\"1\":{\"192\":1}}],[\"使用的算法\",{\"1\":{\"171\":1}}],[\"使用其他的\",{\"1\":{\"189\":1}}],[\"使用不同的\",{\"1\":{\"189\":1}}],[\"使用了\",{\"1\":{\"184\":1}}],[\"使用了来自\",{\"1\":{\"152\":1}}],[\"使用该类需要安装\",{\"1\":{\"213\":1}}],[\"使用该方法会加载或保存\",{\"1\":{\"171\":1}}],[\"使用该函数可以直接根据输入返回目标输出\",{\"1\":{\"144\":1}}],[\"使用这种方式\",{\"1\":{\"170\":2}}],[\"使用默认的配置来创建\",{\"1\":{\"163\":1}}],[\"使用模型的\",{\"1\":{\"156\":1}}],[\"使用模型进行预测时使用的上述操作应该和预训练时的操作一致\",{\"1\":{\"156\":1}}],[\"使用注意力层\",{\"1\":{\"152\":1}}],[\"使用更小的数据集完成\",{\"1\":{\"149\":1}}],[\"使用两个栈来实现\",{\"1\":{\"139\":1}}],[\"使用两个字节的码元\",{\"1\":{\"66\":1}}],[\"使用条件很苛刻\",{\"1\":{\"129\":1}}],[\"使用带头链表之后\",{\"1\":{\"103\":1}}],[\"使用gb类编码方案时一般都要时刻记住\",{\"1\":{\"62\":1}}],[\"使用分类器做预测后\",{\"1\":{\"36\":1}}],[\"使用现代构建工具\",{\"1\":{\"25\":1}}],[\"使用\",{\"0\":{\"26\":1,\"154\":1,\"156\":1,\"165\":1,\"191\":1,\"194\":1,\"202\":1,\"208\":1,\"209\":1,\"210\":1},\"1\":{\"6\":2,\"11\":1,\"17\":1,\"21\":1,\"28\":2,\"29\":2,\"73\":1,\"74\":1,\"156\":1,\"160\":1,\"164\":1,\"168\":1,\"179\":1,\"185\":1,\"202\":1,\"203\":1,\"206\":2,\"208\":1,\"212\":1,\"217\":1,\"222\":1,\"240\":1,\"243\":1}}],[\"使用字符串做\",{\"1\":{\"4\":1,\"240\":1}}],[\"使用它们可以修改一些内建行为\",{\"1\":{\"4\":1,\"11\":1}}],[\"召回率\",{\"0\":{\"39\":1}}],[\"真实positve的数据到底占多少\",{\"1\":{\"38\":1}}],[\"精确度\",{\"0\":{\"38\":1}}],[\"把原数组拷贝进去\",{\"1\":{\"96\":1}}],[\"把每种情况下要遍历的元素的个数累加起来再除以\",{\"1\":{\"88\":1}}],[\"把\",{\"1\":{\"80\":1}}],[\"把数据包加入队列\",{\"1\":{\"71\":1}}],[\"把字节序列映射到一套更受限制的值域内\",{\"1\":{\"48\":1}}],[\"把正样本错误的预测为负\",{\"1\":{\"36\":1}}],[\"把正样本成功预测为正\",{\"1\":{\"36\":1}}],[\"把负样本错误地预测为正\",{\"1\":{\"36\":1}}],[\"把负样本成功预测为负\",{\"1\":{\"36\":1}}],[\"一共12位\",{\"1\":{\"234\":1}}],[\"一次冒泡\",{\"1\":{\"120\":1}}],[\"一次操作实际处理的比特位数量\",{\"1\":{\"42\":1}}],[\"一直压入栈\",{\"1\":{\"115\":1}}],[\"一经声明就要占用整块连续内存空间\",{\"1\":{\"96\":1}}],[\"一块连续的内存空间\",{\"1\":{\"82\":1}}],[\"一旦配置好\",{\"1\":{\"73\":1}}],[\"一旦跨网\",{\"1\":{\"71\":1}}],[\"一一对应于编号空间\",{\"1\":{\"64\":1}}],[\"一些概念\",{\"1\":{\"92\":1}}],[\"一些\",{\"1\":{\"71\":1}}],[\"一些生僻字被编到了\",{\"1\":{\"58\":1}}],[\"一些标记\",{\"1\":{\"34\":1}}],[\"一样\",{\"1\":{\"56\":1}}],[\"一般在输出的时候进行\",{\"1\":{\"245\":1}}],[\"一般被认为是设计失误\",{\"1\":{\"242\":1}}],[\"一般用\",{\"1\":{\"168\":1}}],[\"一般都会选择时间复杂度是\",{\"1\":{\"132\":1}}],[\"一般都是网络管理员分配\",{\"1\":{\"72\":1}}],[\"一般都是位于\",{\"1\":{\"65\":1}}],[\"一般都是相同的\",{\"1\":{\"49\":1}}],[\"一般有两种策略\",{\"1\":{\"111\":1}}],[\"一般有两种处理方式\",{\"1\":{\"48\":1}}],[\"一般均摊时间复杂度就等于最好情况时间复杂度\",{\"1\":{\"89\":1}}],[\"一般是最先到达的那个\",{\"1\":{\"77\":1}}],[\"一般不和它直接打交道\",{\"1\":{\"47\":1}}],[\"一般编号字符集\",{\"1\":{\"45\":1}}],[\"一般翻译为代码空间\",{\"1\":{\"45\":1}}],[\"一般来说\",{\"1\":{\"42\":1}}],[\"一般以字节为单位\",{\"1\":{\"42\":1}}],[\"一连串的位\",{\"1\":{\"42\":1}}],[\"一个交换机上会连属于多个局域网的机器\",{\"1\":{\"234\":1}}],[\"一个栈用来保存运算符\",{\"1\":{\"137\":1}}],[\"一个栈用来保存操作数\",{\"1\":{\"137\":1}}],[\"一个问题的解可以分解为几个子问题的解\",{\"1\":{\"113\":1}}],[\"一个为如上所述的bmp中的\",{\"1\":{\"65\":1}}],[\"一个汉字由两个字节组成\",{\"1\":{\"62\":1}}],[\"一个汉字的编码\",{\"1\":{\"59\":1}}],[\"一个抽象字符可能对应多个码点\",{\"1\":{\"45\":1}}],[\"一个字符占用的码点所在的坐标或非负整数\",{\"1\":{\"45\":1}}],[\"一个文件下面有很多\",{\"1\":{\"29\":1}}],[\"一个是基本类型\",{\"1\":{\"20\":1}}],[\"一个有\",{\"1\":{\"13\":1}}],[\"矩阵\",{\"1\":{\"34\":2}}],[\"year\",{\"1\":{\"222\":1}}],[\"your\",{\"1\":{\"214\":1,\"222\":2}}],[\"you\",{\"1\":{\"144\":1,\"222\":1}}],[\"y\",{\"1\":{\"37\":2,\"38\":2,\"39\":2,\"40\":2,\"45\":2}}],[\"y=​y1​y2​⋮yn​​​\",{\"1\":{\"34\":1}}],[\"yi​\",{\"1\":{\"34\":1}}],[\"xor\",{\"1\":{\"229\":1}}],[\"xanax\",{\"1\":{\"222\":1}}],[\"xl\",{\"1\":{\"150\":1}}],[\"x1​​x1​​⋯​xp​​\",{\"1\":{\"34\":1}}],[\"x=\",{\"1\":{\"34\":1}}],[\"x=​x1t​x2t​⋮xnt​​​\",{\"1\":{\"34\":1}}],[\"x=​x11​x21​⋮xn1​​x12​x22​⋮xn2​​⋯⋯⋱⋯​x1p​x1p​⋮xnp​​​\",{\"1\":{\"34\":1}}],[\"xj​=​x1​jx2​j⋮xn​j​​\",{\"1\":{\"34\":1}}],[\"xj​\",{\"1\":{\"34\":1}}],[\"xi​=​xi​1xi​2⋮xi​p​​\",{\"1\":{\"34\":1}}],[\"xi​\",{\"1\":{\"34\":1}}],[\"xi​j\",{\"1\":{\"34\":1}}],[\"x\",{\"1\":{\"34\":3,\"45\":4,\"72\":1,\"87\":3,\"190\":2,\"222\":2,\"223\":4,\"239\":1}}],[\"多写多练\",{\"0\":{\"106\":1}}],[\"多项式量级\",{\"1\":{\"85\":1}}],[\"多半只有专家在历史和科学领域里才会用到它们\",{\"1\":{\"65\":1}}],[\"多出了\",{\"1\":{\"60\":1}}],[\"多字节字符与\",{\"1\":{\"58\":1}}],[\"多分类模型accuracy\",{\"1\":{\"40\":1}}],[\"多重假设检验\",{\"1\":{\"33\":1}}],[\"多维数组\",{\"1\":{\"19\":1}}],[\"kn\",{\"1\":{\"131\":1}}],[\"klogk\",{\"1\":{\"129\":1}}],[\"k=log2​n\",{\"1\":{\"125\":1}}],[\"k\",{\"1\":{\"33\":2,\"34\":1,\"58\":1,\"85\":1,\"116\":2,\"125\":1,\"127\":5,\"129\":1,\"130\":3,\"131\":3,\"132\":1,\"190\":5,\"196\":2,\"200\":2,\"201\":2,\"202\":2}}],[\"keys\",{\"1\":{\"6\":2,\"11\":1,\"222\":1}}],[\"keyfor\",{\"0\":{\"9\":1},\"1\":{\"4\":1,\"9\":3,\"11\":1}}],[\"key\",{\"0\":{\"8\":1},\"1\":{\"2\":7,\"4\":2,\"6\":3,\"8\":3,\"11\":1,\"19\":2,\"103\":8,\"240\":2}}],[\">对象的转换\",{\"0\":{\"246\":1}}],[\">基本类型的转换\",{\"0\":{\"245\":1}}],[\">\",{\"1\":{\"33\":3,\"40\":2,\"71\":3,\"103\":7,\"115\":1,\"118\":1,\"120\":1,\"121\":1,\"123\":2,\"127\":1,\"223\":1}}],[\">=\",{\"1\":{\"21\":1,\"121\":1,\"125\":2,\"126\":2,\"130\":1}}],[\"最开始交换机并不知道电脑\",{\"1\":{\"231\":1}}],[\"最开始是为了翻译任务而设计的\",{\"1\":{\"152\":1}}],[\"最难的步骤大概是为\",{\"1\":{\"191\":1}}],[\"最后\",{\"1\":{\"214\":1}}],[\"最后一项任务就是在每个\",{\"1\":{\"189\":1}}],[\"最后让我们看一看如何使用\",{\"1\":{\"184\":1}}],[\"最初的\",{\"1\":{\"152\":1}}],[\"最理想的分区点应该使得两个分区中的数据数量差不多多\",{\"1\":{\"133\":1}}],[\"最差\",{\"1\":{\"126\":1}}],[\"最终代码\",{\"1\":{\"114\":1}}],[\"最终租约达成的时候\",{\"1\":{\"78\":1}}],[\"最近最少使用\",{\"1\":{\"98\":1}}],[\"最坏情况出现的主要原因是分区点选得不够合理\",{\"1\":{\"133\":1}}],[\"最坏情况下\",{\"1\":{\"120\":1}}],[\"最坏情况时间复杂度\",{\"0\":{\"87\":1}}],[\"最坏\",{\"0\":{\"86\":1},\"1\":{\"118\":1,\"120\":1,\"121\":1,\"122\":1,\"123\":1}}],[\"最好是要统计一下字数\",{\"1\":{\"223\":1}}],[\"最好情况下初始有序度是\",{\"1\":{\"120\":1}}],[\"最好情况和最坏情况都是极端情况下的代码复杂度\",{\"1\":{\"88\":1}}],[\"最好情况时间复杂度\",{\"0\":{\"87\":1}}],[\"最好\",{\"0\":{\"86\":1},\"1\":{\"118\":1,\"120\":1,\"121\":1,\"122\":1,\"123\":1,\"126\":1}}],[\"最好和文件同名\",{\"1\":{\"28\":1}}],[\"最简单的方式就是在定义\",{\"1\":{\"208\":1}}],[\"最简单的实现方式是直接在\",{\"1\":{\"110\":1}}],[\"最简单的\",{\"1\":{\"71\":1}}],[\"最大传输单元\",{\"1\":{\"71\":1}}],[\"最大的特点是两字节长的中文字符和一字节长的英文字符\",{\"1\":{\"62\":1}}],[\"最小二乘法\",{\"1\":{\"33\":1}}],[\"误差项\",{\"1\":{\"33\":1}}],[\"获得\",{\"1\":{\"31\":1,\"165\":2}}],[\"获取机器\",{\"1\":{\"232\":1}}],[\"获取目的\",{\"1\":{\"232\":1}}],[\"获取评论的情绪\",{\"1\":{\"141\":1}}],[\"获取索引\",{\"1\":{\"19\":1}}],[\"获取\",{\"1\":{\"9\":2,\"72\":1}}],[\"获取以及注册\",{\"1\":{\"4\":1,\"11\":1}}],[\"访问\",{\"1\":{\"31\":1}}],[\"书是开源的\",{\"1\":{\"31\":1}}],[\"读书笔记\",{\"0\":{\"31\":1}}],[\"读取\",{\"0\":{\"8\":1,\"9\":1}}],[\"🤗\",{\"0\":{\"144\":1,\"154\":1,\"202\":1,\"217\":1},\"1\":{\"30\":4,\"144\":1,\"153\":1,\"154\":1,\"157\":3,\"160\":1,\"164\":1,\"178\":1,\"186\":1,\"188\":1,\"189\":2,\"190\":1,\"191\":1,\"192\":2,\"193\":1,\"201\":1,\"202\":3,\"203\":1,\"204\":1,\"212\":1,\"217\":2,\"218\":1,\"219\":1,\"222\":2}}],[\"本章我们将介绍其他函数\",{\"1\":{\"222\":1}}],[\"本节内容介绍了\",{\"1\":{\"153\":1}}],[\"本质并没有改变\",{\"1\":{\"117\":1}}],[\"本系列文章是对知乎专栏\",{\"1\":{\"41\":1,\"50\":1,\"63\":1}}],[\"本篇文章记录了一些相关概念以及\",{\"1\":{\"32\":1}}],[\"本模块用于记录\",{\"1\":{\"30\":1}}],[\"本身没有\",{\"1\":{\"13\":1}}],[\"介绍\",{\"0\":{\"30\":1,\"141\":1}}],[\"会产生对象\",{\"1\":{\"241\":1}}],[\"会更容易产生冲突\",{\"1\":{\"231\":1}}],[\"会撑爆你的\",{\"1\":{\"217\":1}}],[\"会在每次保存\",{\"1\":{\"208\":1}}],[\"会在之后介绍\",{\"1\":{\"156\":1}}],[\"会帮你处理设备的问题\",{\"1\":{\"202\":1}}],[\"会帮助模型获得正确的翻译\",{\"1\":{\"151\":1}}],[\"会跟着\",{\"1\":{\"201\":1}}],[\"会输出一次\",{\"1\":{\"192\":1}}],[\"会将尽量少的字词标记为\",{\"1\":{\"168\":1}}],[\"会被分别构建不同的\",{\"1\":{\"168\":1}}],[\"会被随机初始化\",{\"1\":{\"163\":1}}],[\"会被略过\",{\"1\":{\"6\":1,\"11\":1}}],[\"会使用填充的方式使句子长度保持一致\",{\"1\":{\"152\":1}}],[\"会有多个线程同时操作队列\",{\"1\":{\"110\":1}}],[\"会有不同的码元序列\",{\"1\":{\"49\":1}}],[\"会根据包中提供的新租期以及其他更新的\",{\"1\":{\"79\":1}}],[\"会广播返回给客户机一个\",{\"1\":{\"78\":1}}],[\"会为此客户保留为它提供的\",{\"1\":{\"76\":1}}],[\"会获取网关的\",{\"1\":{\"72\":1}}],[\"会让计算机发出哔的一声\",{\"1\":{\"53\":1}}],[\"会忽略\",{\"1\":{\"29\":1}}],[\"在较小范围内\",{\"1\":{\"244\":1}}],[\"在较低层的实现中\",{\"1\":{\"208\":1}}],[\"在比较旧的浏览器中\",{\"1\":{\"243\":1}}],[\"在原来的二层的头上加一个\",{\"1\":{\"234\":1}}],[\"在上面的过程中\",{\"1\":{\"232\":1}}],[\"在上一节中\",{\"1\":{\"156\":1}}],[\"在处理\",{\"1\":{\"223\":1}}],[\"在本章内容中\",{\"1\":{\"217\":1}}],[\"在本篇文章中\",{\"1\":{\"186\":1}}],[\"在第三章中我们介绍了\",{\"1\":{\"222\":1}}],[\"在第三章中我们初步体验了\",{\"1\":{\"217\":1}}],[\"在第二字节再度进行扩展\",{\"1\":{\"61\":1}}],[\"在哪个口\",{\"1\":{\"231\":2}}],[\"在哪些数据集上训练的\",{\"1\":{\"205\":1}}],[\"在哪里\",{\"1\":{\"81\":1}}],[\"在前两章中你了解了\",{\"1\":{\"203\":1}}],[\"在多\",{\"1\":{\"193\":1}}],[\"在多线程的情况下\",{\"1\":{\"110\":1}}],[\"在实例化\",{\"1\":{\"192\":1}}],[\"在实现上使用的是连续的内存空间\",{\"1\":{\"96\":1}}],[\"在我们定义\",{\"1\":{\"192\":1}}],[\"在批处理中这将数据整理到一个\",{\"1\":{\"190\":1}}],[\"在批处理句子时\",{\"1\":{\"152\":1}}],[\"在这个例子中\",{\"1\":{\"189\":1}}],[\"在顶部加了一个维度\",{\"1\":{\"178\":1}}],[\"在此之前我们直接调用\",{\"1\":{\"178\":1}}],[\"在之前的例子中\",{\"1\":{\"177\":1}}],[\"在使用过程中直接调用\",{\"1\":{\"172\":1}}],[\"在一些多语言模型中使用\",{\"1\":{\"170\":1}}],[\"在大一些的模型中可能是3072甚至更大\",{\"1\":{\"158\":1}}],[\"在大部分情况下都可以做到\",{\"1\":{\"126\":1}}],[\"在生成第4个单词时\",{\"1\":{\"152\":1}}],[\"在训练过程中\",{\"1\":{\"152\":1}}],[\"在翻译\",{\"1\":{\"151\":1}}],[\"在做文本翻译任务时\",{\"1\":{\"151\":1}}],[\"在该文章中\",{\"1\":{\"150\":1}}],[\"在迁移学习时\",{\"1\":{\"147\":1}}],[\"在模型上进一步微调并不会消除这种偏差\",{\"1\":{\"145\":1}}],[\"在接下来的学习中\",{\"1\":{\"142\":1}}],[\"在每个\",{\"1\":{\"192\":1}}],[\"在每个桶中的复杂度为\",{\"1\":{\"129\":1}}],[\"在每个桶中使用快排\",{\"1\":{\"129\":1}}],[\"在每个波段里使用先进先出\",{\"1\":{\"71\":1}}],[\"在已排序区间中找到合适的位置将其插入\",{\"1\":{\"121\":1}}],[\"在队列为空的时候\",{\"1\":{\"109\":1}}],[\"在任何时候\",{\"1\":{\"103\":1}}],[\"在单链表中\",{\"1\":{\"93\":1}}],[\"在能够应用均摊时间复杂度分析的场合\",{\"1\":{\"89\":1}}],[\"在数组中插入一个元素的时间复杂度是\",{\"1\":{\"121\":1}}],[\"在数组中\",{\"1\":{\"88\":1}}],[\"在给定数组\",{\"1\":{\"87\":1}}],[\"在把包发出去之前要先把\",{\"1\":{\"72\":1}}],[\"在制订\",{\"1\":{\"66\":1}}],[\"在unicode标准中\",{\"1\":{\"49\":1}}],[\"在编号字符集中\",{\"1\":{\"45\":1}}],[\"在\",{\"1\":{\"45\":2,\"58\":1,\"71\":1,\"77\":1,\"152\":1,\"165\":2,\"192\":1,\"194\":1,\"201\":1,\"203\":1,\"204\":1,\"206\":1,\"216\":1,\"233\":1,\"244\":1}}],[\"在某些特殊传输环境中\",{\"1\":{\"48\":1}}],[\"在某些特殊的传输环境中\",{\"1\":{\"42\":1}}],[\"在某些专业领域\",{\"1\":{\"42\":1}}],[\"在所有的positive数据中\",{\"1\":{\"39\":1}}],[\"在预测为positive的所有数据中\",{\"1\":{\"38\":1}}],[\"在评价一个二分类的机器学习模型的性能时\",{\"1\":{\"36\":1}}],[\"在进行\",{\"1\":{\"29\":1}}],[\"在注册表中读取\",{\"1\":{\"8\":1}}],[\"且交换机无法学习到网络的拓扑结构\",{\"1\":{\"233\":1}}],[\"且提供了很多配置项\",{\"1\":{\"193\":1}}],[\"且结果会被缓存\",{\"1\":{\"189\":1}}],[\"且你在这个过程中丢失了信息\",{\"1\":{\"168\":1}}],[\"且都可以稳定\",{\"1\":{\"123\":1}}],[\"且不会直接用命令\",{\"1\":{\"72\":1}}],[\"且\",{\"1\":{\"28\":1}}],[\"且它们对应的实体也是相同的\",{\"1\":{\"7\":1}}],[\"$\",{\"1\":{\"28\":2}}],[\"📁\",{\"1\":{\"28\":1}}],[\"😂𩷶\",{\"1\":{\"16\":1}}],[\"😂\",{\"1\":{\"14\":1}}],[\"既有\",{\"0\":{\"28\":1}}],[\"既拷贝所有的属性\",{\"1\":{\"11\":1}}],[\"既拷贝\",{\"1\":{\"6\":1}}],[\"等目的\",{\"1\":{\"230\":1}}],[\"等于逆序度\",{\"1\":{\"121\":1}}],[\"等函数执行完成返回时\",{\"1\":{\"115\":1}}],[\"等到有空闲线程时\",{\"1\":{\"111\":1}}],[\"等人走了或者用完了\",{\"1\":{\"73\":1}}],[\"等采用多字节码元的编码方式而言\",{\"1\":{\"47\":1}}],[\"等等来筛选\",{\"1\":{\"216\":1}}],[\"等等\",{\"1\":{\"45\":1}}],[\"等指标\",{\"1\":{\"36\":1}}],[\"等\",{\"0\":{\"57\":1},\"1\":{\"25\":1,\"46\":1,\"49\":1,\"53\":1,\"58\":1,\"147\":1,\"238\":1,\"245\":1}}],[\"等数组方法\",{\"1\":{\"15\":1}}],[\"wget\",{\"1\":{\"219\":2}}],[\"way\",{\"1\":{\"222\":1}}],[\"waking\",{\"1\":{\"222\":1}}],[\"walk\",{\"1\":{\"222\":1}}],[\"warmup\",{\"1\":{\"199\":1,\"202\":2}}],[\"warning\",{\"1\":{\"192\":1}}],[\"wash\",{\"1\":{\"222\":1}}],[\"wasnt\",{\"1\":{\"222\":1}}],[\"was\",{\"1\":{\"168\":2,\"222\":7}}],[\"waitress\",{\"1\":{\"145\":1}}],[\"waiter\",{\"1\":{\"145\":1}}],[\"waiting\",{\"1\":{\"144\":2,\"156\":2,\"178\":3,\"180\":1,\"181\":1,\"183\":3,\"184\":1}}],[\"would\",{\"1\":{\"222\":1}}],[\"woman\",{\"1\":{\"145\":1,\"222\":1}}],[\"works\",{\"1\":{\"145\":2}}],[\"worst\",{\"0\":{\"87\":1}}],[\"wordpiece\",{\"1\":{\"170\":1}}],[\"words\",{\"1\":{\"156\":1,\"169\":1}}],[\"word\",{\"0\":{\"168\":1},\"1\":{\"42\":4,\"168\":1,\"169\":3}}],[\"wear\",{\"1\":{\"222\":1}}],[\"weeks\",{\"1\":{\"222\":3}}],[\"web\",{\"0\":{\"210\":1},\"1\":{\"206\":1}}],[\"webpack\",{\"1\":{\"25\":1}}],[\"weight\",{\"1\":{\"171\":1,\"198\":1,\"222\":2}}],[\"we\",{\"1\":{\"144\":1}}],[\"when\",{\"1\":{\"222\":1}}],[\"which\",{\"1\":{\"222\":1}}],[\"while\",{\"1\":{\"14\":1,\"85\":1,\"103\":2,\"125\":3}}],[\"whatever\",{\"1\":{\"214\":1}}],[\"whoami\",{\"1\":{\"209\":1}}],[\"whom\",{\"1\":{\"188\":1}}],[\"whole\",{\"1\":{\"144\":2,\"156\":2,\"178\":3,\"180\":1,\"181\":1,\"183\":3,\"184\":1}}],[\"with\",{\"1\":{\"192\":1,\"201\":1,\"214\":2,\"222\":4}}],[\"witness\",{\"1\":{\"188\":2}}],[\"will\",{\"1\":{\"144\":1,\"178\":1,\"180\":3,\"181\":2,\"222\":1}}],[\"windows\",{\"1\":{\"71\":1}}],[\"width\",{\"1\":{\"47\":1}}],[\"基数排序的复杂度就近似于\",{\"1\":{\"131\":1}}],[\"基数排序\",{\"0\":{\"128\":1},\"1\":{\"132\":1}}],[\"基数\",{\"1\":{\"118\":1}}],[\"基于链表实现的无线排队的线程池是不合适的\",{\"1\":{\"111\":1}}],[\"基于数组的循环队列\",{\"1\":{\"110\":1}}],[\"基于dbcs的编码方案里\",{\"1\":{\"62\":1}}],[\"基于可变数量的参数创建一个新的\",{\"1\":{\"21\":1}}],[\"基础上又增加了\",{\"1\":{\"61\":1}}],[\"基础上增加了\",{\"1\":{\"61\":1}}],[\"基础上进行进一步扩展得到的\",{\"1\":{\"58\":1}}],[\"基本类型\",{\"0\":{\"246\":1}}],[\"基本上都可以通过\",{\"1\":{\"111\":1}}],[\"基本不会变\",{\"1\":{\"73\":1}}],[\"基本是\",{\"1\":{\"71\":1}}],[\"基本满足日常需要\",{\"1\":{\"58\":1}}],[\"基本术语\",{\"0\":{\"42\":1}}],[\"基本使用\",{\"0\":{\"23\":1}}],[\"mcg\",{\"1\":{\"222\":1}}],[\"moisturizer\",{\"1\":{\"222\":1}}],[\"morning\",{\"1\":{\"222\":1}}],[\"more\",{\"1\":{\"222\":2}}],[\"module\",{\"1\":{\"223\":1}}],[\"modules\",{\"1\":{\"25\":1,\"29\":2,\"163\":1}}],[\"moderate\",{\"1\":{\"222\":1}}],[\"moderately\",{\"1\":{\"222\":2}}],[\"model在\",{\"1\":{\"200\":1}}],[\"model=\",{\"1\":{\"144\":1,\"145\":1}}],[\"models\",{\"0\":{\"140\":1,\"161\":1,\"204\":1},\"1\":{\"33\":2,\"142\":1,\"150\":3,\"187\":1,\"208\":1,\"209\":1}}],[\"model\",{\"0\":{\"147\":1,\"157\":1,\"158\":1,\"159\":1,\"197\":1,\"211\":1,\"215\":1,\"216\":1},\"1\":{\"33\":1,\"42\":1,\"142\":3,\"144\":4,\"153\":1,\"154\":3,\"157\":2,\"158\":2,\"159\":3,\"160\":3,\"161\":3,\"162\":2,\"163\":6,\"164\":4,\"165\":7,\"171\":2,\"178\":7,\"179\":4,\"180\":11,\"181\":5,\"183\":3,\"184\":3,\"185\":2,\"192\":4,\"193\":2,\"195\":1,\"197\":3,\"198\":1,\"200\":3,\"201\":2,\"202\":13,\"203\":1,\"205\":1,\"208\":19,\"209\":3,\"212\":1,\"213\":6,\"214\":22,\"215\":6,\"216\":4}}],[\"modified\",{\"1\":{\"214\":1}}],[\"md\",{\"1\":{\"214\":1,\"215\":1}}],[\"ml\",{\"1\":{\"187\":1}}],[\"mrpc\",{\"1\":{\"187\":2,\"188\":1,\"191\":1,\"193\":4,\"194\":1,\"201\":1,\"208\":2}}],[\"mbart\",{\"1\":{\"150\":1}}],[\"must\",{\"1\":{\"222\":1}}],[\"mu\",{\"1\":{\"208\":1}}],[\"much\",{\"1\":{\"144\":1,\"156\":2,\"222\":3}}],[\"multicast\",{\"1\":{\"71\":2}}],[\"multilingual\",{\"1\":{\"65\":1}}],[\"multiple\",{\"1\":{\"33\":1}}],[\"my\",{\"1\":{\"144\":2,\"156\":2,\"164\":2,\"171\":1,\"178\":3,\"180\":1,\"181\":1,\"183\":3,\"184\":1,\"208\":1,\"218\":4,\"222\":15}}],[\"mn​\",{\"1\":{\"129\":1}}],[\"m×klogk\",{\"1\":{\"129\":1}}],[\"m\",{\"1\":{\"129\":4,\"214\":1,\"222\":1,\"223\":2}}],[\"m+1\",{\"1\":{\"125\":1}}],[\"mit\",{\"1\":{\"216\":1}}],[\"mixed\",{\"1\":{\"193\":1}}],[\"microsoft\",{\"1\":{\"187\":1}}],[\"mid+1\",{\"1\":{\"125\":2}}],[\"mid\",{\"1\":{\"125\":7}}],[\"minutes\",{\"1\":{\"222\":2}}],[\"min\",{\"1\":{\"122\":6}}],[\"minage\",{\"1\":{\"21\":2}}],[\"mq\",{\"1\":{\"71\":3}}],[\"mtu500\",{\"1\":{\"71\":1}}],[\"mtu\",{\"1\":{\"71\":3}}],[\"medium\",{\"0\":{\"229\":1}}],[\"medication\",{\"1\":{\"222\":1}}],[\"me\",{\"1\":{\"222\":2}}],[\"mechanic\",{\"1\":{\"145\":1}}],[\"merge\",{\"0\":{\"125\":1},\"1\":{\"125\":13}}],[\"memory\",{\"1\":{\"96\":1,\"217\":1}}],[\"metadata\",{\"0\":{\"216\":1},\"1\":{\"164\":1}}],[\"metrics=compute\",{\"1\":{\"193\":1}}],[\"metrics\",{\"1\":{\"192\":1,\"193\":16,\"201\":1,\"209\":1,\"215\":1,\"217\":1}}],[\"metric\",{\"1\":{\"37\":1,\"38\":1,\"39\":1,\"40\":1,\"193\":5,\"201\":6}}],[\"methods\",{\"1\":{\"33\":2,\"209\":1}}],[\"means\",{\"1\":{\"33\":1}}],[\"mean\",{\"1\":{\"33\":1}}],[\"made\",{\"1\":{\"222\":1}}],[\"master\",{\"1\":{\"219\":2,\"220\":1}}],[\"mask=torch\",{\"1\":{\"180\":1}}],[\"masks\",{\"0\":{\"180\":1},\"1\":{\"185\":1}}],[\"mask\",{\"1\":{\"80\":1,\"145\":3,\"152\":1,\"156\":1,\"171\":2,\"179\":1,\"180\":8,\"181\":2,\"189\":5,\"190\":1,\"195\":1,\"196\":1}}],[\"main\",{\"1\":{\"214\":4}}],[\"maid\",{\"1\":{\"145\":1}}],[\"marian\",{\"1\":{\"150\":1}}],[\"management\",{\"1\":{\"209\":2}}],[\"man\",{\"1\":{\"145\":1}}],[\"maximum\",{\"1\":{\"180\":1}}],[\"max\",{\"1\":{\"80\":1,\"130\":6,\"144\":1,\"162\":1,\"180\":5,\"181\":4,\"202\":1}}],[\"maxage\",{\"1\":{\"21\":2}}],[\"mac\",{\"0\":{\"226\":1,\"229\":1},\"1\":{\"71\":6,\"72\":6,\"75\":2,\"76\":1,\"77\":1,\"229\":3,\"230\":7,\"231\":4,\"232\":5}}],[\"machines\",{\"1\":{\"33\":1}}],[\"machine\",{\"1\":{\"33\":1}}],[\"making\",{\"1\":{\"34\":1}}],[\"makeuser\",{\"1\":{\"2\":1}}],[\"mapping\",{\"1\":{\"217\":1}}],[\"map\",{\"0\":{\"224\":1},\"1\":{\"21\":3,\"189\":4,\"191\":1,\"194\":1,\"214\":3,\"217\":1,\"222\":3,\"223\":2,\"224\":2}}],[\"mapfn\",{\"1\":{\"12\":1,\"16\":1,\"17\":1}}],[\"matrix\",{\"1\":{\"19\":1,\"34\":1,\"36\":1}}],[\"math\",{\"1\":{\"3\":4,\"239\":1}}],[\"作者使用动图清晰地描述了\",{\"1\":{\"150\":1}}],[\"作为参数传递\",{\"1\":{\"192\":1}}],[\"作为参数传递给\",{\"1\":{\"180\":1}}],[\"作为输入\",{\"1\":{\"156\":1,\"159\":1}}],[\"作为一整个整体来处理或运算的一串比特位\",{\"1\":{\"42\":1}}],[\"作为唯一的出口\",{\"1\":{\"29\":1}}],[\"作为\",{\"1\":{\"21\":1}}],[\"作为过滤器\",{\"1\":{\"21\":1}}],[\"作用\",{\"0\":{\"6\":1}}],[\"`number\",{\"1\":{\"243\":1}}],[\"`dataset\",{\"1\":{\"223\":1}}],[\"`parsefloat`\",{\"1\":{\"243\":1}}],[\"`parseint\",{\"1\":{\"243\":1}}],[\"`pip\",{\"1\":{\"192\":2}}],[\"`pytorch`\",{\"1\":{\"192\":1}}],[\"`accelerate>=0\",{\"1\":{\"192\":1}}],[\"`argn`\",{\"1\":{\"21\":1}}],[\"`trainer`\",{\"1\":{\"192\":1}}],[\"`thisarg`\",{\"1\":{\"21\":1}}],[\"`\",{\"1\":{\"28\":2,\"192\":1,\"223\":1,\"243\":2}}],[\"`hello\",{\"1\":{\"28\":2}}],[\"实际上我们更希望得到类似于概率的结果\",{\"1\":{\"160\":1}}],[\"实际上是将递归改为了\",{\"1\":{\"117\":1}}],[\"实际上\",{\"1\":{\"110\":1,\"111\":1,\"156\":1}}],[\"实际上这些所谓的\",{\"1\":{\"53\":1}}],[\"实际分配的时候\",{\"1\":{\"72\":1}}],[\"实例\",{\"1\":{\"21\":1}}],[\"实现微调以及评估\",{\"1\":{\"203\":1}}],[\"实现这一步有不同的规则\",{\"1\":{\"172\":1}}],[\"实现更好性能的一般策略是增加模型的大小以及预训练的数据量\",{\"1\":{\"148\":1}}],[\"实现通用\",{\"0\":{\"132\":1}}],[\"实现了\",{\"1\":{\"15\":1}}],[\"实现\",{\"0\":{\"98\":1},\"1\":{\"14\":1,\"17\":1,\"174\":1}}],[\"实现的是简单的从\",{\"1\":{\"199\":1}}],[\"实现的\",{\"1\":{\"12\":1}}],[\"所处的范围并不大的时候\",{\"1\":{\"130\":1}}],[\"所提供的字节序列\",{\"1\":{\"48\":1}}],[\"所形成的编码用于某些特殊的传输环境\",{\"1\":{\"47\":1}}],[\"所需的码点数量赎回不断增加的\",{\"1\":{\"46\":1}}],[\"所共同组成\",{\"1\":{\"45\":1}}],[\"所有的对象都是\",{\"1\":{\"245\":1}}],[\"所有的\",{\"1\":{\"160\":1}}],[\"所有的递归代码都可以改为迭代循环的非递归写法\",{\"1\":{\"117\":1}}],[\"所有\",{\"1\":{\"21\":1}}],[\"所以不论何时\",{\"1\":{\"243\":1}}],[\"所以字符串的最大长度实际上是受字符串的编码长度影响的\",{\"1\":{\"238\":1}}],[\"所以需要先用\",{\"1\":{\"232\":1}}],[\"所以你可以删除\",{\"1\":{\"202\":1}}],[\"所以我们可以使用\",{\"1\":{\"222\":1}}],[\"所以我们可以跳过自己解压的过程\",{\"1\":{\"219\":1}}],[\"所以我们可以不传递\",{\"1\":{\"192\":1}}],[\"所以我们可以用它们构建张量并把张量提供给模型\",{\"1\":{\"172\":1}}],[\"所以我们在使用该模型做推理的时候也应该在首尾加上它们\",{\"1\":{\"183\":1}}],[\"所以我们需要用我们所选的模型的名称来实例化\",{\"1\":{\"172\":1}}],[\"所以输出维度是\",{\"1\":{\"159\":1}}],[\"所以平均情况下的时间复杂度是\",{\"1\":{\"120\":1}}],[\"所以平均值需要查找一半的数据\",{\"1\":{\"94\":1}}],[\"所以线程池中排队的请求超过队列大小时\",{\"1\":{\"111\":1}}],[\"所以队列这种数据结构很适合来存储排队请求\",{\"1\":{\"111\":1}}],[\"所以内存消耗会翻倍\",{\"1\":{\"96\":1}}],[\"所以对\",{\"1\":{\"96\":1}}],[\"所以访问效率更高\",{\"1\":{\"96\":1}}],[\"所以这个过程叫预启动执行环境\",{\"1\":{\"80\":1}}],[\"所以这个返回值一般会被忽略\",{\"1\":{\"21\":1}}],[\"所以他希望的不仅仅是自动分配\",{\"1\":{\"80\":1}}],[\"所以它的网卡不会把包收进去\",{\"1\":{\"72\":1}}],[\"所以只能使用多个字节来表示一个字符\",{\"1\":{\"58\":1}}],[\"所以实际上共\",{\"1\":{\"56\":1}}],[\"所以在各种计算机系统平台中\",{\"1\":{\"47\":1}}],[\"所以\",{\"1\":{\"40\":1,\"73\":1,\"76\":1,\"81\":1,\"114\":1,\"115\":1,\"189\":1,\"230\":1}}],[\"所以会被当做元素直接添加\",{\"1\":{\"21\":1}}],[\"颠倒顺序\",{\"1\":{\"21\":1}}],[\"正确的比较方法应该是使用\",{\"1\":{\"239\":1}}],[\"正确写出链表代码\",{\"0\":{\"100\":1}}],[\"正无穷\",{\"1\":{\"239\":1}}],[\"正文里有\",{\"1\":{\"71\":1}}],[\"正常邮件为\",{\"1\":{\"40\":1}}],[\"正数表示大于\",{\"1\":{\"21\":1}}],[\"正是为了防止属性名冲突的\",{\"1\":{\"4\":1,\"240\":1}}],[\"迭代继续\",{\"1\":{\"21\":1}}],[\"迭代器\",{\"1\":{\"17\":1}}],[\"迭代器是在\",{\"1\":{\"13\":1}}],[\"迭代器和它所迭代的对象是分开的\",{\"1\":{\"13\":1}}],[\"迭代器要有\",{\"1\":{\"13\":1}}],[\"迭代器必须有\",{\"1\":{\"12\":1,\"17\":1}}],[\"到最大长度效率不高\",{\"1\":{\"189\":1}}],[\"到整个词表大小\",{\"1\":{\"168\":1}}],[\"到此为止\",{\"1\":{\"160\":1}}],[\"到底有多少数据被成功预测为positive\",{\"1\":{\"39\":1}}],[\"到\",{\"1\":{\"21\":3,\"199\":1}}],[\"没办法有效预读\",{\"1\":{\"96\":1}}],[\"没找到则返回\",{\"1\":{\"21\":1}}],[\"没有提供该方法的话\",{\"1\":{\"192\":1}}],[\"没有对应的转换\",{\"1\":{\"245\":1}}],[\"没有对应的值再进行计算\",{\"1\":{\"116\":1}}],[\"没有对句子对进行过预训练\",{\"1\":{\"192\":1}}],[\"没有介绍\",{\"1\":{\"189\":1}}],[\"没有体现出它们之间的相似与联系\",{\"1\":{\"168\":1}}],[\"没有指定\",{\"1\":{\"144\":1}}],[\"没有数据了的话\",{\"1\":{\"139\":2}}],[\"没有移动\",{\"1\":{\"121\":1}}],[\"没有考虑与任何一种现有的字符编码保持完全兼容\",{\"1\":{\"66\":1}}],[\"没有\",{\"1\":{\"15\":1,\"28\":1}}],[\"没有则会报错\",{\"1\":{\"13\":1}}],[\"则这个\",{\"1\":{\"190\":1}}],[\"则会使用默认\",{\"1\":{\"144\":1}}],[\"则所有数据的时间复杂度就是\",{\"1\":{\"129\":1}}],[\"则链表尾结点删除\",{\"1\":{\"98\":1}}],[\"则将此结点直接插入到链表的头部\",{\"1\":{\"98\":1}}],[\"则可能出现不够用的情况\",{\"1\":{\"96\":1}}],[\"则时间复杂度就会降到\",{\"1\":{\"82\":1}}],[\"则相对整齐和直观\",{\"1\":{\"71\":1}}],[\"则通过\",{\"1\":{\"71\":1}}],[\"则返回空数组\",{\"1\":{\"21\":1}}],[\"则返回\",{\"1\":{\"21\":2}}],[\"则创建它\",{\"1\":{\"8\":1}}],[\"而非\",{\"1\":{\"243\":1}}],[\"而非创建\",{\"1\":{\"209\":1}}],[\"而引入了无穷大的概念\",{\"1\":{\"239\":1}}],[\"而使用\",{\"1\":{\"169\":1}}],[\"而使用循环链表时\",{\"1\":{\"93\":1}}],[\"而不是\",{\"1\":{\"169\":1}}],[\"而不需要考虑参数的数量或类型\",{\"1\":{\"21\":1}}],[\"而重新训练又需要大量的时间和数据\",{\"1\":{\"163\":1}}],[\"而对\",{\"1\":{\"151\":1}}],[\"而是要求进行显示转换后用\",{\"1\":{\"242\":1}}],[\"而是要理解上下文的含义\",{\"1\":{\"141\":1}}],[\"而是是字符串的\",{\"1\":{\"238\":1}}],[\"而是放在一个配置文件里面\",{\"1\":{\"72\":1}}],[\"而快排是由上到下的\",{\"1\":{\"127\":1}}],[\"而递归是一种编程技巧\",{\"1\":{\"125\":1}}],[\"而插入排序只需要一个\",{\"1\":{\"123\":1}}],[\"而链表在内存中并不是连续存储\",{\"1\":{\"96\":1}}],[\"而且把不需要的包转发出去纯属浪费\",{\"1\":{\"231\":1}}],[\"而且\",{\"1\":{\"89\":1,\"96\":1,\"130\":1}}],[\"而且这些操作之间存在前后连贯的时序关系\",{\"1\":{\"89\":1}}],[\"而将待插入的元素直接插入对应位置\",{\"1\":{\"82\":1}}],[\"而scope\",{\"1\":{\"71\":1}}],[\"而gb18030\",{\"1\":{\"61\":1}}],[\"而一个字节只能表示\",{\"1\":{\"58\":1}}],[\"而\",{\"1\":{\"47\":1,\"71\":4,\"152\":1,\"222\":1}}],[\"而计算机所能表示的整数范围却是有限的\",{\"1\":{\"46\":1}}],[\"而耽误治疗离世\",{\"1\":{\"40\":1}}],[\"而另外两个不能\",{\"1\":{\"21\":1}}],[\"而我们只有一个迭代器\",{\"1\":{\"13\":1}}],[\"将图中的环破坏了\",{\"1\":{\"233\":1}}],[\"将少于\",{\"1\":{\"223\":1}}],[\"将你的\",{\"1\":{\"208\":1}}],[\"将模型上传至\",{\"1\":{\"208\":1}}],[\"将代码存到\",{\"1\":{\"202\":1}}],[\"将列\",{\"1\":{\"195\":1}}],[\"将我们之前构造的对象\",{\"1\":{\"192\":1}}],[\"将每个\",{\"1\":{\"179\":1}}],[\"将每一个\",{\"1\":{\"156\":1}}],[\"将词表索引转化成字符串\",{\"1\":{\"175\":1}}],[\"将上面的\",{\"1\":{\"165\":1}}],[\"将输入传递给\",{\"1\":{\"160\":1}}],[\"将输入传递给模型\",{\"1\":{\"155\":1}}],[\"将文本转换成数字的过程叫做编码\",{\"1\":{\"172\":1}}],[\"将文本转化为\",{\"1\":{\"185\":1}}],[\"将文本转化为张量\",{\"1\":{\"165\":1}}],[\"将文本转化成\",{\"1\":{\"171\":1}}],[\"将文本传递给\",{\"1\":{\"156\":1}}],[\"将文本切分成\",{\"1\":{\"156\":1,\"169\":1}}],[\"将文本翻译成另一种语言\",{\"1\":{\"141\":1}}],[\"将栈\",{\"1\":{\"139\":2}}],[\"将结果压入操作数栈\",{\"1\":{\"137\":1}}],[\"将结果拷贝到\",{\"1\":{\"130\":1}}],[\"将这些高维张量映射到不同的维度上\",{\"1\":{\"159\":1}}],[\"将这些用于控制或通讯的控制字符或通讯专用字符称之为\",{\"1\":{\"53\":1}}],[\"将这个对应的栈帧出栈\",{\"1\":{\"136\":1}}],[\"将大于\",{\"1\":{\"126\":1}}],[\"将大问题分解成小的子问题\",{\"1\":{\"125\":1}}],[\"将小于\",{\"1\":{\"126\":1}}],[\"将问题\",{\"1\":{\"125\":1}}],[\"将数组分成前后两部分\",{\"1\":{\"125\":1}}],[\"将数组中的元素分为两个区间\",{\"1\":{\"121\":1}}],[\"将其设为\",{\"1\":{\"224\":1}}],[\"将其压入栈中\",{\"1\":{\"138\":1}}],[\"将其放到已排序区间的末尾\",{\"1\":{\"122\":1}}],[\"将其他多字节字符编码中的各个字节的最高位设为\",{\"1\":{\"58\":1}}],[\"将未排序区间的一个元素插入已排序空间时\",{\"1\":{\"121\":1}}],[\"将递归代码改为非递归代码\",{\"0\":{\"117\":1}}],[\"将请求排队\",{\"1\":{\"111\":1}}],[\"将新的数据结点插入链表的头部\",{\"1\":{\"98\":1}}],[\"将来根据需要\",{\"1\":{\"64\":1}}],[\"将码元序列进一步编码所形成的\",{\"1\":{\"47\":1}}],[\"将逻辑上的码元序列映射为物理上的字节序列\",{\"1\":{\"47\":1}}],[\"将字符编号编码为逻辑上的码元序列\",{\"1\":{\"46\":1}}],[\"将字符集中的字符进行编号\",{\"1\":{\"42\":1}}],[\"将字符集中的字符按一定方式编码为某指定集合中的某一对象的过程\",{\"1\":{\"42\":1}}],[\"将抽象字符表\",{\"1\":{\"45\":1}}],[\"将被作为独立函数调用\",{\"1\":{\"21\":1}}],[\"将位置\",{\"1\":{\"21\":1}}],[\"将\",{\"0\":{\"174\":1},\"1\":{\"21\":1,\"55\":1,\"58\":1,\"70\":1,\"125\":1,\"139\":1,\"151\":1,\"176\":2,\"195\":1,\"208\":1,\"220\":1}}],[\"将可迭代对象或类数组转化为真正的数组\",{\"1\":{\"17\":1}}],[\"将可迭代对象或类数组\",{\"1\":{\"12\":1}}],[\"并\",{\"1\":{\"214\":1}}],[\"并成功\",{\"1\":{\"213\":1}}],[\"并不直观\",{\"1\":{\"192\":1}}],[\"并不存在字节序问题\",{\"1\":{\"47\":1}}],[\"并会为你处理好它\",{\"1\":{\"183\":1}}],[\"并在\",{\"1\":{\"171\":1}}],[\"并在当前位置插入\",{\"1\":{\"21\":1}}],[\"并尽可能小\",{\"1\":{\"166\":1}}],[\"并实例化模型\",{\"1\":{\"161\":1}}],[\"并实例化了对应的模型\",{\"1\":{\"157\":1}}],[\"并缓存下来\",{\"1\":{\"156\":1}}],[\"并负责将数字表示转化成文本\",{\"1\":{\"154\":1}}],[\"并返回分区点\",{\"1\":{\"126\":1}}],[\"并发包利用\",{\"1\":{\"108\":1}}],[\"并发队列\",{\"0\":{\"110\":1},\"1\":{\"108\":1}}],[\"并发送了子网掩码\",{\"1\":{\"76\":1}}],[\"并将它们拼接起来\",{\"1\":{\"190\":1}}],[\"并将这一\",{\"1\":{\"78\":1}}],[\"并将其从原来的位置删除\",{\"1\":{\"98\":1}}],[\"并将其\",{\"1\":{\"19\":2}}],[\"并将其存储在注册表中\",{\"1\":{\"8\":1}}],[\"并撤销他们提供的\",{\"1\":{\"77\":1}}],[\"并且\",{\"1\":{\"129\":1}}],[\"并且告诉所有的\",{\"1\":{\"77\":1}}],[\"并且必须是\",{\"1\":{\"59\":1}}],[\"并向网络发送一个\",{\"1\":{\"77\":1}}],[\"并为每个字符分配一个唯一的字符编号\",{\"1\":{\"64\":1}}],[\"并提供了一些新功能\",{\"1\":{\"71\":1}}],[\"并提供\",{\"1\":{\"60\":1}}],[\"并移到下一行\",{\"1\":{\"53\":1}}],[\"并从第二个元素开始迭代\",{\"1\":{\"21\":1}}],[\"并停止迭代\",{\"1\":{\"21\":1}}],[\"从随机打乱的数据集中选取前\",{\"1\":{\"222\":1}}],[\"从文本中提取答案\",{\"1\":{\"141\":1}}],[\"从左到右扫描字符串\",{\"1\":{\"138\":1}}],[\"从左向右遍历表达式\",{\"1\":{\"137\":1}}],[\"从操作数栈栈顶取出\",{\"1\":{\"137\":1}}],[\"从运算符栈中取出运算符\",{\"1\":{\"137\":1}}],[\"从区间的首\",{\"1\":{\"133\":1}}],[\"从后向前遍历\",{\"1\":{\"130\":1}}],[\"从队头取数据会被阻塞\",{\"1\":{\"109\":1}}],[\"从任意结点出发都可以访问到表中的所有节点\",{\"1\":{\"93\":1}}],[\"从已知一结点出发\",{\"1\":{\"93\":1}}],[\"从链尾到链头比较方便\",{\"1\":{\"93\":1}}],[\"从而实现了与\",{\"1\":{\"66\":1}}],[\"从而导致不同的用户由于安装了不同的字体文件\",{\"1\":{\"65\":1}}],[\"从多维数组创建一个新的扁平数组\",{\"1\":{\"21\":1}}],[\"从索引\",{\"1\":{\"21\":1}}],[\"从右到左\",{\"1\":{\"21\":1}}],[\"从\",{\"0\":{\"188\":1},\"1\":{\"21\":1,\"168\":1,\"217\":1}}],[\"从全局注册表中读取\",{\"1\":{\"8\":1}}],[\"删除等有关的方法\",{\"1\":{\"209\":1}}],[\"删除等操作比单链表简单高效\",{\"1\":{\"94\":1}}],[\"删除链表倒数第\",{\"1\":{\"106\":1}}],[\"删除链表结点时\",{\"1\":{\"102\":1}}],[\"删除最后一个结点就可以统一为相同的代码实现逻辑\",{\"1\":{\"103\":1}}],[\"删除最后一个结点\",{\"1\":{\"103\":1}}],[\"删除操作\",{\"1\":{\"96\":1}}],[\"删除的时间复杂度都是\",{\"1\":{\"92\":1}}],[\"删除\",{\"1\":{\"21\":2,\"82\":1,\"103\":1}}],[\"删掉了\",{\"1\":{\"19\":2}}],[\"添加了两个特殊词\",{\"1\":{\"183\":1}}],[\"添加可能对模型有用的其他输入\",{\"1\":{\"156\":1}}],[\"添加\",{\"1\":{\"21\":1}}],[\"仅当两个对象引用的是同一个对象时\",{\"1\":{\"20\":1}}],[\"比特串\",{\"1\":{\"42\":1}}],[\"比特位\",{\"1\":{\"42\":1}}],[\"比较少用的词可以分解为有意义的子词\",{\"1\":{\"170\":1}}],[\"比较操作肯定比交换操作多\",{\"1\":{\"120\":1}}],[\"比较和交换\",{\"1\":{\"120\":1}}],[\"比较\",{\"0\":{\"127\":1},\"1\":{\"120\":1,\"121\":1}}],[\"比较次数和交换\",{\"1\":{\"118\":1}}],[\"比较函数要返回\",{\"1\":{\"21\":1}}],[\"比较数组\",{\"0\":{\"20\":1}}],[\"比如不让除以\",{\"1\":{\"239\":1}}],[\"比如不常用的象形文字\",{\"1\":{\"65\":1}}],[\"比如通过配置\",{\"1\":{\"193\":1}}],[\"比如中文字符会比拉丁系语言的字符携带更多信息\",{\"1\":{\"169\":1}}],[\"比如最大值是\",{\"1\":{\"130\":1}}],[\"比如散列表\",{\"1\":{\"116\":1}}],[\"比如数据库连接池等\",{\"1\":{\"111\":1}}],[\"比如高性能队列\",{\"1\":{\"108\":1}}],[\"比如email中\",{\"1\":{\"42\":1}}],[\"比如码元的单字节与多字节\",{\"1\":{\"42\":1}}],[\"比如\",{\"1\":{\"14\":1,\"21\":1,\"115\":1,\"132\":1,\"141\":1,\"151\":1,\"152\":2,\"164\":1,\"170\":1,\"202\":1,\"245\":1}}],[\"比如设置\",{\"1\":{\"13\":1}}],[\"以后遇到目的地址是电脑\",{\"1\":{\"231\":1}}],[\"以该列为基准做排序\",{\"1\":{\"223\":1}}],[\"以对数据有一个直观的认识\",{\"1\":{\"222\":1}}],[\"以上的文件\",{\"1\":{\"212\":1}}],[\"以在\",{\"1\":{\"203\":1}}],[\"以在训练过程中查看训练效果\",{\"1\":{\"200\":1}}],[\"以让\",{\"1\":{\"200\":1}}],[\"以获取\",{\"1\":{\"190\":1}}],[\"以启动多进程\",{\"1\":{\"189\":1}}],[\"以确保使用和预训练时相同的规则\",{\"1\":{\"172\":1}}],[\"以下\",{\"1\":{\"170\":1}}],[\"以作为神经网络的输入\",{\"1\":{\"154\":1}}],[\"以使得模型关注某些表示\",{\"1\":{\"152\":1}}],[\"以使得对象具有迭代性质\",{\"1\":{\"10\":1}}],[\"以及\",{\"1\":{\"192\":1}}],[\"以及行数\",{\"1\":{\"188\":1}}],[\"以及其他输入来生成目标序列\",{\"1\":{\"150\":1}}],[\"以及不在数组中\",{\"1\":{\"88\":1}}],[\"以从输入中获得理解\",{\"1\":{\"150\":1}}],[\"以保证计数是稳定的\",{\"1\":{\"130\":1}}],[\"以此类推\",{\"1\":{\"127\":1}}],[\"以最后一个元素作为分区的界限\",{\"1\":{\"126\":1}}],[\"以便提供给下一个\",{\"1\":{\"77\":1}}],[\"以便与其他多字节字符统一\",{\"1\":{\"58\":1}}],[\"以太网就用的这种方式\",{\"1\":{\"229\":1}}],[\"以太网规定正文部分不允许超过\",{\"1\":{\"71\":1}}],[\"以太网的默认值\",{\"1\":{\"71\":1}}],[\"以外的其他增补平面\",{\"1\":{\"65\":1}}],[\"以外的其他平面为增补平面\",{\"1\":{\"65\":1}}],[\"以取代\",{\"1\":{\"61\":1}}],[\"以避免与\",{\"1\":{\"58\":1}}],[\"以满足该特殊环境的限制\",{\"1\":{\"48\":1}}],[\"以\",{\"1\":{\"46\":1,\"159\":1}}],[\"以衡量其准确性方面的性能\",{\"1\":{\"40\":1}}],[\"以逗号连接数组中的元素\",{\"1\":{\"19\":1}}],[\"8lbs\",{\"1\":{\"222\":1}}],[\"851ff3e\",{\"1\":{\"214\":1}}],[\"8578431372549019\",{\"1\":{\"193\":1}}],[\"8907849829351535\",{\"1\":{\"201\":1}}],[\"8996539792387542\",{\"1\":{\"193\":1}}],[\"8431372549019608\",{\"1\":{\"201\":1}}],[\"8789\",{\"1\":{\"178\":1}}],[\"876\",{\"1\":{\"106\":1}}],[\"8n​\",{\"1\":{\"125\":2}}],[\"883\",{\"1\":{\"60\":1}}],[\"8859\",{\"0\":{\"54\":1,\"56\":1},\"1\":{\"45\":2,\"55\":1,\"56\":5,\"67\":1}}],[\"8859系列\",{\"1\":{\"44\":1}}],[\"8个\",{\"1\":{\"42\":1}}],[\"8\",{\"1\":{\"19\":1,\"42\":2,\"46\":1,\"47\":2,\"49\":1,\"58\":2,\"66\":2,\"70\":2,\"190\":6,\"196\":4,\"197\":1}}],[\"76\",{\"1\":{\"196\":3}}],[\"768\",{\"1\":{\"158\":1,\"162\":1}}],[\"7276\",{\"1\":{\"178\":1}}],[\"754\",{\"1\":{\"239\":2}}],[\"7592\",{\"1\":{\"165\":1}}],[\"75\",{\"1\":{\"71\":1}}],[\"7993\",{\"1\":{\"171\":1,\"174\":1,\"175\":1}}],[\"79\",{\"1\":{\"71\":1}}],[\"777\",{\"1\":{\"70\":1}}],[\"7\",{\"0\":{\"80\":1},\"1\":{\"19\":1,\"48\":1,\"53\":1}}],[\"清空数组最简单的方式\",{\"1\":{\"19\":1}}],[\"减小再恢复原长\",{\"1\":{\"19\":1}}],[\"倍\",{\"1\":{\"19\":1}}],[\"速度要慢\",{\"1\":{\"19\":1}}],[\"<file>\",{\"1\":{\"214\":1}}],[\"<your\",{\"1\":{\"214\":1}}],[\"<namespace>\",{\"1\":{\"212\":1,\"213\":1,\"214\":1}}],[\"<path\",{\"1\":{\"212\":1,\"213\":4,\"214\":2}}],[\"<token>\",{\"1\":{\"208\":1}}],[\"<broadcast\",{\"1\":{\"71\":1}}],[\"<\",{\"1\":{\"19\":1,\"21\":1,\"85\":1,\"87\":1,\"103\":3,\"120\":2,\"121\":1,\"122\":3,\"125\":3,\"126\":2,\"127\":1,\"130\":4}}],[\"<=\",{\"1\":{\"13\":2,\"103\":1,\"117\":1,\"120\":1,\"121\":1,\"122\":1,\"125\":3,\"130\":3,\"239\":1}}],[\"支持自动解压\",{\"1\":{\"219\":1}}],[\"支持下列格式\",{\"1\":{\"218\":1}}],[\"支持随机访问\",{\"1\":{\"82\":1}}],[\"支持\",{\"1\":{\"19\":1}}],[\"值\",{\"1\":{\"17\":1,\"237\":1}}],[\"就生成了树\",{\"1\":{\"233\":1}}],[\"就能处理比较长的序列\",{\"1\":{\"181\":1}}],[\"就入栈\",{\"1\":{\"137\":1}}],[\"就不适合用计数排序了\",{\"1\":{\"130\":1}}],[\"就不再向下递归了\",{\"1\":{\"115\":1}}],[\"就会将临时变量作为一个栈帧入栈\",{\"1\":{\"136\":1}}],[\"就会影响代码的可读性\",{\"1\":{\"115\":1}}],[\"就会有堆栈溢出的风险\",{\"1\":{\"115\":1}}],[\"就会返回该\",{\"1\":{\"8\":1}}],[\"就相对更加合理\",{\"1\":{\"111\":1}}],[\"就相应的可能指码元序列\",{\"1\":{\"47\":1}}],[\"就有可能会导致频繁的\",{\"1\":{\"96\":1}}],[\"就可以通过\",{\"1\":{\"206\":1}}],[\"就可以\",{\"1\":{\"172\":1}}],[\"就可以用这种方法\",{\"1\":{\"115\":1}}],[\"就可以得到需要遍历元素个数的平均值\",{\"1\":{\"88\":1}}],[\"就可以连接到服务器做一些操作了\",{\"1\":{\"80\":1}}],[\"就要分片传输\",{\"1\":{\"71\":1}}],[\"就表示这是一个汉字的开始\",{\"1\":{\"60\":1}}],[\"就属于跟特定计算机系统平台有关的物理意义上的编码过程\",{\"1\":{\"47\":1}}],[\"就是一个非常小的常量\",{\"1\":{\"129\":1}}],[\"就是第\",{\"1\":{\"127\":1}}],[\"就是在遍历数组\",{\"1\":{\"126\":1}}],[\"就是将\",{\"1\":{\"46\":1}}],[\"就是\",{\"1\":{\"17\":1}}],[\"表达式求值\",{\"0\":{\"137\":1}}],[\"表明已经接受客户机的选择\",{\"1\":{\"78\":1}}],[\"表明迭代结束\",{\"1\":{\"17\":1}}],[\"表示输入的哪部分是第一个句子\",{\"1\":{\"189\":1}}],[\"表示该位置是\",{\"1\":{\"180\":1}}],[\"表示递归的深度\",{\"1\":{\"115\":1}}],[\"表示数组\",{\"1\":{\"103\":1}}],[\"表示执行时间\",{\"1\":{\"85\":1}}],[\"表示当前的包的优先级\",{\"1\":{\"71\":1}}],[\"表示英文大写字母\",{\"1\":{\"67\":1}}],[\"表示\",{\"1\":{\"65\":1,\"71\":2,\"168\":1}}],[\"表示补充扩展的其他衍生字符\",{\"1\":{\"55\":1}}],[\"表示的其实是一种动作或行为\",{\"1\":{\"53\":1}}],[\"表示为\",{\"1\":{\"42\":2}}],[\"表示循环结束\",{\"1\":{\"13\":1}}],[\"9007199254740990\",{\"1\":{\"239\":1}}],[\"988bc5a\",{\"1\":{\"214\":1}}],[\"9946e\",{\"1\":{\"160\":1}}],[\"9995\",{\"1\":{\"160\":1}}],[\"999\",{\"1\":{\"156\":1,\"165\":2,\"180\":4,\"181\":2}}],[\"9994558691978455\",{\"1\":{\"144\":1}}],[\"9598\",{\"1\":{\"160\":1}}],[\"9598048329353333\",{\"1\":{\"144\":2}}],[\"95\",{\"1\":{\"60\":1}}],[\"96\",{\"1\":{\"56\":1}}],[\"97~122\",{\"1\":{\"53\":1}}],[\"94\",{\"1\":{\"45\":1}}],[\"9\",{\"1\":{\"16\":1,\"19\":1,\"53\":1,\"66\":1,\"160\":2,\"222\":1}}],[\"例题\",{\"1\":{\"114\":1}}],[\"例\",{\"1\":{\"16\":1}}],[\"例如要将文本内容在\",{\"1\":{\"66\":1}}],[\"例如\",{\"1\":{\"12\":1,\"15\":1,\"40\":2,\"72\":1,\"152\":1,\"168\":1,\"214\":1,\"245\":1}}],[\"转发表\",{\"0\":{\"231\":1}}],[\"转换为\",{\"0\":{\"174\":1}}],[\"转化为字符串\",{\"1\":{\"176\":1}}],[\"转化为数字表示\",{\"1\":{\"172\":1}}],[\"转化为真正的数组\",{\"1\":{\"12\":1}}],[\"转化成\",{\"1\":{\"165\":1,\"176\":1,\"179\":1}}],[\"转化成有限比特长度的编码值\",{\"1\":{\"46\":1}}],[\"转成\",{\"1\":{\"16\":1}}],[\"上应该怎么做\",{\"1\":{\"217\":1}}],[\"上加载数据集\",{\"1\":{\"217\":1}}],[\"上传\",{\"0\":{\"211\":1}}],[\"上传最后一版\",{\"1\":{\"208\":1}}],[\"上传到你所在的组织下\",{\"1\":{\"208\":1}}],[\"上传到\",{\"1\":{\"208\":1}}],[\"上传文件了\",{\"1\":{\"206\":1}}],[\"上共享模型会自动为该模型部署托管的推理\",{\"1\":{\"204\":1}}],[\"上进行分布式训练\",{\"1\":{\"202\":1}}],[\"上进行正确的\",{\"1\":{\"190\":1}}],[\"上开箱即用\",{\"1\":{\"193\":1}}],[\"上运行\",{\"1\":{\"192\":1,\"200\":1}}],[\"上\",{\"1\":{\"192\":1}}],[\"上述例子中为16\",{\"1\":{\"158\":1}}],[\"上述例子中为2\",{\"1\":{\"158\":1}}],[\"上述三个\",{\"1\":{\"58\":1}}],[\"上一篇文章中介绍了如何使用\",{\"1\":{\"186\":1}}],[\"上一节中提到的\",{\"1\":{\"155\":1}}],[\"上一个函数调用的结果\",{\"1\":{\"21\":1}}],[\"上中点\",{\"1\":{\"99\":1}}],[\"上扩展后的字符集\",{\"1\":{\"58\":1}}],[\"上面模型的默认\",{\"1\":{\"156\":1}}],[\"上面爬台阶的例子中\",{\"1\":{\"116\":1}}],[\"上面只是举例说明哨兵的作用\",{\"1\":{\"103\":1}}],[\"上面对应的就是最好情况时间复杂度和最坏情况时间复杂度\",{\"1\":{\"87\":1}}],[\"上面已经介绍了\",{\"1\":{\"21\":1}}],[\"上面的代码没抛出\",{\"1\":{\"222\":1}}],[\"上面的代码确实将文本转化成了数字表示\",{\"1\":{\"189\":1}}],[\"上面的代码下载了\",{\"1\":{\"157\":1}}],[\"上面的\",{\"1\":{\"15\":1}}],[\"上的每个字符对应\",{\"1\":{\"238\":1}}],[\"上的数据集\",{\"0\":{\"218\":1}}],[\"上的\",{\"1\":{\"14\":1,\"213\":1}}],[\"类以于\",{\"1\":{\"213\":1}}],[\"类以及它的\",{\"1\":{\"156\":1}}],[\"类进行微调\",{\"1\":{\"194\":1}}],[\"类来微调各种预训练模型\",{\"1\":{\"191\":1}}],[\"类可以根据\",{\"1\":{\"161\":1}}],[\"类似于\",{\"1\":{\"171\":2}}],[\"类似\",{\"1\":{\"157\":1,\"198\":1,\"222\":1}}],[\"类\",{\"0\":{\"213\":1},\"1\":{\"154\":1,\"159\":1,\"161\":1,\"192\":1}}],[\"类和\",{\"1\":{\"154\":1}}],[\"类比身份证\",{\"1\":{\"71\":1}}],[\"类字符集均属于双字节字符集\",{\"1\":{\"62\":1}}],[\"类字符\",{\"1\":{\"53\":1}}],[\"类数组\",{\"0\":{\"15\":1},\"1\":{\"17\":1}}],[\"类型转换\",{\"0\":{\"242\":1}}],[\"类型基本符合\",{\"1\":{\"239\":1}}],[\"类型\",{\"0\":{\"235\":1},\"1\":{\"4\":1,\"229\":2,\"230\":1,\"240\":1,\"241\":1}}],[\"类型或\",{\"1\":{\"4\":1,\"240\":1}}],[\"vlan\",{\"0\":{\"232\":1},\"1\":{\"234\":10}}],[\"visibility\",{\"1\":{\"209\":1}}],[\"vocabulary\",{\"1\":{\"172\":1}}],[\"vocab\",{\"1\":{\"162\":2}}],[\"void\",{\"1\":{\"120\":1,\"121\":1,\"122\":1,\"125\":3,\"126\":3,\"130\":1,\"237\":2}}],[\"very\",{\"1\":{\"222\":1}}],[\"verify\",{\"1\":{\"222\":1}}],[\"version\",{\"1\":{\"162\":1,\"214\":1}}],[\"ve\",{\"1\":{\"144\":2,\"156\":2,\"178\":3,\"180\":1,\"181\":1,\"183\":3,\"184\":1}}],[\"vector\",{\"1\":{\"33\":2,\"34\":2,\"233\":1}}],[\"vs\",{\"0\":{\"142\":1}}],[\"vxlan\",{\"1\":{\"70\":1}}],[\"variable\",{\"1\":{\"34\":2,\"215\":1}}],[\"variables\",{\"1\":{\"34\":3}}],[\"validation\",{\"1\":{\"33\":1,\"188\":2,\"189\":1,\"192\":2,\"193\":3,\"196\":1}}],[\"values\",{\"1\":{\"33\":2}}],[\"valueof\",{\"1\":{\"19\":1}}],[\"value\",{\"1\":{\"12\":1,\"13\":4,\"14\":1,\"17\":2,\"21\":5,\"33\":1,\"34\":1,\"45\":1,\"121\":3,\"123\":1,\"188\":3}}],[\"v\",{\"0\":{\"15\":1,\"96\":1},\"1\":{\"40\":1,\"190\":4,\"196\":2,\"200\":2,\"201\":2,\"202\":2}}],[\"然后根据策略进行转发\",{\"1\":{\"231\":1}}],[\"然后让主机自己判断是否需要\",{\"1\":{\"231\":1}}],[\"然后我们就可以保存\",{\"1\":{\"213\":1}}],[\"然后我们就可以使用\",{\"1\":{\"171\":1}}],[\"然后在\",{\"1\":{\"202\":1}}],[\"然后你可以使用下面的命令使用该配置文件启动分布式训练\",{\"1\":{\"202\":1}}],[\"然后它会将你的答案写入配置文件中\",{\"1\":{\"202\":1}}],[\"然后转化为\",{\"1\":{\"172\":1}}],[\"然后会介绍\",{\"1\":{\"154\":1}}],[\"然后\",{\"1\":{\"126\":1,\"192\":1}}],[\"然后再处理子问题\",{\"1\":{\"127\":1}}],[\"然后再合并\",{\"1\":{\"127\":1}}],[\"然后再返回\",{\"1\":{\"109\":1}}],[\"然后再插入到链表的头部\",{\"1\":{\"98\":1}}],[\"然后再继续迭代\",{\"1\":{\"14\":1}}],[\"然后自动配置好\",{\"1\":{\"73\":1}}],[\"然后将包发出去\",{\"1\":{\"72\":1}}],[\"然后是以下几部分\",{\"1\":{\"215\":1}}],[\"然后是\",{\"1\":{\"14\":1}}],[\"输入\",{\"1\":{\"179\":1}}],[\"输入一个\",{\"1\":{\"2\":1}}],[\"输出\",{\"0\":{\"158\":1},\"1\":{\"180\":1}}],[\"输出的部分一起作为\",{\"1\":{\"152\":1}}],[\"输出字符\",{\"1\":{\"14\":1}}],[\"html\",{\"1\":{\"222\":1,\"223\":5}}],[\"https\",{\"1\":{\"214\":2,\"219\":2,\"220\":1}}],[\"http\",{\"1\":{\"212\":1}}],[\"http的头\",{\"1\":{\"71\":1}}],[\"hypo\",{\"1\":{\"222\":1}}],[\"hypothesis\",{\"1\":{\"33\":1}}],[\"hf\",{\"1\":{\"163\":1,\"188\":1}}],[\"him\",{\"1\":{\"188\":1}}],[\"his\",{\"1\":{\"188\":4}}],[\"highly\",{\"1\":{\"222\":1}}],[\"high\",{\"1\":{\"186\":1}}],[\"hidden\",{\"0\":{\"158\":1},\"1\":{\"157\":1,\"158\":2,\"159\":1,\"162\":4}}],[\"hierarchical\",{\"1\":{\"33\":1}}],[\"hour\",{\"1\":{\"222\":1}}],[\"hoping\",{\"1\":{\"222\":1}}],[\"home\",{\"1\":{\"163\":1,\"188\":1}}],[\"however\",{\"1\":{\"222\":1}}],[\"how\",{\"1\":{\"144\":1,\"215\":1}}],[\"host\",{\"0\":{\"73\":1},\"1\":{\"71\":1}}],[\"had\",{\"1\":{\"222\":2}}],[\"hanzhuo\",{\"1\":{\"214\":2}}],[\"have\",{\"1\":{\"178\":1,\"180\":1,\"181\":1,\"184\":1,\"222\":1}}],[\"hate\",{\"1\":{\"144\":1,\"156\":2}}],[\"hassolvedlist\",{\"1\":{\"116\":3}}],[\"has\",{\"1\":{\"33\":1,\"222\":3}}],[\"hasinstance\",{\"1\":{\"10\":1}}],[\"hurt\",{\"1\":{\"222\":1}}],[\"hub=true\",{\"1\":{\"192\":1,\"208\":2}}],[\"hub\",{\"0\":{\"188\":1,\"208\":1,\"209\":1,\"218\":1},\"1\":{\"143\":1,\"186\":1,\"187\":1,\"188\":1,\"192\":1,\"203\":1,\"204\":2,\"206\":2,\"208\":13,\"209\":3,\"211\":2,\"212\":2,\"213\":3,\"216\":1,\"217\":3,\"227\":1}}],[\"huggingface\",{\"0\":{\"209\":1},\"1\":{\"144\":2,\"156\":2,\"163\":1,\"178\":3,\"180\":1,\"181\":1,\"183\":3,\"184\":1,\"188\":1,\"206\":1,\"208\":3,\"209\":5,\"212\":1,\"213\":1,\"214\":2}}],[\"hugging\",{\"0\":{\"218\":1},\"1\":{\"30\":1,\"204\":1,\"208\":1,\"211\":1,\"216\":1,\"217\":1}}],[\"healthy\",{\"1\":{\"222\":2}}],[\"header\",{\"1\":{\"216\":1}}],[\"heads\",{\"0\":{\"159\":1},\"1\":{\"159\":1,\"162\":1}}],[\"head\",{\"1\":{\"103\":5,\"108\":2,\"159\":1,\"192\":2}}],[\"helps\",{\"1\":{\"222\":1}}],[\"hello\",{\"1\":{\"14\":1,\"165\":1}}],[\"he\",{\"1\":{\"188\":1}}],[\"henson\",{\"1\":{\"168\":2}}],[\"𝒳\",{\"1\":{\"14\":1}}],[\"𝒳😂𩷶\",{\"1\":{\"16\":1}}],[\"𝒳😂\",{\"1\":{\"14\":1}}],[\"也收到了信息\",{\"1\":{\"232\":1}}],[\"也收到了这个广播\",{\"1\":{\"232\":1}}],[\"也被称为\",{\"1\":{\"229\":1}}],[\"也被称为存储格式\",{\"1\":{\"46\":1}}],[\"也提供了一些函数处理\",{\"1\":{\"222\":1}}],[\"也会到交换机\",{\"1\":{\"232\":1}}],[\"也会被考虑进去\",{\"1\":{\"179\":1}}],[\"也会减少\",{\"1\":{\"169\":1}}],[\"也就是\",{\"1\":{\"168\":1}}],[\"也有针对标点符号增加了额外规则的\",{\"1\":{\"168\":1}}],[\"也计算了\",{\"1\":{\"116\":1}}],[\"也属于是不完全的间接兼容或半兼容\",{\"1\":{\"66\":1}}],[\"也存在对应的两种可能\",{\"1\":{\"47\":1}}],[\"也称为专用区\",{\"1\":{\"65\":1}}],[\"也称辅助平面\",{\"1\":{\"65\":1}}],[\"也称\",{\"1\":{\"56\":1}}],[\"也称字节顺序\",{\"1\":{\"47\":1}}],[\"也称作序列化模式\",{\"1\":{\"47\":1}}],[\"也可做同样的操作\",{\"1\":{\"208\":1}}],[\"也可能会变\",{\"1\":{\"230\":1}}],[\"也可能指字节序列\",{\"1\":{\"47\":1}}],[\"也可能是指\",{\"1\":{\"47\":1,\"142\":1}}],[\"也可能使用多个码点组成的序列来表示\",{\"1\":{\"45\":1}}],[\"也可以上传自己的模型和数据集\",{\"1\":{\"204\":1}}],[\"也可以指定\",{\"1\":{\"182\":1}}],[\"也可以使用\",{\"1\":{\"171\":1}}],[\"也可以说\",{\"1\":{\"142\":1}}],[\"也可以知道如何从\",{\"1\":{\"80\":1}}],[\"也可以是开放的\",{\"1\":{\"44\":1}}],[\"也可以用\",{\"1\":{\"21\":1}}],[\"也可以正常地处理\",{\"1\":{\"14\":1}}],[\"也不能让正常邮件直接进垃圾箱\",{\"1\":{\"40\":1}}],[\"也不能让真正患病的人检测不出癌症\",{\"1\":{\"40\":1}}],[\"也没有\",{\"1\":{\"19\":1}}],[\"也是不同的\",{\"1\":{\"240\":1}}],[\"也是分治\",{\"1\":{\"126\":1}}],[\"也是非常有讲究的\",{\"1\":{\"111\":1}}],[\"也是一致的\",{\"1\":{\"67\":1}}],[\"也是在\",{\"1\":{\"56\":1}}],[\"也是\",{\"1\":{\"15\":1,\"180\":1,\"192\":1}}],[\"也拷贝\",{\"1\":{\"6\":1}}],[\"都建议传入\",{\"1\":{\"243\":1}}],[\"都在对象类型中有所对应\",{\"1\":{\"241\":1}}],[\"都能收到广播信息\",{\"1\":{\"232\":1}}],[\"都加载到内存中\",{\"1\":{\"189\":1}}],[\"都作为上下文考虑进去了\",{\"1\":{\"179\":1}}],[\"都做了什么\",{\"0\":{\"155\":1}}],[\"都会接收然后发给主机\",{\"1\":{\"231\":1}}],[\"都会跟\",{\"1\":{\"126\":1}}],[\"都会将临时变量封装为栈帧压入内存栈\",{\"1\":{\"115\":1}}],[\"都用到了循环并发队列\",{\"1\":{\"108\":1}}],[\"都是原地排序\",{\"1\":{\"123\":1}}],[\"都是把8位的字节映射为7位长的数据\",{\"1\":{\"48\":1}}],[\"都是\",{\"1\":{\"46\":1}}],[\"都是可迭代的\",{\"1\":{\"14\":1}}],[\"都与以字节为基础的基本数据类型密切相关\",{\"1\":{\"42\":1}}],[\"都从\",{\"1\":{\"29\":1}}],[\"都接受一个可选的附加参数\",{\"1\":{\"21\":1}}],[\"都使用\",{\"1\":{\"21\":1}}],[\"都可以是负数\",{\"1\":{\"21\":1}}],[\"都不是\",{\"1\":{\"15\":1}}],[\"都则将创建一个新的\",{\"1\":{\"8\":1}}],[\"了仓库\",{\"1\":{\"213\":1}}],[\"了解\",{\"1\":{\"185\":1,\"217\":1}}],[\"了解如何加载模型\",{\"1\":{\"154\":1}}],[\"了\",{\"1\":{\"13\":1,\"85\":1,\"165\":1,\"192\":1,\"213\":1}}],[\"被替换成了做\",{\"1\":{\"192\":1}}],[\"被称为状态字典\",{\"1\":{\"164\":1}}],[\"被称为全局\",{\"1\":{\"7\":1}}],[\"被网卡厂商固化在了网卡的\",{\"1\":{\"80\":1}}],[\"被分配到三个\",{\"1\":{\"71\":1}}],[\"被保留为私用\",{\"1\":{\"65\":1}}],[\"被划分为了17个平面\",{\"1\":{\"64\":1}}],[\"被\",{\"1\":{\"21\":1}}],[\"被转换成了数字0\",{\"1\":{\"20\":1}}],[\"被截断的元素并不会找回来\",{\"1\":{\"19\":1}}],[\"被调用时生成的\",{\"1\":{\"13\":1}}],[\"e\",{\"1\":{\"239\":4,\"243\":2}}],[\"eye\",{\"1\":{\"222\":1}}],[\"effects\",{\"1\":{\"222\":3}}],[\"effective\",{\"1\":{\"222\":3}}],[\"effectiveness\",{\"1\":{\"222\":2}}],[\"epochs\",{\"1\":{\"199\":2,\"200\":1,\"202\":6}}],[\"epoch\",{\"1\":{\"192\":2,\"193\":3,\"199\":1,\"200\":1,\"202\":2,\"208\":2}}],[\"epsilon\",{\"1\":{\"239\":1}}],[\"eps\",{\"1\":{\"162\":1}}],[\"equivalent\",{\"1\":{\"188\":4}}],[\"evaluate\",{\"1\":{\"193\":5,\"201\":3}}],[\"evaluation\",{\"0\":{\"193\":1,\"201\":1},\"1\":{\"192\":1,\"193\":1,\"215\":1}}],[\"eval\",{\"1\":{\"192\":1,\"193\":3,\"196\":1,\"201\":2,\"202\":4}}],[\"evidence\",{\"1\":{\"188\":2}}],[\"every\",{\"1\":{\"21\":1}}],[\"er\",{\"1\":{\"173\":1}}],[\"error\",{\"1\":{\"33\":1}}],[\"embeddings\",{\"1\":{\"162\":1}}],[\"embedding\",{\"1\":{\"157\":1,\"162\":1}}],[\"email\",{\"1\":{\"48\":2}}],[\"eat\",{\"1\":{\"222\":1}}],[\"eating\",{\"1\":{\"151\":2}}],[\"eascii\",{\"0\":{\"54\":1,\"55\":1},\"1\":{\"54\":1,\"55\":1,\"56\":2}}],[\"ethernet\",{\"1\":{\"230\":1}}],[\"ether\",{\"1\":{\"71\":1}}],[\"eth0\",{\"1\":{\"71\":2}}],[\"e类地址\",{\"1\":{\"70\":1}}],[\"excluding\",{\"1\":{\"222\":1}}],[\"exception\",{\"1\":{\"115\":1}}],[\"extremley\",{\"1\":{\"222\":1}}],[\"extremely\",{\"1\":{\"222\":1}}],[\"extended\",{\"1\":{\"52\":1,\"54\":1}}],[\"exfoliated\",{\"1\":{\"222\":1}}],[\"example\",{\"1\":{\"189\":3,\"191\":3,\"194\":3,\"218\":1,\"222\":2,\"223\":2}}],[\"expected\",{\"1\":{\"178\":1,\"222\":1}}],[\"export\",{\"0\":{\"22\":1,\"24\":1,\"26\":1,\"27\":1,\"28\":1,\"29\":1},\"1\":{\"22\":1,\"24\":2,\"28\":8,\"29\":21}}],[\"execution\",{\"0\":{\"80\":1}}],[\"ebcdic\",{\"0\":{\"51\":1,\"52\":1},\"1\":{\"52\":1}}],[\"english\",{\"1\":{\"156\":2,\"157\":2,\"159\":1,\"178\":2,\"184\":1}}],[\"enqueue\",{\"1\":{\"108\":1,\"110\":1}}],[\"environment\",{\"0\":{\"80\":1}}],[\"encoding\",{\"0\":{\"46\":1,\"47\":1,\"48\":1,\"172\":1,\"249\":1},\"1\":{\"42\":2,\"47\":1,\"146\":1,\"150\":1,\"172\":3,\"175\":1}}],[\"encoded\",{\"1\":{\"165\":2}}],[\"encoder\",{\"1\":{\"150\":2,\"152\":4}}],[\"encoders\",{\"1\":{\"150\":1}}],[\"encode\",{\"1\":{\"42\":1,\"47\":1,\"150\":1}}],[\"entire\",{\"1\":{\"33\":1}}],[\"endo\",{\"1\":{\"222\":1}}],[\"endianness\",{\"1\":{\"47\":1}}],[\"end\",{\"0\":{\"256\":1},\"1\":{\"16\":2,\"21\":7}}],[\"elevate\",{\"1\":{\"222\":1}}],[\"electra\",{\"1\":{\"150\":1}}],[\"elementn\",{\"1\":{\"21\":1}}],[\"element1\",{\"1\":{\"21\":1}}],[\"element0\",{\"1\":{\"21\":1}}],[\"elemn\",{\"1\":{\"21\":2}}],[\"elem1\",{\"1\":{\"21\":2}}],[\"else\",{\"1\":{\"13\":2,\"21\":2,\"103\":1,\"121\":1,\"123\":1,\"200\":1,\"202\":1}}],[\"es5\",{\"1\":{\"237\":1}}],[\"es\",{\"1\":{\"4\":1,\"240\":1}}],[\"调用会抛出错误\",{\"1\":{\"241\":1}}],[\"调用层次很深\",{\"1\":{\"115\":1}}],[\"调用的\",{\"1\":{\"21\":1}}],[\"调用\",{\"1\":{\"13\":1,\"192\":1}}],[\"否则判定括号不匹配\",{\"1\":{\"138\":1}}],[\"否则这种方法并不是很实用\",{\"1\":{\"115\":1}}],[\"否则\",{\"1\":{\"13\":1,\"17\":1,\"21\":1,\"58\":1,\"137\":1,\"138\":1}}],[\"循环冗余检测\",{\"1\":{\"229\":1}}],[\"循环执行\",{\"1\":{\"121\":1}}],[\"循环队列\",{\"1\":{\"108\":2}}],[\"循环链表的尾结点指向链表的头结点\",{\"1\":{\"93\":1}}],[\"循环链表是一种特殊的单链表\",{\"1\":{\"93\":1}}],[\"循环链表\",{\"0\":{\"93\":1},\"1\":{\"91\":1}}],[\"循环或迭代来进行\",{\"1\":{\"20\":1}}],[\"循环\",{\"1\":{\"19\":1}}],[\"循环希望获取下一个数值时\",{\"1\":{\"13\":1}}],[\"循环中使用的对象都是可迭代对象\",{\"1\":{\"12\":1}}],[\"即使\",{\"1\":{\"240\":1}}],[\"即使是类数组对象\",{\"1\":{\"21\":1}}],[\"即字符串具有值类型的特征\",{\"1\":{\"238\":1}}],[\"即字节流\",{\"1\":{\"42\":1}}],[\"即第二层设备\",{\"1\":{\"231\":1}}],[\"即数据数量\",{\"1\":{\"188\":1}}],[\"即数据存储在外部磁盘中\",{\"1\":{\"129\":1}}],[\"即每个序列的表示应该是一样长的\",{\"1\":{\"179\":1}}],[\"即每个新版本都向下兼容\",{\"1\":{\"58\":1}}],[\"即我们在上一节中谈到的\",{\"1\":{\"157\":1}}],[\"即下图中\",{\"1\":{\"157\":1}}],[\"即在正在被翻译的字词之前已经生成的部分\",{\"1\":{\"152\":1}}],[\"即特征\",{\"1\":{\"150\":1}}],[\"即他们已经以自监督学习\",{\"1\":{\"147\":1}}],[\"即时间复杂度是\",{\"1\":{\"127\":1}}],[\"即网线插着\",{\"1\":{\"71\":1}}],[\"即latin\",{\"1\":{\"67\":1}}],[\"即十进制的\",{\"1\":{\"67\":2}}],[\"即便是\",{\"1\":{\"66\":1}}],[\"即16位码元\",{\"1\":{\"66\":1}}],[\"即代码点\",{\"1\":{\"64\":1}}],[\"即代码空间\",{\"1\":{\"64\":1}}],[\"即一个汉字占用的存储空间相当于两个英文字符所占用的存储空间\",{\"1\":{\"62\":1}}],[\"即对\",{\"1\":{\"59\":1}}],[\"即最高位为\",{\"1\":{\"59\":1}}],[\"即汉字内码\",{\"1\":{\"59\":1}}],[\"即\",{\"1\":{\"56\":1,\"66\":1,\"67\":1,\"126\":1,\"156\":1,\"189\":1,\"199\":1,\"239\":2}}],[\"即扩展剩余的128位\",{\"1\":{\"56\":1}}],[\"即换行\",{\"1\":{\"53\":1}}],[\"即回车\",{\"1\":{\"53\":1}}],[\"即物理字符编码\",{\"1\":{\"47\":1}}],[\"即逻辑字符编码\",{\"1\":{\"46\":1}}],[\"即码点编号\",{\"1\":{\"64\":1,\"67\":1}}],[\"即码点值\",{\"1\":{\"45\":1}}],[\"即码元序列\",{\"1\":{\"42\":1}}],[\"即该字符的编号\",{\"1\":{\"45\":1}}],[\"即用数字给抽象字符表acr中的字符进行编号\",{\"1\":{\"45\":1}}],[\"即确定支持哪些字符\",{\"1\":{\"44\":1}}],[\"即映射为\",{\"1\":{\"42\":1}}],[\"即可打印字符引用编码\",{\"1\":{\"48\":1}}],[\"即可\",{\"1\":{\"24\":1,\"220\":1}}],[\"即可以使用\",{\"1\":{\"14\":1}}],[\"即被返回的迭代器\",{\"1\":{\"13\":1}}],[\"即创建了\",{\"1\":{\"8\":1}}],[\"这会造成错误\",{\"1\":{\"243\":1}}],[\"这会保存两个文件\",{\"1\":{\"164\":1}}],[\"这原本是符合\",{\"1\":{\"239\":1}}],[\"这将在本地创建文件夹<path\",{\"1\":{\"213\":1}}],[\"这将会创建名为\",{\"1\":{\"208\":1}}],[\"这次我们再执行\",{\"1\":{\"193\":1}}],[\"这要通过\",{\"1\":{\"179\":1}}],[\"这要用到\",{\"1\":{\"163\":1}}],[\"这显然是不应该的\",{\"1\":{\"179\":1}}],[\"这也会产生一些问题\",{\"1\":{\"169\":1}}],[\"这也是循环队列比链式队列应用更加广泛的原因\",{\"1\":{\"110\":1}}],[\"这类模型有\",{\"1\":{\"150\":3}}],[\"这类模型在其进行训练的语料上进行了理解\",{\"1\":{\"147\":1}}],[\"这取决于你要做什么任务\",{\"1\":{\"150\":1}}],[\"这两个文件相辅相成\",{\"1\":{\"164\":1}}],[\"这两个工具\",{\"1\":{\"71\":1}}],[\"这两部分可以单独使用\",{\"1\":{\"150\":1}}],[\"这意味着它无法检索到一个词的合理表示\",{\"1\":{\"168\":1}}],[\"这意味着该模型已针对生成输出进行了优化\",{\"1\":{\"150\":1}}],[\"这意味着对模型进行了优化\",{\"1\":{\"150\":1}}],[\"这篇文章\",{\"1\":{\"150\":1}}],[\"这往往需要使用大规模语料\",{\"1\":{\"149\":1}}],[\"这其中可能会夹杂一些意识形态或者价值观的刻板印象\",{\"1\":{\"145\":1}}],[\"这块内存被组织成\",{\"1\":{\"136\":1}}],[\"这三种排序算法都是原地排序\",{\"1\":{\"119\":1}}],[\"这里会用到\",{\"1\":{\"222\":2}}],[\"这里我们传入了\",{\"1\":{\"222\":1}}],[\"这里不展开介绍\",{\"1\":{\"210\":1}}],[\"这里只是画成\",{\"1\":{\"157\":1}}],[\"这里做特殊处理\",{\"1\":{\"103\":1}}],[\"这里给一个\",{\"1\":{\"15\":1}}],[\"这时基本不用广播了\",{\"1\":{\"231\":1}}],[\"这时桶排序的时间复杂度接近于\",{\"1\":{\"129\":1}}],[\"这时快排的时间复杂度就从\",{\"1\":{\"126\":1}}],[\"这时只能再申请一个更大的内存空间\",{\"1\":{\"96\":1}}],[\"这时的沟通基本靠\",{\"1\":{\"75\":1}}],[\"这台机器会收到多个\",{\"1\":{\"77\":1}}],[\"这一步称为\",{\"1\":{\"75\":1}}],[\"这就相当于买房自己装修\",{\"1\":{\"73\":1}}],[\"这就是重复计算问题\",{\"1\":{\"116\":1}}],[\"这就是\",{\"1\":{\"46\":1}}],[\"这张网卡仅仅可以供本机星湖通信\",{\"1\":{\"71\":1}}],[\"这张网卡是\",{\"1\":{\"71\":1}}],[\"这\",{\"1\":{\"56\":2,\"59\":1}}],[\"这带来了一些困扰和麻烦\",{\"1\":{\"52\":1}}],[\"这种方式既可以创建仓库\",{\"1\":{\"208\":1}}],[\"这种方式对响应时间敏感的系统来说\",{\"1\":{\"111\":1}}],[\"这种结构\",{\"1\":{\"136\":1}}],[\"这种数据结构来实现请求排队\",{\"1\":{\"111\":1}}],[\"这种基于阻塞队列实现的\",{\"1\":{\"109\":1}}],[\"这种链表叫带头链表\",{\"1\":{\"103\":1}}],[\"这种采用单字节码元的编码方式来说\",{\"1\":{\"47\":1}}],[\"这种情况是最应该避免的\",{\"1\":{\"40\":2}}],[\"这是找我的\",{\"1\":{\"232\":1}}],[\"这是一个输出全靠\",{\"1\":{\"230\":1}}],[\"这是用来衡量\",{\"1\":{\"193\":1}}],[\"这是因为\",{\"1\":{\"192\":1}}],[\"这是有用的\",{\"1\":{\"189\":1}}],[\"这是在预训练时使用的\",{\"1\":{\"183\":1}}],[\"这是logits\",{\"1\":{\"160\":1}}],[\"这是物理意义上的最终编码\",{\"1\":{\"47\":1}}],[\"这是为了兼容韩国字符集标准ks\",{\"1\":{\"45\":1}}],[\"这是是\",{\"1\":{\"21\":1}}],[\"这些术语\",{\"1\":{\"142\":1}}],[\"这些码点被称之为代理码点\",{\"1\":{\"65\":1}}],[\"这些双字符编码字符就是全角字符\",{\"1\":{\"59\":1}}],[\"这些逻辑层面的码元序列如何转换为\",{\"1\":{\"42\":1}}],[\"这些编号如何编码成一系列逻辑层面有限大小的数字\",{\"1\":{\"42\":1}}],[\"这些字符的编号是什么\",{\"1\":{\"42\":1}}],[\"这与字符编码关系密切\",{\"1\":{\"42\":1}}],[\"这个词表和预训练时的词表是相同的\",{\"1\":{\"172\":1}}],[\"这个架构只包括最基本的\",{\"1\":{\"157\":1}}],[\"这个交换的操作决定了它是不稳定的\",{\"1\":{\"122\":1}}],[\"这个问题与分解之后的子问题\",{\"1\":{\"113\":1}}],[\"这个比较操作\",{\"1\":{\"103\":1}}],[\"这个时候就会存在线程安全问题\",{\"1\":{\"110\":1}}],[\"这个时候\",{\"1\":{\"89\":1}}],[\"这个文件会指示\",{\"1\":{\"81\":1}}],[\"这个过程称为\",{\"1\":{\"76\":1}}],[\"这个被称为\",{\"1\":{\"71\":1}}],[\"这个地址用于本机通信\",{\"1\":{\"71\":1}}],[\"这个地址\",{\"1\":{\"71\":1}}],[\"这个字节和下个字节共同组成汉字\",{\"1\":{\"58\":1}}],[\"这个编码值是码元的序列\",{\"1\":{\"46\":1}}],[\"这个包\",{\"1\":{\"29\":1}}],[\"这个对象\",{\"1\":{\"15\":1}}],[\"这个方法必须返回一个迭代器\",{\"1\":{\"13\":1}}],[\"这样仍然不够\",{\"1\":{\"234\":1}}],[\"这样过了一段时间之后\",{\"1\":{\"231\":1}}],[\"这样我们只需要将长度填充为该\",{\"1\":{\"189\":1}}],[\"这样我们可以用于\",{\"1\":{\"4\":1,\"11\":1}}],[\"这样模型才能进行处理\",{\"1\":{\"189\":1}}],[\"这样做有两点好处\",{\"1\":{\"169\":1}}],[\"这样做给了我们更多的控制权\",{\"1\":{\"14\":1}}],[\"这样肯定比只取某一个数据好\",{\"1\":{\"133\":1}}],[\"这样就可以避免重复计算的问题了\",{\"1\":{\"116\":1}}],[\"这样\",{\"1\":{\"79\":1,\"80\":1,\"223\":1,\"234\":1}}],[\"这样其他的机器也能用\",{\"1\":{\"73\":1}}],[\"这样其他人在使用该包的时候\",{\"1\":{\"29\":1}}],[\"53\",{\"1\":{\"239\":1}}],[\"534\",{\"1\":{\"70\":1}}],[\"52\",{\"1\":{\"239\":1}}],[\"5223\",{\"1\":{\"156\":1}}],[\"5gb\",{\"1\":{\"212\":1}}],[\"5e\",{\"1\":{\"199\":1}}],[\"59\",{\"1\":{\"190\":2}}],[\"5980e\",{\"1\":{\"160\":1}}],[\"5801\",{\"1\":{\"187\":1}}],[\"5803\",{\"1\":{\"179\":1,\"180\":1}}],[\"5694\",{\"1\":{\"179\":2,\"180\":1}}],[\"5607\",{\"1\":{\"160\":2}}],[\"512\",{\"1\":{\"162\":1,\"180\":1,\"181\":2}}],[\"500\",{\"1\":{\"168\":2,\"192\":1}}],[\"50\",{\"1\":{\"79\":1,\"115\":1,\"190\":2}}],[\"57344~63743\",{\"1\":{\"65\":1}}],[\"5\",{\"0\":{\"28\":1,\"48\":1,\"62\":1,\"73\":1,\"105\":1,\"153\":1,\"176\":1,\"182\":1,\"183\":1,\"184\":1,\"217\":1,\"241\":1},\"1\":{\"13\":3,\"19\":1,\"21\":6,\"116\":1,\"160\":1,\"198\":1,\"199\":1,\"202\":2,\"222\":1,\"232\":1}}],[\"runtime\",{\"1\":{\"192\":1}}],[\"running\",{\"1\":{\"168\":1}}],[\"run\",{\"1\":{\"168\":1,\"192\":1}}],[\"rating\",{\"1\":{\"222\":1}}],[\"rate\",{\"0\":{\"199\":1},\"1\":{\"199\":1}}],[\"ram\",{\"1\":{\"189\":2,\"217\":1}}],[\"raw\",{\"1\":{\"156\":2,\"188\":7,\"189\":5,\"191\":2,\"194\":2,\"219\":2,\"220\":1,\"222\":2}}],[\"radix\",{\"0\":{\"131\":1}}],[\"random\",{\"1\":{\"33\":1}}],[\"range\",{\"1\":{\"13\":8,\"15\":1,\"16\":1,\"80\":1,\"162\":1,\"178\":2,\"200\":2,\"202\":4,\"222\":2}}],[\"r\",{\"1\":{\"125\":14,\"126\":11,\"145\":4,\"222\":13}}],[\"root\",{\"1\":{\"233\":4}}],[\"roberta\",{\"1\":{\"150\":1}}],[\"routers\",{\"1\":{\"80\":1}}],[\"rom\",{\"1\":{\"80\":1}}],[\"rows\",{\"1\":{\"34\":1,\"188\":3,\"189\":3,\"219\":3,\"223\":1}}],[\"r×s\",{\"1\":{\"34\":1}}],[\"ridge\",{\"1\":{\"33\":1}}],[\"red\",{\"1\":{\"222\":1}}],[\"reduceright\",{\"1\":{\"21\":2}}],[\"reduce\",{\"1\":{\"21\":2}}],[\"reasons\",{\"1\":{\"222\":2}}],[\"really\",{\"1\":{\"222\":2}}],[\"real\",{\"1\":{\"222\":1}}],[\"readme\",{\"1\":{\"214\":1,\"215\":1}}],[\"review\",{\"1\":{\"222\":2,\"223\":10}}],[\"reverse\",{\"1\":{\"21\":1}}],[\"reply\",{\"1\":{\"230\":1}}],[\"reporting\",{\"1\":{\"215\":1}}],[\"repo=\",{\"1\":{\"212\":1}}],[\"repository\",{\"0\":{\"213\":1},\"1\":{\"209\":1,\"213\":3}}],[\"repo\",{\"1\":{\"202\":1,\"208\":1,\"209\":8,\"212\":2,\"213\":10}}],[\"repertoire\",{\"0\":{\"44\":1}}],[\"rename\",{\"1\":{\"195\":1,\"222\":2}}],[\"remove\",{\"1\":{\"195\":1}}],[\"requires\",{\"1\":{\"192\":1}}],[\"request\",{\"0\":{\"77\":1},\"1\":{\"75\":1,\"77\":1,\"78\":1,\"79\":1,\"230\":1}}],[\"references=batch\",{\"1\":{\"201\":1}}],[\"references=labels\",{\"1\":{\"193\":1}}],[\"references=predictions\",{\"1\":{\"193\":1}}],[\"referring\",{\"1\":{\"188\":1}}],[\"reflect\",{\"1\":{\"6\":1,\"11\":1}}],[\"retrieve\",{\"1\":{\"157\":1,\"209\":1}}],[\"ret\",{\"1\":{\"116\":3,\"117\":4}}],[\"returning\",{\"1\":{\"222\":1}}],[\"returns\",{\"1\":{\"178\":3}}],[\"return\",{\"1\":{\"2\":3,\"13\":6,\"16\":1,\"21\":1,\"87\":1,\"103\":7,\"114\":3,\"115\":2,\"116\":4,\"117\":3,\"120\":1,\"121\":1,\"122\":1,\"125\":1,\"126\":2,\"130\":1,\"144\":1,\"156\":2,\"178\":5,\"182\":1,\"184\":1,\"189\":1,\"191\":1,\"193\":1,\"194\":1,\"222\":1,\"223\":1}}],[\"recently\",{\"1\":{\"98\":1,\"222\":1}}],[\"recall和f1\",{\"1\":{\"40\":1}}],[\"recall=tp+fntp​\",{\"1\":{\"39\":1}}],[\"recall\",{\"0\":{\"39\":1},\"1\":{\"36\":1,\"39\":3,\"40\":5}}],[\"restore\",{\"1\":{\"214\":1}}],[\"restart\",{\"1\":{\"192\":1}}],[\"research\",{\"1\":{\"187\":1}}],[\"res\",{\"1\":{\"168\":1}}],[\"response\",{\"1\":{\"34\":1}}],[\"results\",{\"1\":{\"21\":1,\"215\":1}}],[\"result\",{\"1\":{\"14\":3,\"145\":4,\"171\":1,\"173\":1,\"174\":1,\"175\":1,\"178\":1}}],[\"regular\",{\"1\":{\"211\":1}}],[\"regularization\",{\"1\":{\"198\":1}}],[\"regressive\",{\"1\":{\"146\":1,\"150\":1}}],[\"regression\",{\"1\":{\"33\":6}}],[\"register\",{\"1\":{\"7\":1}}],[\"re\",{\"0\":{\"29\":1},\"1\":{\"29\":4}}],[\"如上面的\",{\"1\":{\"208\":1}}],[\"如我们要使用\",{\"1\":{\"205\":1}}],[\"如翻译或摘要\",{\"1\":{\"150\":1}}],[\"如文本生成\",{\"1\":{\"150\":1}}],[\"如句子分类和命名实体识别\",{\"1\":{\"150\":1}}],[\"如著名的约瑟夫问题\",{\"1\":{\"93\":1}}],[\"如归并排序\",{\"1\":{\"85\":1}}],[\"如用于\",{\"1\":{\"48\":1}}],[\"如何获得同时有\",{\"1\":{\"219\":1}}],[\"如何创建自己的数据集并将其推至\",{\"1\":{\"217\":1}}],[\"如何对数据集进行切片\",{\"1\":{\"217\":1}}],[\"如何从\",{\"1\":{\"186\":1}}],[\"如何利用\",{\"1\":{\"185\":1,\"186\":1}}],[\"如何使用自定义训练过程\",{\"1\":{\"186\":1}}],[\"如何使用\",{\"1\":{\"185\":1,\"186\":1,\"215\":1}}],[\"如何使得一个表示集合的对象可以被\",{\"1\":{\"12\":1}}],[\"如何处理不同长度的多个序列\",{\"1\":{\"177\":1}}],[\"如何处理多个序列\",{\"1\":{\"177\":1}}],[\"如何生成\",{\"1\":{\"171\":1}}],[\"如何在\",{\"1\":{\"127\":1}}],[\"如何编写递归代码\",{\"0\":{\"114\":1}}],[\"如何实现一个线程安全的队列呢\",{\"1\":{\"110\":1}}],[\"如何做兼容\",{\"1\":{\"46\":1}}],[\"如何通过相对有限的整型数来可扩展地表示可能会无限增长的字符数量\",{\"1\":{\"46\":1}}],[\"如码点编号为u+51c9与u+f979的这两个码点实际上是同一个字符\",{\"1\":{\"45\":1}}],[\"如行\",{\"1\":{\"45\":1}}],[\"如ascii字符表\",{\"1\":{\"44\":1}}],[\"如\",{\"1\":{\"25\":1,\"44\":1,\"48\":1,\"49\":1,\"53\":1,\"58\":2,\"70\":1,\"142\":1,\"219\":1,\"222\":1}}],[\"如果要将\",{\"1\":{\"208\":1}}],[\"如果要排序的数据有\",{\"1\":{\"131\":1}}],[\"如果遇到下面的错误\",{\"1\":{\"192\":1}}],[\"如果传入了大于最大限度的序列会崩溃\",{\"1\":{\"181\":1}}],[\"如果两个序列的长度不一样怎么办\",{\"1\":{\"179\":1}}],[\"如果某个\",{\"1\":{\"168\":1}}],[\"如果还在同一环境中\",{\"1\":{\"157\":1}}],[\"如果能则继续\",{\"1\":{\"138\":1}}],[\"如果能用\",{\"1\":{\"15\":1}}],[\"如果比栈顶元素的优先级高\",{\"1\":{\"137\":1}}],[\"如果排序的数组比较大\",{\"1\":{\"133\":1}}],[\"如果数据范围\",{\"1\":{\"130\":1}}],[\"如果数据都被划分到一个桶里\",{\"1\":{\"129\":1}}],[\"如果数组中没有该元素\",{\"1\":{\"87\":1}}],[\"如果最大深度比较小\",{\"1\":{\"115\":1}}],[\"如果实时计算\",{\"1\":{\"115\":1}}],[\"如果递归求解的数据规模很大\",{\"1\":{\"115\":1}}],[\"如果队列已经满了\",{\"1\":{\"109\":1}}],[\"如果此时缓存已满\",{\"1\":{\"98\":1}}],[\"如果此时缓存未满\",{\"1\":{\"98\":1}}],[\"如果此数据没有在缓存链表中\",{\"1\":{\"98\":1}}],[\"如果此数据之前已经被缓存在链表中了\",{\"1\":{\"98\":1}}],[\"如果是\",{\"1\":{\"96\":1}}],[\"如果是数据中心里面的服务器\",{\"1\":{\"73\":1}}],[\"如果你确实需要使用\",{\"1\":{\"217\":1}}],[\"如果你确切知道你想使用什么类型的模型\",{\"1\":{\"161\":1}}],[\"如果你使用\",{\"1\":{\"208\":1}}],[\"如果你要复制粘贴分布式训练的代码\",{\"1\":{\"202\":1}}],[\"如果你想使用某个特定的\",{\"1\":{\"208\":1}}],[\"如果你想将仓库放到组织下\",{\"1\":{\"208\":1}}],[\"如果你想在\",{\"1\":{\"202\":1}}],[\"如果你想在训练过程中自动上传你的模型到\",{\"1\":{\"192\":1}}],[\"如果你想做进一步了解\",{\"1\":{\"153\":1}}],[\"如果你的数据集很大\",{\"1\":{\"217\":1}}],[\"如果你的\",{\"1\":{\"189\":1}}],[\"如果你的代码对内存的使用非常苛刻\",{\"1\":{\"96\":1}}],[\"如果你不想了解这些细节\",{\"1\":{\"187\":1}}],[\"如果你配置了网关\",{\"1\":{\"72\":1}}],[\"如果声明的数组过小\",{\"1\":{\"96\":1}}],[\"如果声明的数组过大\",{\"1\":{\"96\":1}}],[\"如果我们使用的交换机是支持\",{\"1\":{\"234\":1}}],[\"如果我们自定义了\",{\"1\":{\"193\":1}}],[\"如果我们想使用这种\",{\"1\":{\"168\":1}}],[\"如果我们从概率的角度分析\",{\"1\":{\"88\":1}}],[\"如果我们要找的元素刚好是数组的第一个元素\",{\"1\":{\"87\":1}}],[\"如果一段代码的时间复杂度是\",{\"1\":{\"85\":1}}],[\"如果一个广播网络里面接入了\",{\"1\":{\"230\":1}}],[\"如果一个网络管理员在网络里配置了\",{\"1\":{\"76\":1}}],[\"如果一个字节是\",{\"1\":{\"58\":1}}],[\"如果一个字符串可以和一个整数互相转换\",{\"1\":{\"3\":1}}],[\"如果对数组内元素的顺序没有要求\",{\"1\":{\"82\":1}}],[\"如果想要在每个\",{\"1\":{\"193\":1}}],[\"如果想使用\",{\"1\":{\"80\":1}}],[\"如果想让两次的结果相同\",{\"1\":{\"179\":1}}],[\"如果想让同名\",{\"1\":{\"4\":1,\"11\":1}}],[\"如果想让属性按照自定义的方式\",{\"1\":{\"3\":1}}],[\"如果有多个\",{\"1\":{\"77\":1}}],[\"如果直接将网关配置成\",{\"1\":{\"72\":1}}],[\"如果没配网关\",{\"1\":{\"72\":1}}],[\"如果没有提供\",{\"1\":{\"21\":1}}],[\"如果不想使用默认模型\",{\"1\":{\"144\":1}}],[\"如果不是一个网段的\",{\"1\":{\"72\":1}}],[\"如果不传\",{\"1\":{\"21\":1}}],[\"如果需要通过某个网络接口发送数据包\",{\"1\":{\"71\":1}}],[\"如果放不下\",{\"1\":{\"71\":1}}],[\"如果在一个被剪裁的很小的\",{\"1\":{\"71\":1}}],[\"如果提供了的话\",{\"1\":{\"21\":1}}],[\"如果什么都没找到\",{\"1\":{\"21\":1}}],[\"如果为假值\",{\"1\":{\"21\":1}}],[\"如果返回\",{\"1\":{\"21\":1}}],[\"如果类数组中有\",{\"1\":{\"21\":1}}],[\"如果\",{\"1\":{\"20\":1,\"21\":1,\"127\":3}}],[\"如果它表示一个集合\",{\"1\":{\"12\":1}}],[\"如果该\",{\"1\":{\"8\":1}}],[\"如果全局注册表中有\",{\"1\":{\"8\":1}}],[\"如果使用\",{\"1\":{\"6\":1,\"214\":1}}],[\"来获取\",{\"1\":{\"237\":1}}],[\"来获得正确的翻译\",{\"1\":{\"151\":1}}],[\"来解码\",{\"1\":{\"223\":1}}],[\"来随机抽取样本\",{\"1\":{\"222\":1}}],[\"来完成的\",{\"1\":{\"215\":1}}],[\"来添加小文件\",{\"1\":{\"214\":1}}],[\"来上传文件\",{\"1\":{\"214\":1}}],[\"来设置不同的名称\",{\"1\":{\"208\":1}}],[\"来代替\",{\"1\":{\"202\":1}}],[\"来达到同样的目的\",{\"1\":{\"194\":1}}],[\"来启动\",{\"1\":{\"193\":1}}],[\"来查看\",{\"1\":{\"188\":1}}],[\"来进行推理\",{\"1\":{\"185\":1}}],[\"来进行\",{\"1\":{\"184\":1}}],[\"来\",{\"1\":{\"182\":1}}],[\"来填充\",{\"1\":{\"179\":1}}],[\"来表示不在词表中的字词\",{\"1\":{\"168\":1}}],[\"来表示每个字词\",{\"1\":{\"168\":1}}],[\"来覆盖某门语言\",{\"1\":{\"168\":1}}],[\"来确定模型结构\",{\"1\":{\"161\":1}}],[\"来实例化\",{\"1\":{\"172\":1}}],[\"来实例化任何模型\",{\"1\":{\"161\":1}}],[\"来实现\",{\"1\":{\"179\":1}}],[\"来实现在上一节中\",{\"1\":{\"154\":1}}],[\"来实现公平锁\",{\"1\":{\"108\":1}}],[\"来保存已经求解过的\",{\"1\":{\"116\":1}}],[\"来提高数据的处理效率\",{\"1\":{\"109\":1}}],[\"来这个\",{\"1\":{\"73\":1}}],[\"来说的一个\",{\"1\":{\"169\":1}}],[\"来说\",{\"1\":{\"72\":1,\"169\":1,\"179\":1}}],[\"来统一表示所有的字符\",{\"1\":{\"66\":1}}],[\"来指代\",{\"1\":{\"45\":1}}],[\"来强调\",{\"1\":{\"42\":1}}],[\"来做处理\",{\"1\":{\"16\":1}}],[\"来停止\",{\"1\":{\"13\":1}}],[\"来遍历它\",{\"1\":{\"12\":1}}],[\"来调用\",{\"1\":{\"10\":1}}],[\"psychiatrist\",{\"1\":{\"222\":1}}],[\"pkl\",{\"1\":{\"218\":1}}],[\"py\",{\"1\":{\"202\":2}}],[\"python\",{\"0\":{\"209\":1},\"1\":{\"164\":2,\"206\":1,\"222\":1,\"223\":2}}],[\"pytorch\",{\"0\":{\"194\":1},\"1\":{\"156\":1,\"164\":1,\"178\":1,\"190\":1,\"195\":1,\"214\":5}}],[\"pt\",{\"1\":{\"156\":2,\"178\":2,\"184\":1}}],[\"p+1\",{\"1\":{\"126\":2,\"127\":5}}],[\"p++\",{\"1\":{\"125\":2}}],[\"pickled\",{\"1\":{\"218\":1}}],[\"pip\",{\"1\":{\"192\":2}}],[\"pipeline\",{\"0\":{\"155\":1},\"1\":{\"144\":6,\"145\":2,\"153\":1,\"154\":1,\"155\":1,\"156\":3,\"185\":1}}],[\"pivot\",{\"1\":{\"126\":11,\"127\":1}}],[\"ping\",{\"1\":{\"72\":1}}],[\"pineapple\",{\"1\":{\"19\":2}}],[\"pxelinux\",{\"1\":{\"80\":1,\"81\":2}}],[\"pxe\",{\"0\":{\"80\":1,\"81\":1},\"1\":{\"80\":13,\"81\":10}}],[\"pfifo\",{\"1\":{\"71\":2}}],[\"pull\",{\"1\":{\"213\":2}}],[\"puppeteer\",{\"1\":{\"168\":2}}],[\"put\",{\"1\":{\"116\":1}}],[\"public\",{\"1\":{\"116\":1,\"120\":1,\"121\":1,\"122\":1,\"130\":1}}],[\"pua\",{\"1\":{\"65\":1}}],[\"pushed\",{\"1\":{\"214\":1}}],[\"push\",{\"0\":{\"208\":1},\"1\":{\"15\":1,\"19\":4,\"21\":2,\"108\":1,\"192\":1,\"206\":1,\"208\":9,\"213\":2,\"214\":2}}],[\"pc\",{\"1\":{\"42\":1}}],[\"p\",{\"1\":{\"34\":2,\"94\":2,\"103\":4,\"125\":8,\"126\":3,\"127\":4,\"244\":3}}],[\"port\",{\"1\":{\"233\":1}}],[\"post\",{\"0\":{\"247\":1},\"1\":{\"212\":1}}],[\"pos\",{\"1\":{\"87\":3}}],[\"position\",{\"1\":{\"45\":1,\"162\":2}}],[\"positive\",{\"1\":{\"36\":2,\"40\":1,\"144\":2,\"159\":1,\"160\":3}}],[\"point\",{\"1\":{\"45\":1,\"64\":1}}],[\"points\",{\"1\":{\"34\":1}}],[\"pop\",{\"1\":{\"15\":1,\"19\":2,\"21\":1,\"108\":1}}],[\"peel\",{\"1\":{\"222\":1}}],[\"persistent\",{\"1\":{\"222\":1}}],[\"person\",{\"1\":{\"222\":1}}],[\"per\",{\"1\":{\"222\":2}}],[\"performing\",{\"1\":{\"33\":1}}],[\"pex\",{\"1\":{\"80\":1}}],[\"pea\",{\"1\":{\"222\":1}}],[\"peach\",{\"1\":{\"19\":2}}],[\"pear\",{\"1\":{\"19\":6}}],[\"promise\",{\"1\":{\"222\":1}}],[\"prompt\",{\"1\":{\"2\":1}}],[\"properly\",{\"1\":{\"222\":1}}],[\"progress\",{\"1\":{\"200\":2,\"202\":4}}],[\"prob\",{\"1\":{\"162\":2}}],[\"probs\",{\"1\":{\"162\":1}}],[\"prostitute\",{\"1\":{\"145\":1}}],[\"protocol\",{\"0\":{\"73\":1},\"1\":{\"233\":2}}],[\"procedure\",{\"1\":{\"215\":1}}],[\"process\",{\"1\":{\"125\":4,\"126\":4}}],[\"proc\",{\"1\":{\"71\":1,\"189\":1}}],[\"procfs\",{\"1\":{\"71\":1}}],[\"primitive\",{\"0\":{\"245\":1}}],[\"primary\",{\"1\":{\"222\":1}}],[\"priority\",{\"1\":{\"233\":1}}],[\"private\",{\"1\":{\"65\":2,\"209\":1}}],[\"printable\",{\"1\":{\"48\":1}}],[\"print\",{\"1\":{\"37\":1,\"38\":1,\"39\":1,\"40\":1,\"145\":2,\"156\":1,\"158\":1,\"159\":1,\"160\":2,\"168\":1,\"173\":1,\"174\":1,\"175\":1,\"178\":3,\"179\":3,\"180\":5,\"181\":2,\"183\":4,\"189\":2,\"193\":1,\"197\":1,\"199\":1,\"223\":1}}],[\"principal\",{\"1\":{\"33\":2}}],[\"prepare\",{\"1\":{\"202\":2}}],[\"prepre\",{\"1\":{\"117\":3}}],[\"pretrained\",{\"1\":{\"156\":2,\"157\":2,\"159\":1,\"163\":1,\"164\":2,\"171\":5,\"172\":1,\"173\":1,\"178\":4,\"179\":1,\"184\":2,\"189\":1,\"191\":1,\"192\":1,\"193\":1,\"194\":1,\"197\":1,\"202\":2,\"208\":2,\"213\":2,\"214\":4}}],[\"pretraining\",{\"1\":{\"149\":1}}],[\"previously\",{\"1\":{\"222\":1}}],[\"prev\",{\"1\":{\"94\":1}}],[\"pre\",{\"0\":{\"80\":1},\"1\":{\"117\":4}}],[\"preds\",{\"1\":{\"193\":3}}],[\"pred\",{\"1\":{\"37\":1,\"38\":1,\"39\":1,\"40\":1}}],[\"prediction\",{\"1\":{\"201\":1}}],[\"predictions=predictions\",{\"1\":{\"193\":1,\"201\":1}}],[\"predictions=preds\",{\"1\":{\"193\":1}}],[\"predictions\",{\"1\":{\"34\":1,\"160\":2,\"193\":10,\"201\":1}}],[\"predict\",{\"1\":{\"193\":3}}],[\"predictors\",{\"1\":{\"34\":1}}],[\"precision=tp+fptp​\",{\"1\":{\"38\":1}}],[\"precision\",{\"0\":{\"38\":1},\"1\":{\"36\":1,\"38\":3,\"40\":5,\"193\":1}}],[\"patient\",{\"1\":{\"222\":2}}],[\"path\",{\"1\":{\"212\":1,\"233\":1}}],[\"pain\",{\"1\":{\"222\":2}}],[\"pair\",{\"1\":{\"17\":1}}],[\"pairs\",{\"1\":{\"12\":1,\"14\":1,\"16\":1}}],[\"panic\",{\"1\":{\"222\":2}}],[\"pandas\",{\"1\":{\"217\":1,\"218\":2,\"222\":1}}],[\"parsefloat\",{\"1\":{\"243\":1}}],[\"parseint\",{\"1\":{\"243\":3}}],[\"paragraphs\",{\"1\":{\"219\":3}}],[\"parameters\",{\"1\":{\"198\":1,\"202\":2}}],[\"paraphrase\",{\"1\":{\"187\":1}}],[\"partition\",{\"1\":{\"126\":3}}],[\"pad\",{\"1\":{\"162\":1,\"179\":3,\"180\":4,\"189\":1}}],[\"padding=\",{\"1\":{\"180\":3,\"202\":1}}],[\"padding=true\",{\"1\":{\"156\":1,\"178\":3,\"184\":1,\"189\":1}}],[\"padding\",{\"0\":{\"179\":1,\"190\":1},\"1\":{\"156\":1,\"179\":7,\"180\":1,\"182\":1,\"184\":1,\"189\":4,\"190\":4}}],[\"page\",{\"1\":{\"44\":1}}],[\"package\",{\"1\":{\"29\":1}}],[\"please\",{\"1\":{\"192\":1}}],[\"plane\",{\"1\":{\"64\":1,\"65\":2}}],[\"plane平面\",{\"1\":{\"45\":1}}],[\"place\",{\"1\":{\"21\":2,\"118\":1}}],[\"plum\",{\"1\":{\"19\":5}}],[\"对模型进行微调\",{\"1\":{\"208\":1}}],[\"对应的mac\",{\"1\":{\"231\":1}}],[\"对应的机器来回应自己\",{\"1\":{\"230\":1}}],[\"对应的代码\",{\"1\":{\"195\":1}}],[\"对应的函数\",{\"1\":{\"13\":1}}],[\"对句子中的每个词语进行分类\",{\"1\":{\"141\":1}}],[\"对整个句子进行分类\",{\"1\":{\"141\":1}}],[\"对两部分分别排序\",{\"1\":{\"125\":1}}],[\"对相邻数据做操作\",{\"1\":{\"120\":1}}],[\"对头结点和尾结点的特殊处理\",{\"1\":{\"103\":1}}],[\"对链表进行频繁的插入\",{\"1\":{\"96\":1}}],[\"对一个数据结构进行一组连续操作中\",{\"1\":{\"89\":1}}],[\"对数阶\",{\"1\":{\"85\":1}}],[\"对数组用\",{\"1\":{\"21\":1}}],[\"对数组进行\",{\"1\":{\"21\":1}}],[\"对外数据通路的数据总线宽度决定\",{\"1\":{\"42\":1}}],[\"对于支持\",{\"1\":{\"234\":1}}],[\"对于预测没有提供相对有用的信息\",{\"1\":{\"223\":1}}],[\"对于大文件\",{\"1\":{\"211\":1,\"214\":1}}],[\"对于大部分资源有限的场景\",{\"1\":{\"111\":1}}],[\"对于基础的微调来说表现得也很不错\",{\"1\":{\"192\":1}}],[\"对于短的序列\",{\"1\":{\"179\":1}}],[\"对于第一个句子\",{\"1\":{\"160\":1}}],[\"对于具体问题\",{\"1\":{\"147\":1}}],[\"对于一个给定\",{\"1\":{\"142\":1}}],[\"对于一个有序链表\",{\"1\":{\"94\":1}}],[\"对于其他类型\",{\"1\":{\"130\":1}}],[\"对于归并排序\",{\"1\":{\"125\":1}}],[\"对于冒泡和插入\",{\"1\":{\"123\":1}}],[\"对于u\",{\"1\":{\"47\":1}}],[\"对于对象\",{\"1\":{\"21\":1}}],[\"对于\",{\"1\":{\"14\":1,\"16\":1,\"29\":2,\"46\":1,\"47\":1,\"72\":1,\"126\":1,\"169\":1,\"179\":1,\"211\":1,\"241\":1}}],[\"对于无穷迭代器\",{\"1\":{\"13\":1}}],[\"对其进行遍历\",{\"1\":{\"14\":1}}],[\"对\",{\"1\":{\"12\":1,\"130\":2,\"208\":1,\"238\":1}}],[\"对象可以相减\",{\"1\":{\"245\":1}}],[\"对象构造器\",{\"1\":{\"241\":1}}],[\"对象呢\",{\"1\":{\"219\":1}}],[\"对象\",{\"0\":{\"245\":1},\"1\":{\"156\":1,\"188\":1,\"219\":1,\"222\":1}}],[\"对象本身不是数组\",{\"1\":{\"12\":1}}],[\"对象时\",{\"1\":{\"6\":1}}],[\"对象的\",{\"1\":{\"4\":1,\"208\":1,\"240\":1}}],[\"对象属性\",{\"1\":{\"4\":1,\"11\":1}}],[\"它可以转发属于任何\",{\"1\":{\"234\":1}}],[\"它可以减少\",{\"1\":{\"168\":1}}],[\"它也不知道网络的拓扑信息\",{\"1\":{\"232\":1}}],[\"它也有\",{\"1\":{\"157\":1}}],[\"它使用\",{\"1\":{\"212\":1}}],[\"它包含\",{\"1\":{\"192\":1}}],[\"它接收一个\",{\"1\":{\"190\":1}}],[\"它把你的数据集转化为\",{\"1\":{\"190\":1}}],[\"它不会将整个\",{\"1\":{\"189\":1}}],[\"它有\",{\"1\":{\"188\":1}}],[\"它有以下三个维度\",{\"1\":{\"158\":1}}],[\"它和\",{\"1\":{\"180\":1,\"198\":1,\"222\":1}}],[\"它必须是矩阵\",{\"1\":{\"179\":1}}],[\"它根据\",{\"1\":{\"161\":1}}],[\"它会记住\",{\"1\":{\"231\":1}}],[\"它会生成\",{\"1\":{\"208\":1}}],[\"它会下载对应模型的\",{\"1\":{\"156\":1}}],[\"它会调用这个方法\",{\"1\":{\"13\":1}}],[\"它聚合了预训练模型和对应的文本预处理\",{\"1\":{\"144\":1}}],[\"它是大规模意大利语问答数据集\",{\"1\":{\"219\":1}}],[\"它是构建\",{\"1\":{\"190\":1}}],[\"它是怎么处理数字输入并输出预测的\",{\"1\":{\"154\":1}}],[\"它是\",{\"1\":{\"142\":1,\"187\":1}}],[\"它是通过\",{\"1\":{\"12\":1}}],[\"它表示的是小于\",{\"1\":{\"126\":1}}],[\"它表示数字区间\",{\"1\":{\"13\":1}}],[\"它将输入的文本转化为数字\",{\"1\":{\"165\":1}}],[\"它将接受哪一台服务器提供的\",{\"1\":{\"77\":1}}],[\"它将被分发给该网段上的所有计算机\",{\"1\":{\"70\":1}}],[\"它就没那么有针对性了\",{\"1\":{\"147\":1}}],[\"它就相当于这些\",{\"1\":{\"76\":1}}],[\"它就调用这个对象的\",{\"1\":{\"13\":1}}],[\"它都需要按照为这个接口配置的\",{\"1\":{\"71\":1}}],[\"它容纳的字符太少\",{\"1\":{\"55\":1}}],[\"它的目标是找到最有意义的表示\",{\"1\":{\"166\":1}}],[\"它的主要特点是在\",{\"1\":{\"61\":1}}],[\"它的\",{\"1\":{\"46\":1}}],[\"它赋予precision\",{\"1\":{\"40\":1}}],[\"它们的区别在于\",{\"1\":{\"127\":1}}],[\"它们的时间复杂度都是\",{\"1\":{\"123\":1}}],[\"它们都表示\",{\"1\":{\"66\":1}}],[\"它们也会将没有用到过的引用移除掉\",{\"1\":{\"25\":1}}],[\"它们会将\",{\"1\":{\"25\":1}}],[\"它们是不同的字符串\",{\"1\":{\"20\":1}}],[\"它们才相等\",{\"1\":{\"20\":1}}],[\"它们内置的可迭代对象\",{\"1\":{\"12\":1}}],[\"它返回的对象有\",{\"1\":{\"193\":1}}],[\"它返回\",{\"1\":{\"17\":1}}],[\"它既是\",{\"1\":{\"15\":1}}],[\"内置的\",{\"1\":{\"240\":1}}],[\"内置了很多系统\",{\"1\":{\"10\":1}}],[\"内存有限\",{\"1\":{\"129\":1}}],[\"内存不足\",{\"1\":{\"96\":1}}],[\"内核\",{\"1\":{\"81\":1}}],[\"内部实现了\",{\"1\":{\"12\":1}}],[\"和数字\",{\"1\":{\"241\":1}}],[\"和机器\",{\"1\":{\"232\":1}}],[\"和多\",{\"1\":{\"193\":1}}],[\"和我们之前使用\",{\"1\":{\"192\":1}}],[\"和预训练模型来进行推理\",{\"1\":{\"186\":1}}],[\"和编码\",{\"1\":{\"175\":1}}],[\"和源\",{\"1\":{\"72\":1}}],[\"和码点编号为u+0300的组合字符读音符号\",{\"1\":{\"45\":1}}],[\"和\",{\"0\":{\"70\":1,\"204\":1},\"1\":{\"12\":1,\"15\":1,\"16\":1,\"17\":1,\"19\":1,\"21\":3,\"22\":1,\"24\":1,\"40\":1,\"53\":1,\"54\":1,\"56\":1,\"65\":1,\"66\":1,\"71\":2,\"109\":1,\"125\":3,\"151\":1,\"152\":1,\"154\":1,\"168\":2,\"171\":1,\"180\":2,\"181\":1,\"183\":1,\"184\":1,\"185\":1,\"188\":1,\"189\":1,\"192\":1,\"193\":3,\"203\":1,\"208\":2,\"211\":1,\"213\":4,\"214\":4,\"219\":1,\"222\":3,\"232\":1,\"239\":1}}],[\"当进行数学运算时进行数值转换\",{\"1\":{\"245\":1}}],[\"当进行批处理时\",{\"1\":{\"179\":1}}],[\"当跟\",{\"1\":{\"241\":1}}],[\"当交换机把二层的头取下来时就可以识别\",{\"1\":{\"234\":1}}],[\"当机器\",{\"1\":{\"232\":1}}],[\"当机器数多的时候\",{\"1\":{\"231\":1}}],[\"当包到达交换机时\",{\"1\":{\"231\":1}}],[\"当你调用\",{\"1\":{\"208\":1}}],[\"当在\",{\"1\":{\"192\":1}}],[\"当然每个用户需要一个\",{\"1\":{\"234\":1}}],[\"当然你也可以将\",{\"1\":{\"163\":1}}],[\"当然\",{\"1\":{\"157\":1,\"169\":1}}],[\"当然我们也可以让\",{\"1\":{\"13\":1}}],[\"当点击回退时\",{\"1\":{\"139\":1}}],[\"当按顺序访问页面\",{\"1\":{\"139\":1}}],[\"当扫描到右括号时\",{\"1\":{\"138\":1}}],[\"当扫描到左括号时\",{\"1\":{\"138\":1}}],[\"当被调用函数执行完成\",{\"1\":{\"136\":1}}],[\"当要排序的\",{\"1\":{\"130\":1}}],[\"当要处理的数据具有环型结构的特点时\",{\"1\":{\"93\":1}}],[\"当桶的个数\",{\"1\":{\"129\":1}}],[\"当相邻元素大小相等时\",{\"1\":{\"120\":1}}],[\"当调用栈比较深时\",{\"1\":{\"116\":1}}],[\"当递归调用到\",{\"1\":{\"116\":1}}],[\"当递归调用超过一定深度之后\",{\"1\":{\"115\":1}}],[\"当没有空闲资源时\",{\"1\":{\"111\":1}}],[\"当代码执行万次\",{\"1\":{\"103\":1}}],[\"当有一个新的数据被访问时\",{\"1\":{\"98\":1}}],[\"当数组没有更多空间存储数据时\",{\"1\":{\"82\":1}}],[\"当一台机器新加入一个网络时\",{\"1\":{\"75\":1}}],[\"当配置的地址不在同一个网段时\",{\"1\":{\"72\":1}}],[\"当发出一个目的地址为\",{\"1\":{\"70\":1}}],[\"当第一个比特位为\",{\"1\":{\"55\":2}}],[\"当我们将全部\",{\"1\":{\"201\":1}}],[\"当我们写\",{\"1\":{\"29\":1}}],[\"当我们使用外部的\",{\"1\":{\"6\":1}}],[\"当前进时\",{\"1\":{\"139\":1}}],[\"当前索引\",{\"1\":{\"21\":1}}],[\"当前的数组元素\",{\"1\":{\"21\":1}}],[\"当使用\",{\"1\":{\"13\":1}}],[\"当\",{\"1\":{\"12\":1,\"13\":2,\"40\":2,\"78\":1,\"125\":1}}],[\"dperessed\",{\"1\":{\"222\":1}}],[\"daily\",{\"1\":{\"222\":2}}],[\"day\",{\"1\":{\"222\":2}}],[\"date\",{\"1\":{\"214\":1,\"245\":1}}],[\"dataframe\",{\"1\":{\"218\":1}}],[\"dataframes\",{\"1\":{\"218\":1}}],[\"datacollatorwithpadding\",{\"1\":{\"190\":3,\"191\":2,\"192\":1,\"194\":2}}],[\"dataloader\",{\"0\":{\"196\":1},\"1\":{\"190\":1,\"196\":6,\"197\":1,\"199\":2,\"200\":1,\"201\":1,\"202\":8}}],[\"dataset=tokenized\",{\"1\":{\"192\":2,\"193\":2}}],[\"datasetdict\",{\"1\":{\"188\":2,\"189\":1,\"219\":4,\"222\":2}}],[\"dataset\",{\"1\":{\"188\":9,\"189\":6,\"191\":4,\"194\":2,\"195\":1,\"209\":2,\"217\":1,\"218\":4,\"219\":14,\"220\":2,\"222\":21,\"223\":10,\"224\":1}}],[\"datasets\",{\"0\":{\"217\":1},\"1\":{\"30\":1,\"187\":1,\"188\":6,\"189\":8,\"190\":1,\"191\":2,\"192\":3,\"193\":3,\"194\":4,\"195\":8,\"196\":2,\"203\":1,\"209\":1,\"216\":1,\"217\":2,\"218\":1,\"219\":2,\"222\":2,\"223\":1}}],[\"data\",{\"1\":{\"34\":1,\"190\":3,\"191\":1,\"192\":4,\"193\":1,\"194\":1,\"196\":1,\"215\":1,\"218\":5,\"219\":10,\"220\":4,\"222\":2,\"233\":1}}],[\"due\",{\"1\":{\"222\":5}}],[\"dummy\",{\"1\":{\"208\":5,\"209\":2,\"212\":1,\"213\":6,\"214\":7}}],[\"dry\",{\"1\":{\"222\":2}}],[\"druglibtest\",{\"1\":{\"222\":1}}],[\"druglibtrain\",{\"1\":{\"222\":1}}],[\"drug\",{\"1\":{\"222\":13,\"223\":8}}],[\"dropout\",{\"1\":{\"162\":3}}],[\"dkv\",{\"1\":{\"219\":1}}],[\"dl\",{\"1\":{\"202\":4}}],[\"dtype=\",{\"1\":{\"188\":3}}],[\"d\",{\"1\":{\"132\":1}}],[\"dn\",{\"1\":{\"132\":1}}],[\"ddns\",{\"1\":{\"80\":1}}],[\"dynamic\",{\"0\":{\"73\":1,\"190\":1},\"1\":{\"80\":1,\"189\":1}}],[\"dhcp\",{\"0\":{\"73\":1,\"74\":1,\"75\":1,\"76\":1,\"77\":1,\"78\":1},\"1\":{\"73\":2,\"75\":2,\"76\":7,\"77\":8,\"78\":3,\"79\":3,\"80\":6,\"81\":3}}],[\"d类地址\",{\"1\":{\"70\":1}}],[\"dbcs\",{\"1\":{\"62\":1}}],[\"do\",{\"1\":{\"214\":1}}],[\"dogs\",{\"1\":{\"168\":1}}],[\"dog\",{\"1\":{\"168\":1}}],[\"doctors\",{\"1\":{\"222\":2}}],[\"doctor\",{\"1\":{\"145\":1,\"222\":1}}],[\"doubled\",{\"1\":{\"222\":1}}],[\"double\",{\"1\":{\"42\":1,\"62\":1}}],[\"done=true\",{\"1\":{\"13\":1}}],[\"done\",{\"1\":{\"12\":2,\"13\":5,\"14\":1,\"17\":2,\"222\":1}}],[\"dword\",{\"1\":{\"42\":1}}],[\"diet\",{\"1\":{\"222\":1}}],[\"dicing\",{\"0\":{\"222\":1}}],[\"dictionary\",{\"1\":{\"164\":1}}],[\"different\",{\"1\":{\"208\":1}}],[\"dimension\",{\"1\":{\"178\":1}}],[\"dim=\",{\"1\":{\"160\":1,\"201\":1}}],[\"directory\",{\"1\":{\"164\":2,\"171\":1}}],[\"digit\",{\"1\":{\"42\":1}}],[\"distorting\",{\"1\":{\"188\":2}}],[\"distilbert\",{\"1\":{\"156\":2,\"157\":2,\"159\":1,\"178\":2,\"180\":1,\"181\":1,\"184\":1}}],[\"distillbert\",{\"1\":{\"150\":1}}],[\"distilgpt2\",{\"1\":{\"144\":1}}],[\"distinct\",{\"1\":{\"34\":1}}],[\"disruptor\",{\"1\":{\"108\":1}}],[\"discover\",{\"0\":{\"75\":1},\"1\":{\"75\":1}}],[\"discipline\",{\"1\":{\"71\":1}}],[\"discriminant\",{\"1\":{\"33\":1}}],[\"dfsjh\",{\"1\":{\"35\":1}}],[\"designated\",{\"1\":{\"233\":1}}],[\"description\",{\"0\":{\"9\":1},\"1\":{\"5\":3,\"8\":1,\"215\":1,\"240\":1}}],[\"def\",{\"1\":{\"189\":1,\"191\":1,\"193\":1,\"194\":1,\"222\":1,\"223\":1}}],[\"default\",{\"0\":{\"27\":1,\"28\":1},\"1\":{\"28\":6,\"29\":9,\"71\":1,\"80\":1}}],[\"dequeue\",{\"1\":{\"108\":1,\"110\":1}}],[\"device\",{\"1\":{\"71\":1,\"200\":6,\"201\":1,\"202\":8}}],[\"decay\",{\"1\":{\"198\":1}}],[\"decoding\",{\"0\":{\"175\":1},\"1\":{\"175\":1}}],[\"decoded\",{\"1\":{\"175\":2}}],[\"decoder\",{\"1\":{\"150\":3,\"152\":7}}],[\"decoders\",{\"1\":{\"150\":1}}],[\"decode\",{\"1\":{\"42\":1,\"47\":1,\"175\":3,\"183\":3}}],[\"decimal\",{\"1\":{\"52\":1}}],[\"depression\",{\"1\":{\"222\":4}}],[\"dependent\",{\"1\":{\"34\":1}}],[\"depth\",{\"1\":{\"21\":1,\"115\":2}}],[\"deep\",{\"1\":{\"33\":1}}],[\"deliberately\",{\"1\":{\"188\":2}}],[\"delimiter=\",{\"1\":{\"222\":1}}],[\"delimiter\",{\"1\":{\"222\":1}}],[\"delim\",{\"1\":{\"21\":1}}],[\"deletecount\",{\"1\":{\"21\":2}}],[\"delete\",{\"1\":{\"2\":2,\"209\":2}}],[\"函数将一次处理多个数据\",{\"1\":{\"224\":1}}],[\"函数了\",{\"1\":{\"193\":1}}],[\"函数加载与\",{\"1\":{\"193\":1}}],[\"函数并传递给了\",{\"1\":{\"193\":1}}],[\"函数并在训练时使用它\",{\"1\":{\"193\":1}}],[\"函数提供计算模型性能的方法\",{\"1\":{\"192\":1}}],[\"函数的处理方式是想数据集中添加新的字段\",{\"1\":{\"189\":1}}],[\"函数来实现这一点\",{\"1\":{\"156\":1}}],[\"函数来执行不同的\",{\"1\":{\"153\":1}}],[\"函数实际上经过了以下几个步骤\",{\"1\":{\"155\":1}}],[\"函数完成的任务\",{\"1\":{\"154\":1}}],[\"函数调用栈\",{\"0\":{\"136\":1}}],[\"函数调用会使用栈来保存临时变量\",{\"1\":{\"115\":1}}],[\"函数返回的\",{\"1\":{\"193\":1}}],[\"函数返回\",{\"1\":{\"12\":1}}],[\"函数\",{\"1\":{\"12\":1,\"24\":1,\"125\":1,\"126\":1,\"144\":1,\"193\":1}}],[\"返回之后\",{\"1\":{\"136\":1}}],[\"返回\",{\"1\":{\"21\":1,\"103\":1}}],[\"返回排序后的数组\",{\"1\":{\"21\":1}}],[\"返回满足条件的元素组成的数组\",{\"1\":{\"21\":1}}],[\"返回满足条件的第一个元素\",{\"1\":{\"21\":1}}],[\"返回被删除的元素所组成的数组\",{\"1\":{\"21\":1}}],[\"返回迭代器\",{\"1\":{\"13\":1}}],[\"返回一迭代器\",{\"1\":{\"12\":1}}],[\"返回的是\",{\"1\":{\"4\":1,\"11\":1}}],[\"注\",{\"1\":{\"21\":1,\"24\":1,\"53\":1,\"65\":1,\"187\":1}}],[\"注意力层使得模型对不同位置的字词有着不同的关注程度\",{\"1\":{\"151\":1}}],[\"注意力层\",{\"0\":{\"151\":1}}],[\"注意将元素插到相同元素的后面\",{\"1\":{\"121\":1}}],[\"注意不是空格\",{\"1\":{\"53\":1}}],[\"注意\",{\"1\":{\"11\":1,\"116\":1,\"145\":1,\"152\":1,\"157\":1,\"172\":1,\"175\":1,\"192\":1}}],[\"注册表\",{\"1\":{\"7\":1}}],[\"其他交换机只能转\",{\"1\":{\"233\":1}}],[\"其他属性按照创建的顺序显示\",{\"1\":{\"3\":1}}],[\"其编码也都是\",{\"1\":{\"66\":1}}],[\"其余的都是\",{\"1\":{\"214\":1}}],[\"其余的参数都可以设置为默认值\",{\"1\":{\"192\":1}}],[\"其余的字符全部重新统一编码\",{\"1\":{\"66\":1}}],[\"其余的是一些标点符号\",{\"1\":{\"53\":1}}],[\"其值必须大于\",{\"1\":{\"59\":1}}],[\"其内共包含了\",{\"1\":{\"56\":1}}],[\"其中会填上你的\",{\"1\":{\"208\":1}}],[\"其中的模型不局限于\",{\"1\":{\"204\":1}}],[\"其中的所有元素都会被复制\",{\"1\":{\"21\":1}}],[\"其中记录了模型的权重\",{\"1\":{\"164\":1}}],[\"其中一级汉字\",{\"1\":{\"59\":1}}],[\"其中\",{\"1\":{\"53\":1,\"56\":1,\"103\":1,\"121\":1,\"125\":1,\"165\":1}}],[\"其中包含来自于其他数组和其他项的值\",{\"1\":{\"21\":1}}],[\"其中使用\",{\"1\":{\"10\":1}}],[\"urldrugname\",{\"1\":{\"222\":1}}],[\"url\",{\"1\":{\"220\":4}}],[\"ubuntu\",{\"1\":{\"219\":1}}],[\"utils\",{\"1\":{\"196\":1}}],[\"utf16\",{\"1\":{\"238\":1}}],[\"utf\",{\"0\":{\"66\":1},\"1\":{\"46\":3,\"47\":3,\"49\":3,\"58\":6,\"66\":6,\"238\":2}}],[\"u\",{\"1\":{\"192\":2}}],[\"u`\",{\"1\":{\"192\":1}}],[\"upon\",{\"1\":{\"222\":1}}],[\"upload\",{\"0\":{\"212\":1},\"1\":{\"209\":1,\"212\":3}}],[\"updates\",{\"1\":{\"80\":1}}],[\"update\",{\"1\":{\"80\":1,\"200\":1,\"202\":2,\"209\":1}}],[\"up>\",{\"1\":{\"71\":1}}],[\"up\",{\"1\":{\"71\":4,\"180\":3,\"214\":1}}],[\"u+0000~u+00ff\",{\"1\":{\"67\":1}}],[\"u+0000~u+007f\",{\"1\":{\"67\":1}}],[\"u+0041\",{\"1\":{\"67\":1}}],[\"u+\",{\"1\":{\"67\":1}}],[\"u+100000~u+10fffd\",{\"1\":{\"65\":1}}],[\"u+f0000~u+ffffd\",{\"1\":{\"65\":1}}],[\"u+e000~u+f8ff\",{\"1\":{\"65\":1}}],[\"ucs\",{\"1\":{\"42\":1}}],[\"unescape\",{\"1\":{\"223\":2}}],[\"unable\",{\"1\":{\"222\":1}}],[\"unnamed\",{\"1\":{\"222\":5}}],[\"unk\",{\"1\":{\"168\":1}}],[\"unknown\",{\"1\":{\"168\":4,\"169\":1}}],[\"uncased\",{\"1\":{\"145\":1,\"156\":2,\"157\":2,\"159\":1,\"178\":2,\"184\":1,\"189\":1,\"191\":1,\"194\":1}}],[\"unmasker\",{\"1\":{\"145\":3}}],[\"unbounded\",{\"1\":{\"111\":1}}],[\"unique\",{\"1\":{\"222\":2}}],[\"unix\",{\"1\":{\"219\":1}}],[\"unigram\",{\"1\":{\"170\":1}}],[\"unit\",{\"1\":{\"46\":2,\"49\":1,\"233\":1}}],[\"unicode字符集中的\",{\"1\":{\"67\":1}}],[\"unicode字符集的字符编码方式一开始规定\",{\"1\":{\"66\":1}}],[\"unicode字符集的目标是涵盖目前人类使用的所有字符\",{\"1\":{\"64\":1}}],[\"unicode字符集将所有字符按照使用上的频繁度\",{\"1\":{\"64\":1}}],[\"unicode字符编号为\",{\"1\":{\"47\":1}}],[\"unicode\",{\"0\":{\"63\":1},\"1\":{\"42\":1,\"44\":1,\"45\":4,\"46\":2,\"65\":4,\"66\":1,\"67\":1}}],[\"unstage\",{\"1\":{\"214\":1}}],[\"unsupervised\",{\"1\":{\"33\":1}}],[\"unshift\",{\"1\":{\"19\":4,\"21\":1}}],[\"undefined\",{\"0\":{\"237\":1},\"1\":{\"9\":1,\"19\":1,\"20\":1,\"21\":2,\"236\":1,\"237\":4}}],[\"udp\",{\"1\":{\"74\":1,\"75\":2}}],[\"ud83d\",{\"1\":{\"16\":1}}],[\"udcb3\",{\"1\":{\"16\":1}}],[\"using\",{\"1\":{\"171\":1,\"173\":2,\"175\":1,\"192\":1}}],[\"uses\",{\"1\":{\"215\":1}}],[\"used\",{\"1\":{\"98\":1}}],[\"use\",{\"1\":{\"34\":1,\"65\":2,\"162\":1,\"208\":1,\"214\":1,\"215\":1,\"222\":2}}],[\"username\",{\"1\":{\"214\":1}}],[\"users\",{\"1\":{\"21\":3}}],[\"user\",{\"1\":{\"2\":11,\"6\":9,\"21\":6,\"27\":3,\"28\":10,\"29\":11,\"209\":1}}],[\"usa\",{\"1\":{\"3\":1}}],[\"可通过\",{\"1\":{\"144\":1}}],[\"可读性太差\",{\"1\":{\"103\":1}}],[\"可在这里查询\",{\"1\":{\"67\":1}}],[\"可被分配给不同的字符\",{\"1\":{\"65\":1}}],[\"可显示可打印字符\",{\"1\":{\"53\":1}}],[\"可显示但不可打印的空格字符\",{\"1\":{\"53\":1}}],[\"可能不会有\",{\"1\":{\"189\":1}}],[\"可能被切分成\",{\"1\":{\"170\":1}}],[\"可能有十几个\",{\"1\":{\"169\":1}}],[\"可能本身没有含义\",{\"1\":{\"169\":1}}],[\"可能要\",{\"1\":{\"133\":1}}],[\"可能是患者的\",{\"1\":{\"222\":1}}],[\"可能是\",{\"1\":{\"156\":1}}],[\"可能是指\",{\"1\":{\"142\":1}}],[\"可能是出于显示上视觉美观的考虑\",{\"1\":{\"59\":1}}],[\"可能是在代码中的另一个位置\",{\"1\":{\"8\":1}}],[\"可能具有\",{\"1\":{\"49\":1}}],[\"可能指\",{\"1\":{\"47\":1}}],[\"可迭代\",{\"0\":{\"15\":1}}],[\"可迭代对象\",{\"0\":{\"12\":1},\"1\":{\"12\":1,\"17\":1}}],[\"可以修改\",{\"1\":{\"237\":1}}],[\"可以划分\",{\"1\":{\"234\":1}}],[\"可以准确转发\",{\"1\":{\"231\":1}}],[\"可以配置\",{\"1\":{\"224\":1}}],[\"可以传入\",{\"1\":{\"223\":1}}],[\"可以是单个文件路径\",{\"1\":{\"219\":1}}],[\"可以观察到\",{\"1\":{\"214\":1}}],[\"可以发\",{\"1\":{\"233\":1}}],[\"可以发现\",{\"1\":{\"214\":1}}],[\"可以发送广播包\",{\"1\":{\"71\":1}}],[\"可以指定\",{\"1\":{\"209\":1}}],[\"可以尝试下面方法\",{\"1\":{\"192\":1}}],[\"可以通过传递\",{\"1\":{\"189\":1}}],[\"可以通过查看\",{\"1\":{\"188\":1}}],[\"可以在\",{\"1\":{\"179\":1,\"192\":1,\"205\":1}}],[\"可以在全局注册表中寻找其\",{\"1\":{\"4\":1,\"11\":1}}],[\"可以使用进度条\",{\"1\":{\"200\":1}}],[\"可以使用\",{\"1\":{\"175\":1,\"181\":1,\"193\":1,\"214\":1,\"222\":1,\"223\":1}}],[\"可以使用空格来将句子切分为字词\",{\"1\":{\"168\":1}}],[\"可以接收很多参数\",{\"1\":{\"165\":1}}],[\"可以\",{\"1\":{\"152\":1}}],[\"可以把第一个的走法分为两类\",{\"1\":{\"114\":1}}],[\"可以实现非常高效的并发队列\",{\"1\":{\"110\":1}}],[\"可以有效地协调生产和消费的速度\",{\"1\":{\"109\":1}}],[\"可以借助\",{\"1\":{\"96\":1}}],[\"可以先记录下已经删除的数据\",{\"1\":{\"82\":1}}],[\"可以自行安装\",{\"1\":{\"71\":1}}],[\"可以自定义顺序进行排序\",{\"1\":{\"21\":1}}],[\"可以并存于同一个文件内\",{\"1\":{\"62\":1}}],[\"可以绘出混淆矩阵\",{\"1\":{\"36\":1}}],[\"可以从统一的位置进行\",{\"1\":{\"29\":1}}],[\"可以不指定被导出实体的名称\",{\"1\":{\"28\":1}}],[\"可以正确处理\",{\"1\":{\"21\":1}}],[\"可以一次添加多个元素\",{\"1\":{\"19\":1}}],[\"可以将序列转化成特定结构的\",{\"1\":{\"178\":1}}],[\"可以将\",{\"1\":{\"16\":1,\"193\":1}}],[\"可以创建无穷迭代器\",{\"1\":{\"13\":1}}],[\"可以用来进行\",{\"1\":{\"193\":1}}],[\"可以用桶排序或计数排序\",{\"1\":{\"131\":1}}],[\"可以用\",{\"1\":{\"12\":1,\"17\":1}}],[\"可以用以下方法\",{\"1\":{\"6\":1}}],[\"可以参考\",{\"1\":{\"10\":1}}],[\"可以返回对象所有键\",{\"1\":{\"6\":1,\"11\":1}}],[\"可以获取所有的\",{\"1\":{\"6\":1,\"11\":1}}],[\"可以避免属性名冲突\",{\"1\":{\"6\":1}}],[\"的绝对值较大或较小时\",{\"1\":{\"244\":1}}],[\"的第二个参数\",{\"1\":{\"243\":1}}],[\"的各种操作如\",{\"1\":{\"238\":1}}],[\"的交换机\",{\"1\":{\"234\":1}}],[\"的包是看不到的\",{\"1\":{\"234\":1}}],[\"的包才会互相转发\",{\"1\":{\"234\":1}}],[\"的协议\",{\"1\":{\"233\":1}}],[\"的阶段\",{\"1\":{\"230\":1}}],[\"的词数较少时\",{\"1\":{\"223\":1}}],[\"的这个想法是正确的\",{\"1\":{\"222\":1}}],[\"的猜想\",{\"1\":{\"222\":1}}],[\"的区别在于\",{\"1\":{\"222\":1}}],[\"的变体\",{\"1\":{\"222\":1}}],[\"的匹配规则选择多有满足规则的文件\",{\"1\":{\"219\":1}}],[\"的重要作用\",{\"1\":{\"215\":1}}],[\"的大小超过了\",{\"1\":{\"214\":1}}],[\"的大小关系\",{\"1\":{\"94\":1}}],[\"的版本是最新的\",{\"1\":{\"213\":1}}],[\"的文件管理系统基于\",{\"1\":{\"211\":1}}],[\"的登录命令\",{\"1\":{\"209\":1}}],[\"的仓库\",{\"1\":{\"208\":1}}],[\"的加速\",{\"1\":{\"202\":1}}],[\"的线性衰减\",{\"1\":{\"199\":1}}],[\"的默认\",{\"1\":{\"198\":1}}],[\"的格式设为\",{\"1\":{\"195\":1}}],[\"的格式如下\",{\"1\":{\"76\":1}}],[\"的路径\",{\"1\":{\"192\":1}}],[\"的最大长度是\",{\"1\":{\"238\":1}}],[\"的最大长度为\",{\"1\":{\"190\":1}}],[\"的最大值的取出\",{\"1\":{\"193\":1}}],[\"的最后确认\",{\"1\":{\"77\":1}}],[\"的函数称为\",{\"1\":{\"190\":1}}],[\"的值是\",{\"1\":{\"189\":1}}],[\"的值总是不同的\",{\"1\":{\"4\":1,\"11\":1}}],[\"的十个数据集之一\",{\"1\":{\"187\":1}}],[\"的限制\",{\"1\":{\"185\":1}}],[\"的组成\",{\"1\":{\"185\":1}}],[\"的基本步骤\",{\"1\":{\"217\":1}}],[\"的基本结构\",{\"1\":{\"185\":1}}],[\"的基础上又进行了扩充\",{\"1\":{\"61\":1}}],[\"的类型\",{\"1\":{\"182\":1}}],[\"的原子操作\",{\"1\":{\"176\":1}}],[\"的原则是\",{\"1\":{\"170\":1}}],[\"的该过程相反\",{\"1\":{\"175\":1}}],[\"的两个步骤分别做了什么\",{\"1\":{\"172\":1}}],[\"的分为两步\",{\"1\":{\"172\":1}}],[\"的分组时\",{\"1\":{\"70\":1}}],[\"的中间方法\",{\"1\":{\"171\":1}}],[\"的产生\",{\"1\":{\"168\":1}}],[\"的映射要有\",{\"1\":{\"168\":1}}],[\"的作用是将文本转化为模型可以处理的数字\",{\"1\":{\"166\":1}}],[\"的来源或路径\",{\"1\":{\"164\":1}}],[\"的内容\",{\"1\":{\"162\":1}}],[\"的模型\",{\"1\":{\"159\":1}}],[\"的处理步骤\",{\"1\":{\"156\":1}}],[\"的输出是一个命名元祖\",{\"1\":{\"193\":1}}],[\"的输出是\",{\"1\":{\"193\":1}}],[\"的输出\",{\"1\":{\"152\":1}}],[\"的输入来生成第4个单词\",{\"1\":{\"152\":1}}],[\"的过去的输入\",{\"1\":{\"152\":1}}],[\"的关注度可能小一些\",{\"1\":{\"151\":1}}],[\"的目标\",{\"1\":{\"150\":1}}],[\"的结构\",{\"1\":{\"153\":1}}],[\"的结构和原理\",{\"1\":{\"150\":1}}],[\"的结果累积后就可以使用\",{\"1\":{\"201\":1}}],[\"的结果一致了\",{\"1\":{\"180\":1}}],[\"的结果不一样\",{\"1\":{\"179\":1}}],[\"的结果的第二行与\",{\"1\":{\"179\":1}}],[\"的结果所消耗的时间\",{\"1\":{\"125\":1}}],[\"的结果\",{\"1\":{\"125\":1}}],[\"的结果被称为\",{\"1\":{\"17\":1}}],[\"的方式\",{\"1\":{\"214\":1}}],[\"的方式管理本地仓库\",{\"1\":{\"213\":1}}],[\"的方式在大量文本上进行了训练\",{\"1\":{\"147\":1}}],[\"的方法就好了\",{\"1\":{\"15\":1}}],[\"的方法\",{\"1\":{\"13\":1,\"21\":1,\"211\":1}}],[\"的权重\",{\"1\":{\"142\":1}}],[\"的任务不仅仅是理解单个字词的含义\",{\"1\":{\"141\":1}}],[\"的栈顶取出压入栈\",{\"1\":{\"139\":2}}],[\"的排序算法\",{\"1\":{\"132\":1}}],[\"的排序算法了\",{\"1\":{\"129\":1}}],[\"的算法\",{\"1\":{\"132\":1}}],[\"的数据过滤掉\",{\"1\":{\"222\":1}}],[\"的数据\",{\"1\":{\"126\":1,\"234\":1}}],[\"的元素\",{\"1\":{\"126\":1}}],[\"的下标\",{\"1\":{\"126\":1}}],[\"的放在右边\",{\"1\":{\"126\":1}}],[\"的放在左边\",{\"1\":{\"126\":1}}],[\"的个数\",{\"1\":{\"109\":1}}],[\"的个人计算机和工作站操作系统采用了\",{\"1\":{\"53\":1}}],[\"的长度\",{\"1\":{\"103\":1,\"199\":1}}],[\"的索引\",{\"1\":{\"103\":1}}],[\"的缓存机制\",{\"1\":{\"96\":1}}],[\"的时间复杂度\",{\"1\":{\"92\":1}}],[\"的时候已经下载好了\",{\"1\":{\"172\":1}}],[\"的时候\",{\"1\":{\"29\":1,\"79\":1}}],[\"的工作过程\",{\"0\":{\"81\":1}}],[\"的工作方式\",{\"0\":{\"74\":1}}],[\"的样例配置\",{\"1\":{\"80\":1}}],[\"的新人还没有自己的\",{\"1\":{\"76\":1}}],[\"的管理员\",{\"1\":{\"76\":1}}],[\"的增强版\",{\"1\":{\"75\":1}}],[\"的网关不可能是\",{\"1\":{\"72\":1}}],[\"的优先级最高\",{\"1\":{\"71\":1}}],[\"的头\",{\"1\":{\"71\":2}}],[\"的单字节编码\",{\"1\":{\"66\":1}}],[\"的特殊区域\",{\"1\":{\"65\":1}}],[\"的主要特点是在\",{\"1\":{\"61\":1}}],[\"的汉字\",{\"1\":{\"61\":2}}],[\"的升级版本\",{\"1\":{\"61\":1}}],[\"的字节连在一起共同表示一个汉字\",{\"1\":{\"59\":1}}],[\"的字节\",{\"1\":{\"59\":1}}],[\"的字符\",{\"1\":{\"47\":1}}],[\"的设计各自为政\",{\"1\":{\"54\":1}}],[\"的阿拉伯数字\",{\"1\":{\"53\":1}}],[\"的学习记录\",{\"1\":{\"41\":1,\"50\":1,\"63\":1}}],[\"的学习过程\",{\"1\":{\"30\":1}}],[\"的成本代价很高\",{\"1\":{\"40\":2}}],[\"的综合考量\",{\"1\":{\"40\":1}}],[\"的向量\",{\"1\":{\"34\":2}}],[\"的位置进行\",{\"1\":{\"29\":1}}],[\"的用法\",{\"1\":{\"22\":1}}],[\"的所有元素复制到自身的\",{\"1\":{\"21\":1}}],[\"的参数\",{\"1\":{\"21\":1}}],[\"的含义\",{\"1\":{\"21\":1,\"188\":1}}],[\"的完整语法为\",{\"1\":{\"16\":1}}],[\"的对象\",{\"1\":{\"15\":1}}],[\"的效果\",{\"1\":{\"14\":1}}],[\"的\",{\"1\":{\"8\":1,\"16\":1,\"21\":1,\"79\":1,\"157\":1,\"160\":1,\"171\":3,\"173\":1,\"188\":1,\"192\":2,\"193\":1,\"202\":1,\"219\":3,\"223\":1,\"230\":1,\"231\":1,\"232\":1,\"234\":1}}],[\"为什么有的编程规范要求用\",{\"1\":{\"237\":1}}],[\"为什么会出错呢\",{\"1\":{\"178\":1}}],[\"为什么还要用\",{\"1\":{\"71\":1}}],[\"为此我们要查看\",{\"1\":{\"171\":1}}],[\"为目标地址进行广播\",{\"1\":{\"77\":1}}],[\"为源\",{\"1\":{\"77\":1}}],[\"为它分配了一个可以用的\",{\"1\":{\"76\":1}}],[\"为26个小写英文字母\",{\"1\":{\"53\":1}}],[\"为大型机操作系统而开发设计的\",{\"1\":{\"52\":1}}],[\"为了表达几个额外的语言场景\",{\"1\":{\"239\":1}}],[\"为了避免它在无意中被修改\",{\"1\":{\"237\":1}}],[\"为了避免每次都用\",{\"1\":{\"230\":1}}],[\"为了避免重复计算\",{\"1\":{\"116\":1}}],[\"为了理解\",{\"1\":{\"215\":1}}],[\"为了充分利用集群\",{\"1\":{\"202\":1}}],[\"为了让我们知道训练的进度\",{\"1\":{\"200\":1}}],[\"为了定义学习率调度器\",{\"1\":{\"199\":1}}],[\"为了获得预测结果\",{\"1\":{\"193\":1}}],[\"为了处理长序列\",{\"1\":{\"184\":1}}],[\"为了批处理\",{\"1\":{\"184\":1}}],[\"为了解决这个问题\",{\"1\":{\"179\":1}}],[\"为了实现这一步骤\",{\"1\":{\"172\":1}}],[\"为了加快训练\",{\"1\":{\"152\":1}}],[\"为了在大规模数据上进行预训练\",{\"1\":{\"145\":1}}],[\"为了兼顾任意规模数据排序\",{\"1\":{\"132\":1}}],[\"为了统一这种混乱局面\",{\"1\":{\"54\":1}}],[\"为了与其它标准兼容\",{\"1\":{\"49\":1}}],[\"为了达到这个目的\",{\"1\":{\"7\":1}}],[\"为例\",{\"1\":{\"46\":1}}],[\"为\",{\"1\":{\"8\":1,\"53\":2,\"70\":1,\"71\":1,\"156\":1,\"189\":1,\"192\":1,\"200\":1,\"222\":1,\"239\":2}}],[\"有一种口叫\",{\"1\":{\"234\":1}}],[\"有一个参数是\",{\"1\":{\"224\":1}}],[\"有环的我们常称为图\",{\"1\":{\"233\":1}}],[\"有很多算法解决这个问题\",{\"1\":{\"229\":1}}],[\"有大写有小写\",{\"1\":{\"222\":1}}],[\"有的\",{\"1\":{\"216\":1}}],[\"有三个字段\",{\"1\":{\"193\":1}}],[\"有些模型只在句尾加特殊词\",{\"1\":{\"183\":1}}],[\"有些模型只在句首加特殊词\",{\"1\":{\"183\":1}}],[\"有些模型不用特殊词\",{\"1\":{\"183\":1}}],[\"有两种方式来解决这个问题\",{\"1\":{\"181\":1}}],[\"有明显的性别相关性\",{\"1\":{\"145\":1}}],[\"有序\",{\"1\":{\"121\":1}}],[\"有序度加\",{\"1\":{\"120\":1}}],[\"有序度\",{\"1\":{\"120\":1}}],[\"有数据交换\",{\"1\":{\"120\":1}}],[\"有堆栈溢出的风险\",{\"1\":{\"117\":1}}],[\"有人吗\",{\"1\":{\"75\":1}}],[\"有可能所看到的私有字符也不同\",{\"1\":{\"65\":1}}],[\"有\",{\"1\":{\"58\":1,\"88\":1,\"114\":1}}],[\"有少数字符可能与多个码点对应\",{\"1\":{\"49\":1}}],[\"有哪些字符\",{\"1\":{\"42\":1}}],[\"有时用\",{\"1\":{\"42\":1}}],[\"有时我们希望在不同的地方使用相同名字的\",{\"1\":{\"7\":1}}],[\"有相同的语法\",{\"1\":{\"21\":1}}],[\"有索引和\",{\"1\":{\"12\":1,\"15\":1,\"17\":1}}],[\"有效防止双方对该属性进行的重写覆盖\",{\"1\":{\"6\":1}}],[\"cymbalta\",{\"1\":{\"222\":2}}],[\"csv\",{\"1\":{\"218\":4,\"222\":5}}],[\"cb23931\",{\"1\":{\"214\":1}}],[\"cd\",{\"1\":{\"214\":1}}],[\"cuda\",{\"1\":{\"200\":2,\"202\":2}}],[\"current++\",{\"1\":{\"13\":2}}],[\"current\",{\"1\":{\"13\":4}}],[\"ctrl\",{\"1\":{\"150\":1}}],[\"checked\",{\"1\":{\"222\":1}}],[\"checkpoint\",{\"1\":{\"156\":2,\"157\":2,\"159\":2,\"161\":2,\"164\":2,\"178\":6,\"179\":1,\"184\":3,\"189\":2,\"191\":2,\"192\":1,\"193\":1,\"194\":2,\"197\":1,\"202\":2,\"208\":3,\"214\":3}}],[\"checkpoints\",{\"0\":{\"142\":1},\"1\":{\"142\":4,\"156\":2,\"157\":1,\"189\":2,\"192\":1,\"205\":1}}],[\"changes\",{\"1\":{\"214\":1}}],[\"change\",{\"1\":{\"209\":1}}],[\"chapter\",{\"1\":{\"171\":1,\"192\":1}}],[\"charcodeat\",{\"1\":{\"238\":1}}],[\"charat\",{\"1\":{\"238\":1}}],[\"characters\",{\"1\":{\"169\":1}}],[\"character\",{\"0\":{\"44\":1,\"45\":1,\"46\":1,\"47\":1,\"169\":1,\"249\":1},\"1\":{\"42\":3,\"62\":1,\"168\":1,\"169\":4}}],[\"charset\",{\"1\":{\"42\":1}}],[\"char\",{\"1\":{\"14\":4,\"103\":5}}],[\"c\",{\"1\":{\"125\":3,\"130\":10,\"132\":1,\"139\":2}}],[\"cfg\",{\"1\":{\"81\":1}}],[\"c7\",{\"1\":{\"71\":1}}],[\"c类地址\",{\"1\":{\"70\":1}}],[\"cidr\",{\"0\":{\"70\":1},\"1\":{\"70\":1,\"72\":1}}],[\"cjk\",{\"1\":{\"61\":2}}],[\"cp54936\",{\"1\":{\"61\":1}}],[\"cp936\",{\"1\":{\"60\":1}}],[\"cpu\",{\"1\":{\"42\":2,\"96\":2,\"200\":1,\"202\":1}}],[\"crc\",{\"1\":{\"229\":2}}],[\"cream\",{\"1\":{\"222\":1}}],[\"create\",{\"1\":{\"209\":4}}],[\"creation\",{\"1\":{\"209\":1}}],[\"crux82\",{\"1\":{\"219\":2,\"220\":1}}],[\"cr回车\",{\"1\":{\"53\":1}}],[\"cross\",{\"1\":{\"33\":1}}],[\"celiacs\",{\"1\":{\"222\":1}}],[\"celexa\",{\"1\":{\"222\":3}}],[\"cell\",{\"1\":{\"202\":1}}],[\"ces\",{\"0\":{\"47\":1},\"1\":{\"47\":3,\"48\":1,\"49\":1}}],[\"cef\",{\"0\":{\"46\":1},\"1\":{\"46\":4,\"47\":3,\"49\":1}}],[\"ccs\",{\"0\":{\"45\":1},\"1\":{\"45\":3,\"46\":3}}],[\"cannot\",{\"1\":{\"222\":1}}],[\"cancer\",{\"1\":{\"222\":1}}],[\"canjoin\",{\"1\":{\"21\":6}}],[\"camembert\",{\"1\":{\"205\":1,\"208\":1,\"214\":1,\"216\":1}}],[\"calculation\",{\"1\":{\"193\":1}}],[\"called\",{\"1\":{\"188\":1,\"223\":2}}],[\"cache\",{\"1\":{\"162\":1,\"163\":1,\"188\":1}}],[\"cards\",{\"1\":{\"215\":1}}],[\"card\",{\"0\":{\"215\":1,\"216\":1},\"1\":{\"153\":1,\"163\":1,\"205\":1,\"208\":1,\"215\":3,\"216\":3}}],[\"carpenter\",{\"1\":{\"145\":1}}],[\"cas\",{\"1\":{\"110\":1}}],[\"caseine\",{\"1\":{\"222\":3}}],[\"cased\",{\"1\":{\"142\":2,\"163\":2,\"171\":2,\"173\":1}}],[\"case\",{\"0\":{\"87\":2,\"88\":1}}],[\"categorical\",{\"1\":{\"33\":1}}],[\"cli\",{\"1\":{\"209\":2}}],[\"client\",{\"1\":{\"80\":1}}],[\"cls\",{\"1\":{\"183\":2,\"189\":3}}],[\"clustering\",{\"1\":{\"33\":2}}],[\"classlabel\",{\"1\":{\"188\":1}}],[\"classifier\",{\"1\":{\"33\":1,\"144\":3,\"156\":2,\"162\":1}}],[\"classification\",{\"1\":{\"33\":2,\"159\":1,\"192\":1}}],[\"class\",{\"1\":{\"24\":2,\"28\":3,\"29\":1,\"33\":1,\"70\":1,\"157\":1}}],[\"clone\",{\"1\":{\"6\":2,\"213\":3,\"214\":2}}],[\"costed\",{\"1\":{\"222\":1}}],[\"cost\",{\"1\":{\"222\":2,\"233\":1}}],[\"co\",{\"1\":{\"214\":2}}],[\"commentsreview\",{\"1\":{\"222\":1}}],[\"committed\",{\"1\":{\"214\":2}}],[\"commit\",{\"1\":{\"213\":2,\"214\":3}}],[\"com\",{\"1\":{\"219\":2,\"220\":1}}],[\"company\",{\"1\":{\"222\":1}}],[\"compare\",{\"1\":{\"110\":1}}],[\"compute\",{\"1\":{\"192\":1,\"193\":11,\"201\":3,\"223\":2}}],[\"computer\",{\"1\":{\"164\":2,\"171\":1}}],[\"complexity\",{\"0\":{\"87\":2,\"88\":1,\"89\":1}}],[\"components\",{\"1\":{\"33\":2}}],[\"corpus\",{\"1\":{\"187\":1}}],[\"cool\",{\"1\":{\"165\":1}}],[\"couldnt\",{\"1\":{\"222\":1}}],[\"countingsort\",{\"1\":{\"130\":1}}],[\"counting\",{\"0\":{\"130\":1}}],[\"course\",{\"1\":{\"30\":1,\"144\":3,\"156\":2,\"178\":3,\"180\":1,\"181\":1,\"183\":3,\"184\":1}}],[\"colab\",{\"1\":{\"192\":1}}],[\"collator=data\",{\"1\":{\"192\":1,\"193\":1}}],[\"collator\",{\"1\":{\"190\":3,\"191\":1,\"192\":4,\"193\":1,\"194\":1,\"196\":2,\"203\":1}}],[\"collate\",{\"1\":{\"190\":2,\"196\":2}}],[\"collection\",{\"1\":{\"96\":1}}],[\"columns\",{\"1\":{\"195\":1}}],[\"column\",{\"1\":{\"34\":1,\"195\":2,\"222\":4,\"223\":2}}],[\"copywithin\",{\"1\":{\"21\":1}}],[\"conversion\",{\"0\":{\"245\":1}}],[\"convert\",{\"1\":{\"174\":2,\"178\":2,\"183\":1,\"189\":1}}],[\"condition\",{\"1\":{\"222\":9}}],[\"control\",{\"0\":{\"229\":1}}],[\"content\",{\"1\":{\"209\":1}}],[\"containskey\",{\"1\":{\"116\":1}}],[\"continuous\",{\"1\":{\"33\":1}}],[\"concurrent\",{\"1\":{\"108\":1}}],[\"concat\",{\"1\":{\"21\":6}}],[\"config\",{\"1\":{\"160\":2,\"162\":3,\"164\":3,\"202\":1,\"212\":2,\"214\":6}}],[\"configuration\",{\"0\":{\"73\":1},\"1\":{\"154\":1,\"208\":1}}],[\"confusion\",{\"1\":{\"36\":1}}],[\"constructor\",{\"1\":{\"28\":1}}],[\"console\",{\"1\":{\"5\":3,\"244\":2,\"245\":1}}],[\"coded\",{\"0\":{\"45\":1},\"1\":{\"52\":1}}],[\"code\",{\"0\":{\"251\":1},\"1\":{\"3\":1,\"6\":1,\"44\":1,\"45\":3,\"46\":2,\"49\":1,\"52\":1,\"53\":1,\"64\":2}}],[\"codes\",{\"1\":{\"3\":2}}],[\"想要进行评估可以设置\",{\"1\":{\"192\":1}}],[\"想要获得\",{\"1\":{\"6\":1}}],[\"想为该对象增加属性时\",{\"1\":{\"6\":1}}],[\"时的特殊值减掉\",{\"1\":{\"239\":1}}],[\"时的一个参数\",{\"1\":{\"190\":1}}],[\"时配置\",{\"1\":{\"208\":1}}],[\"时就会在每个\",{\"1\":{\"193\":1}}],[\"时间\",{\"1\":{\"193\":1}}],[\"时间复杂度可以做到\",{\"1\":{\"131\":1}}],[\"时间复杂度分析\",{\"1\":{\"127\":1}}],[\"时间复杂度内查找一个无序数组中的第\",{\"1\":{\"127\":1}}],[\"时间复杂度的系数\",{\"1\":{\"118\":1}}],[\"时间复杂度来找到前驱节点\",{\"1\":{\"94\":1}}],[\"时间复杂度有量级的差距\",{\"1\":{\"88\":1}}],[\"时间复杂度就是\",{\"1\":{\"85\":1,\"87\":2}}],[\"时间复杂度量级\",{\"1\":{\"85\":1}}],[\"时间复杂度\",{\"0\":{\"85\":1},\"1\":{\"118\":2,\"120\":1,\"121\":1,\"122\":1,\"125\":1,\"126\":1,\"129\":1,\"132\":1}}],[\"时你会看到\",{\"1\":{\"192\":1}}],[\"时该结构会不一样\",{\"1\":{\"189\":1}}],[\"时需要进行单独处理\",{\"1\":{\"29\":1}}],[\"时可以是任何名称\",{\"1\":{\"28\":1}}],[\"时不需要加\",{\"1\":{\"28\":1}}],[\"时下一个值\",{\"1\":{\"13\":1}}],[\"时迭代结束\",{\"1\":{\"12\":1}}],[\"时使用的\",{\"1\":{\"164\":1}}],[\"时使用\",{\"1\":{\"8\":1}}],[\"时\",{\"1\":{\"6\":1,\"11\":1,\"13\":2,\"24\":1,\"25\":1,\"28\":1,\"40\":2,\"55\":2,\"116\":2,\"125\":1,\"129\":1,\"151\":2,\"163\":1,\"178\":1,\"189\":2,\"192\":1,\"208\":2,\"232\":1}}],[\"over\",{\"1\":{\"222\":1}}],[\"old\",{\"1\":{\"222\":1}}],[\"ocd\",{\"1\":{\"222\":2}}],[\"octet\",{\"1\":{\"42\":1}}],[\"optimizer=optimizer\",{\"1\":{\"199\":1,\"202\":2}}],[\"optimizer\",{\"0\":{\"198\":1},\"1\":{\"198\":2,\"200\":2,\"202\":10}}],[\"option\",{\"1\":{\"80\":3}}],[\"once\",{\"1\":{\"222\":1}}],[\"one\",{\"1\":{\"189\":3}}],[\"on\",{\"1\":{\"164\":2,\"171\":1,\"214\":2,\"222\":4}}],[\"only\",{\"1\":{\"150\":2,\"188\":1}}],[\"others\",{\"1\":{\"157\":1}}],[\"oscar\",{\"1\":{\"216\":1}}],[\"os\",{\"1\":{\"110\":1}}],[\"o\",{\"1\":{\"82\":2,\"85\":15,\"87\":2,\"92\":2,\"94\":1,\"118\":4,\"120\":5,\"121\":5,\"122\":2,\"123\":10,\"125\":6,\"126\":8,\"127\":2,\"129\":4,\"131\":3,\"132\":10,\"133\":1}}],[\"out\",{\"1\":{\"96\":1,\"178\":1}}],[\"outputs\",{\"1\":{\"158\":2,\"159\":2,\"160\":2,\"197\":3,\"200\":2,\"201\":2,\"202\":4}}],[\"output\",{\"1\":{\"34\":1,\"165\":1,\"178\":2,\"184\":1}}],[\"our\",{\"1\":{\"6\":1}}],[\"observation\",{\"1\":{\"34\":1}}],[\"observations\",{\"1\":{\"34\":1}}],[\"obj\",{\"1\":{\"2\":9,\"6\":3,\"11\":3,\"12\":2,\"16\":1,\"17\":2,\"245\":2}}],[\"objects\",{\"1\":{\"214\":3}}],[\"object\",{\"0\":{\"1\":1,\"241\":1,\"245\":1},\"1\":{\"2\":1,\"6\":5,\"11\":3,\"21\":3,\"222\":1,\"236\":1}}],[\"organization=\",{\"1\":{\"208\":2,\"209\":1}}],[\"organization\",{\"1\":{\"208\":1,\"209\":2}}],[\"original\",{\"1\":{\"222\":1}}],[\"origin\",{\"1\":{\"179\":1,\"214\":2}}],[\"order\",{\"1\":{\"47\":1,\"58\":1}}],[\"or\",{\"1\":{\"33\":2,\"170\":1,\"180\":1,\"181\":1,\"192\":1,\"222\":1}}],[\"orange\",{\"1\":{\"19\":8}}],[\"offset\",{\"1\":{\"80\":1}}],[\"offer\",{\"0\":{\"76\":1},\"1\":{\"76\":2,\"77\":1}}],[\"of只对这个被返回的对象\",{\"1\":{\"13\":1}}],[\"of\",{\"1\":{\"12\":5,\"13\":6,\"14\":4,\"17\":1,\"19\":2,\"21\":1,\"33\":2,\"34\":7,\"71\":1,\"96\":1,\"178\":2,\"188\":2,\"222\":3}}],[\"ownkeys\",{\"1\":{\"6\":1,\"11\":1}}],[\"ieee\",{\"1\":{\"239\":3}}],[\"iec8859\",{\"1\":{\"54\":1}}],[\"iec\",{\"0\":{\"56\":1},\"1\":{\"44\":1,\"53\":2,\"55\":1,\"56\":5,\"67\":2}}],[\"im\",{\"1\":{\"222\":2}}],[\"importerror\",{\"1\":{\"192\":1}}],[\"import\",{\"0\":{\"22\":1,\"25\":1},\"1\":{\"22\":1,\"27\":1,\"28\":4,\"29\":1,\"37\":1,\"38\":1,\"39\":1,\"40\":1,\"144\":2,\"145\":1,\"156\":2,\"157\":1,\"159\":1,\"160\":1,\"162\":1,\"163\":2,\"165\":1,\"171\":2,\"173\":1,\"178\":4,\"184\":2,\"188\":1,\"189\":1,\"190\":1,\"191\":2,\"192\":3,\"193\":2,\"194\":2,\"196\":1,\"197\":1,\"198\":1,\"199\":1,\"200\":2,\"201\":1,\"202\":5,\"208\":2,\"209\":2,\"212\":1,\"213\":1,\"214\":1,\"219\":1,\"222\":1,\"223\":1}}],[\"irritated\",{\"1\":{\"222\":1}}],[\"illustrated\",{\"1\":{\"150\":1,\"153\":1}}],[\"ignore\",{\"1\":{\"80\":1}}],[\"ioctl\",{\"1\":{\"71\":1}}],[\"iproute2\",{\"1\":{\"71\":5}}],[\"ipconfig\",{\"1\":{\"71\":1}}],[\"ip\",{\"0\":{\"70\":1,\"71\":1,\"72\":1,\"79\":1},\"1\":{\"70\":8,\"71\":10,\"72\":5,\"73\":3,\"75\":4,\"76\":8,\"77\":7,\"78\":1,\"79\":3,\"80\":6,\"81\":1,\"229\":1,\"230\":6,\"232\":1}}],[\"ibm\",{\"1\":{\"52\":1,\"53\":1}}],[\"its\",{\"1\":{\"222\":1}}],[\"it\",{\"1\":{\"151\":1,\"214\":2,\"219\":17,\"220\":4,\"222\":5}}],[\"ith\",{\"1\":{\"34\":1}}],[\"items\",{\"1\":{\"190\":2,\"196\":1,\"200\":1,\"201\":1,\"202\":1}}],[\"item\",{\"1\":{\"21\":11}}],[\"iteration\",{\"1\":{\"13\":2}}],[\"iterator\",{\"0\":{\"13\":1},\"1\":{\"10\":2,\"12\":1,\"13\":4,\"14\":3,\"15\":1,\"17\":3}}],[\"iterable\",{\"0\":{\"15\":1},\"1\":{\"12\":2,\"15\":2}}],[\"iterables\",{\"0\":{\"12\":1},\"1\":{\"10\":1,\"15\":2,\"16\":1,\"17\":1}}],[\"is\",{\"1\":{\"156\":1,\"171\":1,\"173\":2,\"175\":1,\"189\":6,\"200\":1,\"202\":1,\"214\":1,\"222\":3}}],[\"iso\",{\"0\":{\"54\":1,\"56\":1},\"1\":{\"44\":1,\"45\":2,\"53\":2,\"54\":1,\"55\":1,\"56\":5,\"67\":2}}],[\"isarray\",{\"1\":{\"21\":1}}],[\"isconcatspreadable\",{\"1\":{\"10\":1,\"21\":2}}],[\"i++\",{\"1\":{\"19\":1,\"125\":3,\"126\":1}}],[\"i\",{\"1\":{\"19\":4,\"85\":4,\"87\":4,\"103\":9,\"117\":2,\"120\":3,\"121\":4,\"122\":7,\"125\":4,\"126\":7,\"130\":25,\"144\":3,\"151\":2,\"156\":4,\"178\":4,\"180\":2,\"181\":2,\"183\":3,\"184\":2,\"222\":15,\"223\":2}}],[\"ifconfig\",{\"0\":{\"71\":1},\"1\":{\"71\":2}}],[\"if\",{\"1\":{\"13\":2,\"14\":1,\"87\":1,\"103\":7,\"114\":2,\"115\":2,\"116\":3,\"117\":2,\"120\":3,\"121\":2,\"122\":3,\"123\":2,\"125\":1,\"126\":2,\"130\":2,\"190\":1,\"200\":1,\"202\":1,\"222\":1}}],[\"id>\",{\"1\":{\"214\":1}}],[\"id=\",{\"1\":{\"208\":2,\"212\":1}}],[\"id=none\",{\"1\":{\"188\":4}}],[\"idx\",{\"1\":{\"188\":6,\"189\":3,\"190\":2,\"195\":2}}],[\"ids\",{\"0\":{\"174\":1},\"1\":{\"156\":1,\"165\":3,\"171\":5,\"172\":1,\"174\":4,\"176\":2,\"178\":15,\"179\":9,\"180\":8,\"181\":2,\"183\":6,\"185\":1,\"189\":15,\"190\":4,\"193\":3,\"195\":2,\"196\":2}}],[\"idagain\",{\"1\":{\"8\":2}}],[\"id2label\",{\"1\":{\"160\":2}}],[\"id2\",{\"1\":{\"5\":2}}],[\"id1\",{\"1\":{\"5\":2}}],[\"id\",{\"1\":{\"5\":10,\"6\":17,\"8\":4,\"9\":2,\"162\":1,\"168\":4,\"179\":6,\"180\":1,\"183\":1,\"222\":5,\"233\":3,\"234\":2}}],[\"inactive\",{\"1\":{\"222\":1}}],[\"ineffective\",{\"1\":{\"222\":1}}],[\"ingredients\",{\"1\":{\"222\":1}}],[\"ing\",{\"1\":{\"170\":1}}],[\"install\",{\"1\":{\"192\":4,\"214\":1}}],[\"institute\",{\"1\":{\"53\":1}}],[\"insertionsort\",{\"1\":{\"121\":1}}],[\"insertion\",{\"0\":{\"121\":1}}],[\"initramfs\",{\"1\":{\"81\":1}}],[\"initializer\",{\"1\":{\"162\":1}}],[\"initial\",{\"1\":{\"21\":2}}],[\"inference\",{\"0\":{\"165\":1},\"1\":{\"153\":1,\"184\":1}}],[\"information\",{\"1\":{\"53\":1,\"209\":1}}],[\"infinity\",{\"1\":{\"13\":1,\"239\":7}}],[\"intended\",{\"1\":{\"215\":1}}],[\"intermediate\",{\"1\":{\"162\":1}}],[\"interim\",{\"1\":{\"80\":1}}],[\"interchange\",{\"1\":{\"52\":1,\"53\":1}}],[\"int32\",{\"1\":{\"188\":1}}],[\"int\",{\"1\":{\"87\":6,\"103\":6,\"114\":2,\"115\":3,\"116\":3,\"117\":6,\"120\":5,\"121\":5,\"122\":6,\"123\":1,\"125\":11,\"126\":9,\"130\":14}}],[\"introduction\",{\"0\":{\"83\":1,\"108\":1},\"1\":{\"31\":1}}],[\"independent\",{\"1\":{\"34\":1}}],[\"indexerror\",{\"1\":{\"178\":1}}],[\"indexof\",{\"1\":{\"21\":1}}],[\"index\",{\"1\":{\"21\":6,\"29\":2,\"130\":2}}],[\"inputs\",{\"1\":{\"156\":4,\"158\":1,\"159\":1,\"165\":2,\"178\":4,\"180\":8,\"181\":4,\"183\":3,\"189\":3}}],[\"input\",{\"0\":{\"174\":1},\"1\":{\"34\":1,\"156\":1,\"165\":5,\"168\":2,\"171\":3,\"172\":1,\"176\":1,\"178\":7,\"180\":5,\"181\":2,\"183\":2,\"185\":1,\"189\":6,\"190\":3,\"195\":1,\"196\":1}}],[\"include\",{\"1\":{\"33\":1}}],[\"includes\",{\"1\":{\"21\":2}}],[\"in\",{\"1\":{\"2\":3,\"3\":1,\"6\":2,\"11\":1,\"19\":2,\"21\":2,\"34\":1,\"118\":1,\"144\":1,\"145\":2,\"178\":1,\"190\":4,\"196\":2,\"200\":3,\"201\":2,\"202\":5,\"212\":1,\"222\":5}}],[\"引入哨兵结点\",{\"1\":{\"103\":1}}],[\"引入\",{\"1\":{\"4\":1,\"240\":1}}],[\"只读\",{\"1\":{\"237\":1}}],[\"只必传的\",{\"1\":{\"165\":1}}],[\"只接收\",{\"1\":{\"165\":1}}],[\"只需要\",{\"1\":{\"169\":1}}],[\"只需要对\",{\"1\":{\"127\":1}}],[\"只需给键名前加一个\",{\"1\":{\"3\":1}}],[\"只有相同\",{\"1\":{\"234\":1}}],[\"只有\",{\"1\":{\"233\":1}}],[\"只有在极端情况下\",{\"1\":{\"126\":1}}],[\"只有个别情况下时间复杂度比较高\",{\"1\":{\"89\":1}}],[\"只有同一块代码在不同的情况下\",{\"1\":{\"88\":1}}],[\"只有是一个网段的\",{\"1\":{\"72\":1}}],[\"只记录数据已经被删除\",{\"1\":{\"82\":1}}],[\"只知道自己的\",{\"1\":{\"75\":1}}],[\"只支持十六进制前缀\",{\"1\":{\"243\":1}}],[\"只支持\",{\"1\":{\"71\":1}}],[\"只要求高字节大于\",{\"1\":{\"60\":1}}],[\"只要表示的是同一个字符\",{\"1\":{\"49\":1}}],[\"只会导出\",{\"1\":{\"29\":1}}],[\"只获取元素\",{\"1\":{\"19\":1}}],[\"只能看到已经翻译好的字词\",{\"1\":{\"152\":1}}],[\"只能访问到该结点以及它之后的结点\",{\"1\":{\"93\":1}}],[\"只能先把客户端放在\",{\"1\":{\"80\":1}}],[\"只能通过查表这样低效率的办法\",{\"1\":{\"66\":1}}],[\"只能得到\",{\"1\":{\"21\":1}}],[\"只能执行\",{\"1\":{\"19\":1}}],[\"只能查找全局注册表中的\",{\"1\":{\"9\":1}}],[\"只能是\",{\"1\":{\"4\":1,\"240\":1}}],[\"just\",{\"1\":{\"222\":1}}],[\"jim\",{\"1\":{\"168\":2}}],[\"j+1\",{\"1\":{\"120\":3,\"121\":2,\"123\":4}}],[\"j\",{\"1\":{\"120\":6,\"121\":5,\"122\":4,\"123\":5,\"126\":4}}],[\"javascrip\",{\"1\":{\"238\":1}}],[\"javascript\",{\"0\":{\"255\":1},\"1\":{\"4\":1,\"10\":1,\"11\":1,\"82\":1,\"239\":4,\"240\":1,\"241\":1}}],[\"java\",{\"1\":{\"96\":1,\"108\":1,\"132\":1}}],[\"jjj\",{\"0\":{\"35\":1}}],[\"jth\",{\"1\":{\"34\":1}}],[\"jsonl\",{\"1\":{\"218\":1}}],[\"json\",{\"1\":{\"164\":3,\"212\":2,\"214\":12,\"218\":4,\"219\":13,\"220\":3}}],[\"js\",{\"1\":{\"27\":1,\"28\":1,\"29\":10}}],[\"joints\",{\"1\":{\"222\":1}}],[\"join\",{\"1\":{\"16\":1,\"21\":2}}],[\"john\",{\"1\":{\"2\":1,\"6\":3,\"27\":1}}],[\"隐藏\",{\"1\":{\"4\":1,\"11\":1}}],[\"用逗号作为分割符\",{\"1\":{\"222\":1}}],[\"用屏蔽词填充文本中的空白\",{\"1\":{\"141\":1}}],[\"用自动生成的文本完成提示\",{\"1\":{\"141\":1}}],[\"用栈保存未被匹配的左括号\",{\"1\":{\"138\":1}}],[\"用来衡量\",{\"1\":{\"187\":1}}],[\"用来存储函数调用时的临时变量\",{\"1\":{\"136\":1}}],[\"用来指定字节序\",{\"1\":{\"47\":1}}],[\"用大\",{\"1\":{\"125\":1}}],[\"用链表的应用\",{\"0\":{\"97\":1}}],[\"用十六进制\",{\"1\":{\"71\":1}}],[\"用于迭代批次\",{\"0\":{\"196\":1}}],[\"用于排队请求\",{\"1\":{\"111\":1}}],[\"用于指示打印机的打印针头退到行首\",{\"1\":{\"53\":1}}],[\"用于传递上下文\",{\"1\":{\"21\":1}}],[\"用将字节序列作进一步的适应性编码处理\",{\"1\":{\"48\":1}}],[\"用数字编号表示字符\",{\"1\":{\"45\":1}}],[\"用重复的\",{\"1\":{\"21\":1}}],[\"用\",{\"1\":{\"4\":4,\"10\":1,\"11\":4,\"12\":1,\"20\":1,\"67\":1,\"103\":1,\"130\":1,\"239\":1}}],[\"是对应类型的构造器\",{\"1\":{\"241\":1}}],[\"是不同的类型\",{\"1\":{\"241\":1}}],[\"是不行的\",{\"1\":{\"29\":1}}],[\"是指三个特殊值\",{\"1\":{\"239\":1}}],[\"是指一次向模型传递多个句子\",{\"1\":{\"178\":1}}],[\"是患者\",{\"1\":{\"222\":1}}],[\"是什么\",{\"1\":{\"217\":1}}],[\"是通过\",{\"1\":{\"215\":1}}],[\"是都要创建\",{\"1\":{\"209\":1}}],[\"是每个\",{\"1\":{\"208\":1}}],[\"是主网站\",{\"1\":{\"204\":1}}],[\"是大模型\",{\"0\":{\"148\":1}}],[\"是大端序还是小端序\",{\"1\":{\"47\":1}}],[\"是语言模型\",{\"0\":{\"147\":1}}],[\"是由\",{\"1\":{\"142\":1}}],[\"是维度\",{\"1\":{\"132\":1}}],[\"是数据范围\",{\"1\":{\"132\":1}}],[\"是数组时\",{\"1\":{\"21\":1}}],[\"是将子问题的结果合并成问题\",{\"1\":{\"125\":1}}],[\"是将没有患癌症的人诊断为癌症\",{\"1\":{\"40\":1}}],[\"是网卡固件的一部分\",{\"1\":{\"80\":1}}],[\"是没有启动扇区的\",{\"1\":{\"80\":1}}],[\"是唯一的\",{\"1\":{\"76\":1}}],[\"是唯一标识符的基本类型\",{\"1\":{\"4\":1,\"11\":1}}],[\"是它\",{\"1\":{\"72\":1}}],[\"是否想用给定的\",{\"1\":{\"209\":1}}],[\"是否对其他人可见\",{\"1\":{\"209\":1}}],[\"是否出错时使用的\",{\"1\":{\"197\":1}}],[\"是否能在\",{\"1\":{\"190\":1}}],[\"是否存在序列过长的问题\",{\"1\":{\"177\":1}}],[\"是否有数据交换\",{\"1\":{\"120\":1}}],[\"是否基于比较\",{\"1\":{\"118\":1}}],[\"是否在同一网段\",{\"1\":{\"72\":1}}],[\"是否为数组\",{\"1\":{\"21\":1}}],[\"是多队列\",{\"1\":{\"71\":1}}],[\"是多字节编码\",{\"1\":{\"58\":1}}],[\"是启动的\",{\"1\":{\"71\":1}}],[\"是可以对外的\",{\"1\":{\"71\":1}}],[\"是可以被争取处理的\",{\"1\":{\"12\":1}}],[\"是一个\",{\"1\":{\"142\":1}}],[\"是一个网卡的物理地址\",{\"1\":{\"71\":1}}],[\"是一个特例\",{\"1\":{\"21\":1}}],[\"是一致的\",{\"1\":{\"67\":1}}],[\"是两个字节表示的\",{\"1\":{\"66\":1}}],[\"是双字节编码\",{\"1\":{\"59\":1}}],[\"是在左边的网口\",{\"1\":{\"232\":1}}],[\"是在预训练好的模型上进行进一步的训练\",{\"1\":{\"149\":1}}],[\"是在\",{\"1\":{\"58\":2}}],[\"是最早的\",{\"1\":{\"58\":1}}],[\"是跟特定计算机系统平台无关的逻辑意义上的编码过程\",{\"1\":{\"47\":1}}],[\"是把正常邮件识别为垃圾邮件\",{\"1\":{\"40\":1}}],[\"是得了癌症的病人没有被诊断出癌症\",{\"1\":{\"40\":1}}],[\"是内置的可迭代对象\",{\"1\":{\"17\":1}}],[\"是内建的去除小数部分的方法\",{\"1\":{\"3\":1}}],[\"是\",{\"1\":{\"15\":1,\"19\":1,\"21\":2,\"40\":1,\"61\":1,\"71\":3,\"72\":1,\"75\":2,\"156\":1,\"170\":1,\"188\":2,\"214\":2,\"222\":1,\"232\":1,\"239\":1,\"241\":1}}],[\"46\",{\"1\":{\"229\":1}}],[\"4658\",{\"1\":{\"165\":1}}],[\"48\",{\"1\":{\"219\":1}}],[\"48~57\",{\"1\":{\"53\":1}}],[\"4096\",{\"1\":{\"234\":2}}],[\"400mb\",{\"1\":{\"214\":1}}],[\"408\",{\"1\":{\"188\":1,\"189\":1,\"193\":2}}],[\"473\",{\"1\":{\"223\":1}}],[\"47\",{\"1\":{\"190\":1}}],[\"4n​\",{\"1\":{\"125\":2}}],[\"4n\",{\"1\":{\"120\":1}}],[\"43200\",{\"1\":{\"80\":1}}],[\"4个\",{\"1\":{\"42\":1}}],[\"4\",{\"0\":{\"10\":1,\"16\":1,\"27\":1,\"40\":1,\"47\":1,\"61\":1,\"72\":1,\"78\":1,\"95\":1,\"100\":1,\"101\":1,\"102\":1,\"103\":1,\"104\":2,\"105\":1,\"106\":1,\"123\":1,\"132\":1,\"150\":1,\"151\":1,\"152\":1,\"175\":1,\"177\":1,\"178\":1,\"179\":1,\"180\":1,\"181\":2,\"199\":1,\"202\":1,\"204\":1,\"240\":1,\"246\":1},\"1\":{\"13\":1,\"16\":1,\"19\":1,\"21\":8,\"53\":1,\"58\":1,\"72\":2,\"74\":1,\"116\":2,\"125\":1,\"160\":2,\"162\":1,\"171\":1,\"182\":1,\"192\":1,\"222\":1,\"229\":1,\"232\":3,\"238\":1}}],[\"442\",{\"1\":{\"219\":2}}],[\"4418e\",{\"1\":{\"160\":1}}],[\"44\",{\"1\":{\"3\":1}}],[\"4125\",{\"1\":{\"179\":1,\"180\":1}}],[\"41\",{\"1\":{\"3\":1}}],[\"49\",{\"1\":{\"3\":4}}],[\"bpdu\",{\"1\":{\"233\":2}}],[\"bpe\",{\"1\":{\"170\":1,\"214\":4}}],[\"blabla\",{\"1\":{\"232\":1}}],[\"blanket\",{\"1\":{\"151\":1}}],[\"blood\",{\"1\":{\"222\":1}}],[\"bc20ff2\",{\"1\":{\"214\":1}}],[\"but\",{\"1\":{\"178\":1,\"222\":1}}],[\"bucket\",{\"0\":{\"129\":1}}],[\"bubblesort\",{\"1\":{\"120\":1}}],[\"bubble\",{\"0\":{\"120\":1}}],[\"became\",{\"1\":{\"222\":1}}],[\"better\",{\"1\":{\"222\":1}}],[\"benefit\",{\"1\":{\"223\":4}}],[\"benefitsreview\",{\"1\":{\"222\":1,\"223\":3}}],[\"benchmark\",{\"1\":{\"187\":2}}],[\"be\",{\"1\":{\"178\":1,\"214\":3,\"222\":3}}],[\"been\",{\"1\":{\"144\":2,\"156\":2,\"178\":3,\"180\":1,\"181\":1,\"183\":3,\"184\":1}}],[\"berttokenizer\",{\"1\":{\"171\":2}}],[\"bertmodel\",{\"1\":{\"162\":2,\"163\":3}}],[\"bertconfig\",{\"1\":{\"162\":3}}],[\"bert\",{\"1\":{\"142\":5,\"145\":1,\"146\":1,\"147\":1,\"150\":1,\"161\":1,\"162\":2,\"163\":3,\"170\":1,\"171\":3,\"173\":1,\"180\":1,\"181\":1,\"189\":1,\"191\":1,\"192\":1,\"194\":1,\"208\":2,\"223\":2}}],[\"best\",{\"0\":{\"87\":1}}],[\"bel响铃\",{\"1\":{\"53\":1}}],[\"bsd\",{\"1\":{\"71\":1}}],[\"b类地址\",{\"1\":{\"70\":1}}],[\"bmp\",{\"0\":{\"65\":1},\"1\":{\"65\":6}}],[\"bytes\",{\"1\":{\"229\":5,\"230\":3}}],[\"byte\",{\"1\":{\"42\":3,\"47\":1,\"49\":1,\"58\":1,\"62\":1,\"71\":1,\"170\":1}}],[\"bias\",{\"1\":{\"205\":1,\"215\":1}}],[\"bin\",{\"1\":{\"164\":3,\"214\":5}}],[\"binary\",{\"1\":{\"42\":1,\"52\":1}}],[\"bios\",{\"1\":{\"80\":3}}],[\"bit\",{\"1\":{\"42\":4}}],[\"birds\",{\"1\":{\"2\":2}}],[\"bad\",{\"1\":{\"222\":2}}],[\"back\",{\"1\":{\"222\":1}}],[\"backward\",{\"1\":{\"200\":1,\"202\":3}}],[\"bached\",{\"1\":{\"179\":1}}],[\"bar\",{\"1\":{\"200\":2,\"202\":4}}],[\"bart\",{\"1\":{\"146\":1,\"147\":1,\"150\":1}}],[\"batches\",{\"1\":{\"190\":1,\"199\":1,\"201\":1}}],[\"batched=true\",{\"1\":{\"189\":1,\"191\":1,\"194\":1}}],[\"batched\",{\"1\":{\"178\":1,\"179\":4,\"180\":2,\"189\":1,\"224\":1}}],[\"batching\",{\"1\":{\"178\":1}}],[\"batch\",{\"1\":{\"158\":1,\"179\":1,\"189\":4,\"190\":6,\"196\":4,\"197\":2,\"200\":4,\"201\":7,\"202\":6,\"224\":2}}],[\"band\",{\"1\":{\"71\":3}}],[\"banana\",{\"1\":{\"15\":1,\"19\":2}}],[\"basic\",{\"0\":{\"250\":1},\"1\":{\"65\":1}}],[\"base\",{\"1\":{\"142\":2,\"145\":1,\"156\":2,\"157\":2,\"159\":1,\"163\":2,\"171\":2,\"178\":2,\"184\":1,\"189\":1,\"191\":1,\"194\":1,\"205\":1,\"208\":1,\"214\":1,\"216\":1}}],[\"base64\",{\"1\":{\"48\":1}}],[\"based\",{\"0\":{\"168\":1,\"169\":1,\"214\":1},\"1\":{\"33\":1,\"168\":2,\"169\":3,\"173\":1}}],[\"bagging\",{\"1\":{\"33\":1}}],[\"body\",{\"1\":{\"222\":1}}],[\"boys\",{\"1\":{\"222\":1}}],[\"bounded\",{\"1\":{\"111\":1}}],[\"booting\",{\"1\":{\"80\":1}}],[\"boot\",{\"0\":{\"80\":1},\"1\":{\"75\":1}}],[\"bootp\",{\"1\":{\"75\":3,\"77\":1,\"80\":2}}],[\"bootstrap\",{\"1\":{\"33\":1}}],[\"boosting\",{\"1\":{\"33\":1}}],[\"boolean\",{\"1\":{\"12\":1,\"13\":1,\"17\":1,\"120\":1,\"236\":1,\"241\":2}}],[\"both\",{\"1\":{\"33\":2}}],[\"b\",{\"1\":{\"21\":2,\"42\":2,\"61\":1,\"125\":3,\"139\":2,\"231\":2,\"232\":1}}],[\"bridge\",{\"1\":{\"233\":6}}],[\"britain\",{\"1\":{\"3\":1}}],[\"branch\",{\"1\":{\"214\":3}}],[\"brother\",{\"1\":{\"188\":2}}],[\"broadcast\",{\"1\":{\"71\":1}}],[\"brd\",{\"1\":{\"71\":1}}],[\"break\",{\"1\":{\"13\":1,\"14\":1,\"47\":1,\"87\":1,\"120\":1,\"121\":1,\"123\":1,\"196\":1}}],[\"gained\",{\"1\":{\"222\":1}}],[\"gain\",{\"1\":{\"222\":1}}],[\"garbage\",{\"1\":{\"96\":1}}],[\"gzip\",{\"1\":{\"219\":1}}],[\"gz\",{\"1\":{\"219\":5,\"220\":2}}],[\"github\",{\"1\":{\"219\":2,\"220\":1}}],[\"gitattributes\",{\"1\":{\"213\":1,\"214\":1}}],[\"git\",{\"0\":{\"214\":1},\"1\":{\"204\":1,\"206\":2,\"211\":2,\"212\":2,\"213\":16,\"214\":23}}],[\"gpu\",{\"1\":{\"193\":1,\"200\":2,\"202\":1,\"203\":1}}],[\"gpt\",{\"1\":{\"146\":1,\"147\":1,\"150\":2,\"170\":1}}],[\"going\",{\"1\":{\"222\":1}}],[\"gotten\",{\"1\":{\"222\":1}}],[\"got\",{\"1\":{\"178\":1}}],[\"google\",{\"1\":{\"142\":1}}],[\"gc\",{\"1\":{\"96\":1}}],[\"grad\",{\"1\":{\"160\":2,\"178\":1,\"179\":3,\"180\":1,\"197\":1,\"200\":1,\"201\":1,\"202\":2}}],[\"group\",{\"1\":{\"71\":1}}],[\"great\",{\"1\":{\"3\":1,\"222\":1}}],[\"gb1212\",{\"1\":{\"60\":2}}],[\"gb18030\",{\"0\":{\"61\":1},\"1\":{\"58\":1,\"61\":7}}],[\"gb2312\",{\"0\":{\"59\":1},\"1\":{\"58\":2,\"59\":4}}],[\"gb2312的汉字编号空间是94\",{\"1\":{\"45\":1}}],[\"gb\",{\"1\":{\"58\":5,\"62\":1}}],[\"gbk\",{\"0\":{\"57\":1,\"60\":1},\"1\":{\"58\":2,\"60\":2,\"61\":4,\"66\":1}}],[\"gbk2312\",{\"0\":{\"57\":1}}],[\"gluten\",{\"1\":{\"222\":2}}],[\"glue\",{\"1\":{\"21\":1,\"187\":1,\"188\":1,\"191\":1,\"193\":2,\"194\":1,\"201\":1}}],[\"global\",{\"0\":{\"7\":1},\"1\":{\"7\":1,\"71\":2}}],[\"gelu\",{\"1\":{\"162\":1}}],[\"generation\",{\"1\":{\"144\":1}}],[\"generator\",{\"1\":{\"144\":2}}],[\"generalized\",{\"1\":{\"33\":2}}],[\"get\",{\"1\":{\"116\":1,\"199\":2,\"202\":4}}],[\"getownpropertysymbols\",{\"1\":{\"6\":1,\"11\":1}}],[\"germany\",{\"1\":{\"3\":1}}],[\"显然\",{\"1\":{\"156\":1}}],[\"显然这样的模型在实际中不会获得好的效果\",{\"1\":{\"152\":1}}],[\"显示地将\",{\"1\":{\"19\":1}}],[\"显示调用迭代器\",{\"0\":{\"14\":1}}],[\"显示\",{\"1\":{\"3\":1}}],[\"显式转换为数字\",{\"1\":{\"3\":1}}],[\"不能处理其他任何进制\",{\"1\":{\"243\":1}}],[\"不能自动转换成\",{\"1\":{\"5\":1}}],[\"不能自动转化成\",{\"1\":{\"5\":1}}],[\"不支持科学计数法\",{\"1\":{\"243\":1}}],[\"不支持的部分中文简体\",{\"1\":{\"60\":1}}],[\"不在右边的网口\",{\"1\":{\"232\":1}}],[\"不是\",{\"1\":{\"195\":1}}],[\"不是整数属性\",{\"1\":{\"3\":2}}],[\"不论如何\",{\"1\":{\"183\":1}}],[\"不大时\",{\"1\":{\"131\":1}}],[\"不稳定\",{\"1\":{\"122\":1,\"126\":1}}],[\"不做交换\",{\"1\":{\"120\":1}}],[\"不带哨兵结点的链表叫做不带头链表\",{\"1\":{\"103\":1}}],[\"不管链表是否为空\",{\"1\":{\"103\":1}}],[\"不会为其他客户分配同一个\",{\"1\":{\"76\":1}}],[\"不会允许配置成功\",{\"1\":{\"72\":1}}],[\"不会在任何网络中出现\",{\"1\":{\"71\":1}}],[\"不对进入的数据包做任何处理\",{\"1\":{\"71\":1}}],[\"不可显示不可打印的控制字符del\",{\"1\":{\"53\":1}}],[\"不可显示不可打印的控制字符或通讯专用字符\",{\"1\":{\"53\":1}}],[\"不同\",{\"1\":{\"198\":1,\"234\":1}}],[\"不同的模型会使用不同的特殊词\",{\"1\":{\"183\":1}}],[\"不同的加载方法\",{\"0\":{\"163\":1}}],[\"不同的码元序列或是字节序列\",{\"1\":{\"49\":1}}],[\"不同系统的配置文件格式不同\",{\"1\":{\"72\":1}}],[\"不同于具有特定字型的\",{\"1\":{\"44\":1}}],[\"不同于\",{\"1\":{\"3\":2,\"66\":1}}],[\"不用担心引入得太多\",{\"1\":{\"25\":1}}],[\"不需要\",{\"1\":{\"212\":1}}],[\"不需要进行交换\",{\"1\":{\"120\":1}}],[\"不需要进一步进行类型转化\",{\"1\":{\"20\":1}}],[\"不需要在最后加分号\",{\"1\":{\"24\":1}}],[\"不改变原数组\",{\"1\":{\"21\":2}}],[\"不要用\",{\"0\":{\"20\":1}}],[\"不获取索引\",{\"1\":{\"19\":1}}],[\"不过使用效果肯定很差\",{\"1\":{\"163\":1}}],[\"不过\",{\"1\":{\"111\":1}}],[\"不过很少这样做\",{\"1\":{\"14\":1}}],[\"不过并行执行\",{\"1\":{\"13\":1}}],[\"不存在\",{\"1\":{\"8\":1}}],[\"⇒\",{\"1\":{\"3\":2}}],[\"相对于\",{\"1\":{\"169\":1}}],[\"相关的前五名答案之一\",{\"1\":{\"145\":1}}],[\"相关信息\",{\"1\":{\"3\":1}}],[\"相比于上面的代码\",{\"1\":{\"103\":1}}],[\"相当于是一组字符集的总称\",{\"1\":{\"56\":1}}],[\"相当于\",{\"1\":{\"19\":1}}],[\"相等\",{\"1\":{\"4\":1,\"11\":1}}],[\"相同的\",{\"1\":{\"8\":1}}],[\"相同\",{\"1\":{\"3\":1,\"240\":1}}],[\"箱单与\",{\"1\":{\"2\":1}}],[\"two\",{\"1\":{\"222\":1}}],[\"tired\",{\"1\":{\"222\":1}}],[\"tirosint\",{\"1\":{\"222\":6}}],[\"title\",{\"1\":{\"219\":3}}],[\"time\",{\"0\":{\"87\":2,\"88\":1,\"89\":1},\"1\":{\"80\":3}}],[\"txt\",{\"1\":{\"218\":1}}],[\"tsv\",{\"1\":{\"218\":1,\"222\":4}}],[\"tqdm\",{\"1\":{\"200\":4,\"202\":2}}],[\"tuning\",{\"1\":{\"149\":1,\"186\":1}}],[\"tune\",{\"1\":{\"147\":1,\"214\":1,\"217\":1}}],[\"t5\",{\"1\":{\"146\":1,\"147\":1,\"150\":1}}],[\"taking\",{\"1\":{\"222\":3}}],[\"take\",{\"1\":{\"222\":1}}],[\"tazorac\",{\"1\":{\"222\":1}}],[\"tasks\",{\"1\":{\"216\":1}}],[\"tag\",{\"1\":{\"213\":1,\"234\":1}}],[\"tail\",{\"1\":{\"108\":2}}],[\"target\",{\"1\":{\"21\":2}}],[\"tmp\",{\"1\":{\"103\":2,\"120\":2,\"122\":2,\"123\":2,\"125\":5,\"130\":3}}],[\"t\",{\"1\":{\"85\":2,\"125\":7,\"126\":2,\"222\":1}}],[\"tcp\",{\"1\":{\"71\":1,\"79\":1}}],[\"tftp\",{\"1\":{\"81\":6}}],[\"tf\",{\"1\":{\"47\":1,\"178\":1}}],[\"tbyte\",{\"1\":{\"42\":1}}],[\"tn\",{\"1\":{\"36\":1}}],[\"tpu\",{\"1\":{\"193\":1,\"202\":2,\"203\":1}}],[\"tp\",{\"1\":{\"36\":1}}],[\"teacher\",{\"1\":{\"145\":1}}],[\"teach\",{\"1\":{\"144\":1}}],[\"text\",{\"1\":{\"144\":1,\"168\":2,\"218\":3,\"223\":2}}],[\"tes\",{\"0\":{\"48\":1},\"1\":{\"47\":1}}],[\"testing\",{\"1\":{\"33\":1}}],[\"test\",{\"1\":{\"2\":2,\"37\":1,\"38\":1,\"39\":1,\"40\":1,\"188\":2,\"189\":1,\"192\":1,\"193\":1,\"219\":7,\"220\":2,\"222\":1,\"223\":1}}],[\"tensorflow\",{\"1\":{\"178\":1}}],[\"tensors=\",{\"1\":{\"156\":1,\"178\":4,\"184\":1}}],[\"tensors\",{\"1\":{\"156\":1,\"178\":3,\"182\":1,\"190\":1}}],[\"tensor\",{\"1\":{\"156\":3,\"160\":2,\"165\":3,\"178\":6,\"179\":8,\"180\":5,\"185\":1,\"195\":1,\"197\":1}}],[\"ten\",{\"1\":{\"42\":1}}],[\"term\",{\"1\":{\"33\":1}}],[\"try\",{\"1\":{\"222\":1}}],[\"trainerarguments\",{\"1\":{\"208\":3}}],[\"trainer\",{\"0\":{\"191\":1},\"1\":{\"191\":2,\"192\":13,\"193\":10,\"194\":2,\"195\":1,\"198\":1,\"199\":1,\"208\":4}}],[\"trained\",{\"1\":{\"163\":2}}],[\"trainingarguments\",{\"1\":{\"192\":4,\"193\":1}}],[\"training\",{\"0\":{\"192\":1,\"200\":1},\"1\":{\"188\":1,\"192\":5,\"193\":2,\"195\":1,\"199\":7,\"200\":1,\"202\":10,\"203\":1,\"208\":1,\"215\":2}}],[\"train\",{\"1\":{\"188\":6,\"189\":5,\"190\":2,\"191\":1,\"192\":4,\"193\":3,\"195\":1,\"196\":3,\"199\":1,\"200\":2,\"202\":12,\"208\":1,\"214\":1,\"219\":11,\"220\":2,\"222\":2,\"223\":2}}],[\"transform\",{\"1\":{\"173\":1}}],[\"transformer\",{\"0\":{\"140\":1,\"146\":1,\"147\":1,\"148\":1,\"150\":1,\"162\":1,\"165\":1},\"1\":{\"146\":5,\"147\":1,\"150\":4,\"152\":2,\"153\":2,\"154\":2,\"156\":2,\"157\":4,\"158\":1,\"165\":1,\"171\":1,\"173\":1,\"175\":1,\"179\":1,\"181\":1,\"185\":2,\"223\":2}}],[\"transformers\",{\"0\":{\"143\":1,\"144\":1,\"154\":1},\"1\":{\"30\":1,\"143\":1,\"144\":3,\"145\":1,\"153\":1,\"154\":1,\"156\":2,\"157\":3,\"159\":1,\"160\":1,\"162\":2,\"163\":2,\"164\":1,\"171\":2,\"173\":1,\"178\":3,\"184\":1,\"189\":1,\"190\":2,\"191\":2,\"192\":6,\"194\":1,\"197\":1,\"198\":1,\"199\":1,\"202\":2,\"204\":1,\"208\":2,\"214\":1}}],[\"transfer\",{\"0\":{\"48\":1,\"149\":1},\"1\":{\"147\":1}}],[\"tree\",{\"1\":{\"33\":1,\"233\":1}}],[\"trees\",{\"1\":{\"33\":1}}],[\"trunk\",{\"1\":{\"234\":1}}],[\"truncate\",{\"1\":{\"181\":2,\"182\":1,\"184\":1}}],[\"truncation=true\",{\"1\":{\"156\":1,\"181\":2,\"184\":1,\"189\":2,\"191\":1,\"194\":1}}],[\"truncation\",{\"1\":{\"156\":1}}],[\"trunc\",{\"1\":{\"3\":4}}],[\"true\",{\"1\":{\"2\":1,\"8\":1,\"12\":1,\"13\":2,\"14\":1,\"17\":1,\"19\":1,\"20\":1,\"21\":4,\"36\":2,\"120\":1,\"123\":1,\"162\":1,\"189\":1,\"224\":1,\"239\":1,\"241\":1,\"245\":1}}],[\"type\",{\"1\":{\"71\":1,\"162\":3,\"171\":2,\"189\":8,\"190\":1,\"195\":1,\"196\":1,\"209\":1,\"212\":1}}],[\"typeof\",{\"1\":{\"21\":1}}],[\"typeerror\",{\"1\":{\"5\":1}}],[\"thinking\",{\"1\":{\"222\":1}}],[\"this\",{\"1\":{\"13\":11,\"21\":5,\"28\":1,\"144\":2,\"145\":2,\"156\":2,\"178\":1,\"189\":6,\"222\":2}}],[\"thisarg\",{\"1\":{\"12\":1,\"16\":1,\"17\":1,\"21\":6}}],[\"three\",{\"1\":{\"222\":1}}],[\"throw\",{\"1\":{\"115\":1}}],[\"thyroidectomy\",{\"1\":{\"222\":1}}],[\"thyroid\",{\"1\":{\"222\":1}}],[\"than\",{\"1\":{\"181\":2,\"222\":1}}],[\"that\",{\"1\":{\"33\":1,\"34\":1,\"181\":2,\"222\":5}}],[\"then\",{\"1\":{\"222\":5}}],[\"the\",{\"1\":{\"34\":7,\"150\":1,\"153\":1,\"157\":1,\"180\":6,\"181\":4,\"188\":2,\"189\":6,\"192\":1,\"209\":1,\"214\":1,\"222\":16}}],[\"their\",{\"1\":{\"6\":1}}],[\"todo\",{\"1\":{\"246\":1}}],[\"tofdo\",{\"1\":{\"245\":1}}],[\"toner\",{\"1\":{\"222\":1}}],[\"too\",{\"1\":{\"222\":1}}],[\"tools\",{\"1\":{\"71\":6}}],[\"touch\",{\"1\":{\"222\":1}}],[\"total\",{\"1\":{\"222\":1}}],[\"torch\",{\"1\":{\"158\":1,\"159\":1,\"160\":2,\"165\":2,\"178\":4,\"179\":3,\"180\":1,\"184\":1,\"190\":4,\"192\":1,\"195\":1,\"196\":5,\"197\":1,\"200\":4,\"201\":2,\"202\":3}}],[\"token=\",{\"1\":{\"208\":1}}],[\"tokenize\",{\"1\":{\"173\":2,\"178\":2,\"183\":1,\"191\":2,\"194\":2}}],[\"tokenized\",{\"1\":{\"168\":2,\"178\":2,\"189\":7,\"190\":1,\"191\":1,\"193\":1,\"194\":1,\"195\":8,\"196\":2}}],[\"tokenizer=tokenizer\",{\"1\":{\"190\":1,\"191\":1,\"192\":1,\"193\":1,\"194\":1}}],[\"tokenizer\",{\"0\":{\"156\":1,\"182\":1},\"1\":{\"154\":3,\"156\":6,\"158\":1,\"160\":1,\"165\":2,\"166\":1,\"168\":6,\"169\":1,\"171\":10,\"172\":4,\"173\":3,\"174\":1,\"175\":1,\"176\":1,\"178\":12,\"179\":2,\"180\":5,\"181\":3,\"182\":1,\"183\":7,\"184\":3,\"185\":3,\"186\":1,\"189\":8,\"190\":1,\"191\":2,\"192\":2,\"194\":2,\"202\":1,\"203\":1,\"208\":8,\"213\":5,\"214\":9}}],[\"tokenizers\",{\"0\":{\"166\":1,\"204\":1},\"1\":{\"30\":1,\"189\":1,\"208\":1}}],[\"tokenization\",{\"0\":{\"167\":1,\"170\":1,\"173\":1},\"1\":{\"166\":1,\"169\":1,\"170\":3,\"172\":1,\"173\":1,\"176\":1,\"185\":1,\"189\":2}}],[\"tokens\",{\"0\":{\"174\":1},\"1\":{\"156\":1,\"169\":2,\"172\":2,\"173\":2,\"174\":3,\"175\":2,\"176\":1,\"178\":6,\"179\":2,\"180\":1,\"181\":1,\"183\":3,\"184\":2,\"189\":1,\"208\":1,\"214\":3}}],[\"token\",{\"0\":{\"183\":1},\"1\":{\"145\":2,\"156\":1,\"162\":1,\"168\":7,\"169\":2,\"171\":2,\"179\":5,\"180\":1,\"183\":1,\"189\":8,\"190\":2,\"195\":1,\"196\":1,\"208\":1,\"209\":3,\"212\":1}}],[\"tos\",{\"1\":{\"71\":2}}],[\"tostring\",{\"1\":{\"5\":2,\"19\":2}}],[\"to\",{\"0\":{\"208\":1,\"245\":1},\"1\":{\"13\":5,\"31\":1,\"144\":1,\"146\":1,\"150\":1,\"174\":2,\"178\":3,\"180\":3,\"183\":1,\"188\":1,\"189\":1,\"192\":1,\"200\":2,\"201\":1,\"202\":2,\"206\":1,\"208\":9,\"209\":1,\"212\":1,\"213\":5,\"214\":8,\"215\":1,\"222\":21}}],[\"toprimitive\",{\"1\":{\"10\":1,\"19\":1}}],[\"0c13\",{\"1\":{\"243\":1}}],[\"0b111\",{\"1\":{\"243\":1}}],[\"0860\",{\"1\":{\"229\":1}}],[\"0800\",{\"1\":{\"229\":1}}],[\"039\",{\"1\":{\"222\":1,\"223\":1}}],[\"000\",{\"1\":{\"168\":2}}],[\"0005\",{\"1\":{\"160\":1}}],[\"0402\",{\"1\":{\"160\":1}}],[\"04\",{\"1\":{\"160\":1}}],[\"01\",{\"1\":{\"160\":2}}],[\"0195e\",{\"1\":{\"160\":1}}],[\"02\",{\"1\":{\"160\":1,\"162\":1}}],[\"097\",{\"1\":{\"70\":1}}],[\"0~239\",{\"1\":{\"70\":1}}],[\"0~223\",{\"1\":{\"70\":1}}],[\"0~255\",{\"1\":{\"67\":1,\"70\":1}}],[\"0~192\",{\"1\":{\"70\":1}}],[\"0~191\",{\"1\":{\"70\":1}}],[\"0~172\",{\"1\":{\"70\":1}}],[\"0~10\",{\"1\":{\"70\":1}}],[\"0~127\",{\"1\":{\"58\":1,\"67\":1,\"70\":1}}],[\"0~31\",{\"1\":{\"53\":1}}],[\"0x\",{\"1\":{\"243\":1}}],[\"0x1f\",{\"1\":{\"239\":2}}],[\"0xdfff\",{\"1\":{\"65\":1}}],[\"0xd800\",{\"1\":{\"65\":1}}],[\"0xe000~0xf8ff\",{\"1\":{\"65\":1}}],[\"0xa0~0xff\",{\"1\":{\"56\":1}}],[\"0xff\",{\"1\":{\"54\":1,\"243\":1}}],[\"0xfeff\",{\"1\":{\"47\":1}}],[\"0x80\",{\"1\":{\"54\":1}}],[\"0x0a\",{\"1\":{\"53\":1}}],[\"0x0d\",{\"1\":{\"53\":1}}],[\"0x00\",{\"1\":{\"53\":1}}],[\"0x07\",{\"1\":{\"53\":1}}],[\"0\",{\"1\":{\"2\":4,\"15\":1,\"19\":2,\"20\":2,\"21\":4,\"53\":1,\"55\":1,\"58\":1,\"65\":2,\"66\":1,\"70\":20,\"71\":3,\"75\":4,\"77\":4,\"80\":4,\"81\":1,\"87\":1,\"103\":4,\"115\":1,\"117\":1,\"120\":3,\"121\":1,\"122\":1,\"125\":3,\"126\":1,\"127\":2,\"130\":7,\"144\":3,\"156\":16,\"160\":5,\"162\":4,\"168\":1,\"171\":9,\"178\":1,\"179\":2,\"180\":2033,\"188\":3,\"189\":16,\"193\":2,\"197\":1,\"199\":1,\"201\":2,\"219\":1,\"222\":5,\"237\":2,\"239\":11,\"243\":1}}],[\"small\",{\"1\":{\"222\":1}}],[\"skin\",{\"1\":{\"222\":2}}],[\"sklearn\",{\"1\":{\"37\":1,\"38\":1,\"39\":1,\"40\":1}}],[\"slicing\",{\"0\":{\"222\":1}}],[\"slice\",{\"1\":{\"16\":5,\"21\":1}}],[\"squad\",{\"1\":{\"219\":17,\"220\":4}}],[\"squares\",{\"1\":{\"33\":1}}],[\"side\",{\"1\":{\"222\":3}}],[\"sideeffectsreview\",{\"1\":{\"222\":1}}],[\"sideeffects\",{\"1\":{\"222\":1}}],[\"simple\",{\"1\":{\"171\":1,\"173\":2,\"175\":1}}],[\"size=8\",{\"1\":{\"196\":2}}],[\"size\",{\"1\":{\"158\":3,\"159\":1,\"162\":4,\"190\":4,\"196\":4,\"197\":1,\"222\":1,\"224\":1}}],[\"sat\",{\"1\":{\"222\":1}}],[\"said\",{\"1\":{\"222\":1}}],[\"sample\",{\"1\":{\"222\":2}}],[\"samples\",{\"1\":{\"190\":5}}],[\"saved\",{\"1\":{\"222\":1}}],[\"save\",{\"1\":{\"164\":2,\"171\":2,\"208\":1,\"213\":2,\"214\":2}}],[\"say\",{\"1\":{\"29\":1}}],[\"sayhi\",{\"1\":{\"28\":1,\"29\":2}}],[\"shocked\",{\"1\":{\"222\":1}}],[\"should\",{\"1\":{\"222\":1}}],[\"shows\",{\"1\":{\"222\":1}}],[\"shuffle\",{\"1\":{\"222\":2}}],[\"shuffle=true\",{\"1\":{\"196\":1}}],[\"shell\",{\"1\":{\"219\":1}}],[\"shape\",{\"1\":{\"158\":1,\"159\":1,\"190\":1,\"193\":2,\"196\":1,\"197\":1}}],[\"shift\",{\"1\":{\"19\":2,\"21\":1}}],[\"sst\",{\"1\":{\"156\":2,\"157\":2,\"159\":1,\"178\":2,\"184\":1}}],[\"swelling\",{\"1\":{\"222\":2}}],[\"swell\",{\"1\":{\"222\":1}}],[\"switching\",{\"1\":{\"222\":1}}],[\"switched\",{\"1\":{\"222\":2}}],[\"switzerland\",{\"1\":{\"3\":1}}],[\"swap\",{\"1\":{\"110\":1,\"126\":2}}],[\"synthroid\",{\"1\":{\"222\":2}}],[\"syntax\",{\"0\":{\"48\":1}}],[\"symptoms\",{\"1\":{\"222\":3}}],[\"symptms\",{\"1\":{\"222\":1}}],[\"sym2\",{\"1\":{\"9\":2}}],[\"sym\",{\"1\":{\"9\":4}}],[\"symbols\",{\"0\":{\"5\":1,\"7\":1},\"1\":{\"5\":1,\"156\":1}}],[\"symbol\",{\"0\":{\"4\":1,\"8\":2,\"9\":2,\"10\":1,\"13\":1,\"240\":1},\"1\":{\"2\":1,\"4\":12,\"5\":7,\"6\":11,\"7\":5,\"8\":10,\"9\":9,\"10\":7,\"11\":14,\"12\":2,\"13\":5,\"14\":1,\"15\":1,\"17\":2,\"19\":1,\"21\":2,\"236\":1,\"240\":4,\"241\":3}}],[\"scheduler\",{\"0\":{\"199\":1},\"1\":{\"199\":4,\"200\":1,\"202\":8}}],[\"scheme\",{\"0\":{\"47\":1}}],[\"scope\",{\"1\":{\"71\":1}}],[\"score的超级无敌深入探讨\",{\"1\":{\"40\":1}}],[\"score相同的权重\",{\"1\":{\"40\":1}}],[\"score和recall\",{\"1\":{\"40\":1}}],[\"score\",{\"0\":{\"40\":1},\"1\":{\"36\":1,\"37\":2,\"38\":2,\"39\":2,\"40\":3,\"144\":3}}],[\"script\",{\"1\":{\"218\":1,\"219\":1}}],[\"scr\",{\"1\":{\"45\":1}}],[\"scalar\",{\"1\":{\"33\":1,\"45\":1}}],[\"section2\",{\"0\":{\"253\":1}}],[\"section1\",{\"0\":{\"252\":1,\"254\":1}}],[\"second\",{\"1\":{\"189\":3}}],[\"see\",{\"1\":{\"222\":1}}],[\"sever\",{\"1\":{\"222\":2}}],[\"severe\",{\"1\":{\"222\":1}}],[\"sep\",{\"1\":{\"183\":2,\"189\":6}}],[\"sentence\",{\"1\":{\"189\":3}}],[\"sentences\",{\"1\":{\"189\":2}}],[\"sentence2\",{\"1\":{\"188\":6,\"189\":7,\"190\":2,\"191\":1,\"194\":1,\"195\":2}}],[\"sentence1\",{\"1\":{\"188\":6,\"189\":7,\"190\":2,\"191\":1,\"194\":1,\"195\":2}}],[\"sentencepiece\",{\"1\":{\"170\":1,\"214\":4}}],[\"sentiment\",{\"1\":{\"144\":2,\"156\":3}}],[\"select\",{\"1\":{\"222\":3}}],[\"selectionsort\",{\"1\":{\"122\":1}}],[\"selection\",{\"0\":{\"122\":1},\"1\":{\"33\":1}}],[\"self\",{\"1\":{\"147\":1}}],[\"server\",{\"1\":{\"76\":5,\"77\":4,\"78\":1,\"79\":1,\"80\":5,\"81\":2}}],[\"service\",{\"1\":{\"71\":1}}],[\"serialization\",{\"1\":{\"47\":1}}],[\"sequence2\",{\"1\":{\"179\":3,\"180\":1}}],[\"sequence1\",{\"1\":{\"179\":2}}],[\"sequences\",{\"1\":{\"165\":3,\"178\":4,\"180\":8,\"181\":5,\"184\":2}}],[\"sequences=2\",{\"1\":{\"144\":1}}],[\"sequence\",{\"1\":{\"46\":1,\"49\":2,\"146\":2,\"150\":2,\"158\":1,\"159\":1,\"173\":2,\"178\":5,\"180\":1,\"181\":3,\"183\":3,\"192\":1}}],[\"set\",{\"0\":{\"45\":1},\"1\":{\"12\":1,\"33\":1,\"42\":1,\"62\":1,\"188\":3,\"190\":1,\"195\":1}}],[\"sun\",{\"1\":{\"222\":1}}],[\"sunscreen\",{\"1\":{\"222\":1}}],[\"subsided\",{\"1\":{\"222\":1}}],[\"subword\",{\"0\":{\"170\":1},\"1\":{\"169\":1,\"170\":2}}],[\"subwords\",{\"1\":{\"156\":1}}],[\"subnet\",{\"1\":{\"80\":2}}],[\"supervised\",{\"1\":{\"147\":1}}],[\"supplementary\",{\"1\":{\"65\":1}}],[\"support\",{\"1\":{\"33\":2}}],[\"surprise\",{\"1\":{\"222\":1}}],[\"survival\",{\"1\":{\"33\":1}}],[\"surrogate\",{\"1\":{\"12\":1,\"14\":1,\"16\":1,\"17\":1,\"65\":1}}],[\"soak\",{\"1\":{\"222\":1}}],[\"sore\",{\"1\":{\"222\":1}}],[\"sorted\",{\"1\":{\"118\":1}}],[\"sort\",{\"0\":{\"120\":1,\"121\":1,\"122\":1,\"125\":1,\"126\":1,\"129\":1,\"130\":1,\"131\":1},\"1\":{\"21\":5,\"125\":8,\"126\":8,\"223\":2}}],[\"softmax\",{\"1\":{\"160\":2}}],[\"soft\",{\"1\":{\"151\":1}}],[\"so\",{\"1\":{\"144\":1,\"156\":2,\"178\":1,\"180\":1,\"181\":1,\"184\":1,\"222\":4}}],[\"soldiers\",{\"1\":{\"21\":4}}],[\"some\",{\"1\":{\"21\":1,\"209\":1,\"222\":1}}],[\"something\",{\"1\":{\"21\":3}}],[\"s\",{\"0\":{\"15\":1,\"96\":1},\"1\":{\"40\":1,\"239\":3}}],[\"spanning\",{\"1\":{\"233\":1}}],[\"space\",{\"1\":{\"45\":1,\"47\":1,\"64\":1,\"209\":2}}],[\"specification\",{\"1\":{\"216\":1}}],[\"specified\",{\"1\":{\"180\":1,\"181\":1}}],[\"special\",{\"1\":{\"214\":3}}],[\"split\",{\"1\":{\"21\":2,\"168\":1,\"222\":3,\"223\":1}}],[\"splice\",{\"1\":{\"21\":2}}],[\"sp\",{\"0\":{\"65\":1},\"1\":{\"14\":1,\"65\":3,\"238\":2}}],[\"stp\",{\"0\":{\"233\":1},\"1\":{\"233\":1}}],[\"style\",{\"1\":{\"80\":1}}],[\"steps=num\",{\"1\":{\"199\":1,\"202\":2}}],[\"steps=0\",{\"1\":{\"199\":1,\"202\":2}}],[\"steps\",{\"1\":{\"192\":3,\"199\":4,\"200\":1,\"202\":6}}],[\"step\",{\"0\":{\"75\":1,\"76\":1,\"77\":1,\"78\":1},\"1\":{\"200\":2,\"202\":4}}],[\"stepwise\",{\"1\":{\"33\":1}}],[\"storage\",{\"1\":{\"46\":1,\"211\":1,\"213\":1}}],[\"stay\",{\"1\":{\"222\":1}}],[\"staged\",{\"1\":{\"214\":2}}],[\"status\",{\"1\":{\"214\":2}}],[\"states\",{\"0\":{\"158\":1},\"1\":{\"157\":1,\"159\":1}}],[\"state\",{\"1\":{\"71\":1,\"158\":1,\"164\":1}}],[\"statistical\",{\"1\":{\"31\":1,\"33\":2}}],[\"standard\",{\"1\":{\"53\":2}}],[\"started\",{\"1\":{\"222\":3}}],[\"start\",{\"1\":{\"16\":2,\"21\":9}}],[\"strategy=\",{\"1\":{\"193\":1,\"208\":1}}],[\"strategy\",{\"1\":{\"192\":1}}],[\"str\",{\"0\":{\"243\":1},\"1\":{\"14\":5,\"16\":6,\"21\":1,\"145\":2}}],[\"stringtonumber\",{\"0\":{\"243\":1}}],[\"string并非\",{\"1\":{\"238\":1}}],[\"string\",{\"0\":{\"238\":1,\"244\":1},\"1\":{\"3\":3,\"4\":1,\"5\":2,\"6\":1,\"12\":2,\"14\":1,\"15\":1,\"17\":1,\"19\":1,\"42\":1,\"175\":2,\"188\":2,\"236\":1,\"238\":3,\"240\":1,\"241\":2,\"244\":2}}],[\"sting\",{\"1\":{\"2\":1}}],[\"或命名实体\",{\"1\":{\"141\":1}}],[\"或移动\",{\"1\":{\"118\":1}}],[\"或puz\",{\"1\":{\"65\":1}}],[\"或其他字符\",{\"1\":{\"58\":1}}],[\"或码点编号\",{\"1\":{\"45\":1}}],[\"或者想先运行数据处理的整体代码\",{\"1\":{\"187\":1}}],[\"或者和我的一个网卡是否在同一个网段\",{\"1\":{\"72\":1}}],[\"或者\",{\"1\":{\"71\":2,\"156\":1,\"204\":1,\"206\":1}}],[\"或者说\",{\"1\":{\"56\":1}}],[\"或者进程长度编码等无损压缩技术\",{\"1\":{\"48\":1}}],[\"或者映射到\",{\"1\":{\"45\":1}}],[\"或者输出\",{\"1\":{\"5\":1}}],[\"或\",{\"0\":{\"158\":1},\"1\":{\"2\":1,\"6\":1,\"11\":1,\"12\":1,\"45\":1,\"47\":1,\"150\":1,\"168\":1,\"192\":1,\"202\":1,\"209\":2,\"212\":1,\"223\":1,\"243\":1}}],[\"60mg\",{\"1\":{\"222\":1}}],[\"6617\",{\"1\":{\"197\":1}}],[\"62\",{\"1\":{\"190\":1}}],[\"6251\",{\"1\":{\"189\":1}}],[\"67\",{\"1\":{\"190\":6}}],[\"6763\",{\"1\":{\"59\":1}}],[\"6123\",{\"1\":{\"160\":2}}],[\"65\",{\"1\":{\"70\":1}}],[\"65~90\",{\"1\":{\"53\":1}}],[\"682\",{\"1\":{\"59\":2}}],[\"646\",{\"1\":{\"53\":1,\"67\":1}}],[\"64位甚至高达128位\",{\"1\":{\"42\":1}}],[\"64\",{\"1\":{\"42\":1,\"239\":2}}],[\"6\",{\"0\":{\"49\":1,\"79\":1,\"106\":1,\"242\":1,\"243\":1,\"244\":1,\"245\":1,\"246\":1},\"1\":{\"2\":1,\"4\":1,\"19\":1,\"21\":4,\"71\":1,\"72\":4,\"146\":1,\"222\":1,\"229\":2,\"230\":4,\"240\":1}}],[\"+0\",{\"1\":{\"239\":1}}],[\"+3\",{\"1\":{\"239\":1}}],[\"+3×n\",{\"1\":{\"125\":1}}],[\"+2×n=8×t\",{\"1\":{\"125\":1}}],[\"+2×n=4×\",{\"1\":{\"125\":1}}],[\"+k×n​\",{\"1\":{\"125\":1}}],[\"+k\",{\"1\":{\"125\":1}}],[\"+t\",{\"1\":{\"125\":1}}],[\"++\",{\"1\":{\"130\":1}}],[\"++j\",{\"1\":{\"120\":1,\"122\":1,\"126\":1}}],[\"++1\",{\"1\":{\"117\":1}}],[\"++depth\",{\"1\":{\"115\":1}}],[\"++i\",{\"1\":{\"87\":1,\"103\":2,\"120\":1,\"121\":1,\"122\":1,\"125\":1,\"130\":5}}],[\"+f\",{\"1\":{\"114\":1}}],[\"+n=4×t\",{\"1\":{\"125\":1}}],[\"+n\",{\"1\":{\"125\":3,\"126\":1}}],[\"+n×2n1​+n×21​=43n+1​\",{\"1\":{\"88\":1}}],[\"+n+n​=2\",{\"1\":{\"88\":1}}],[\"+code\",{\"1\":{\"3\":1}}],[\"+1=2n−1\",{\"1\":{\"127\":1}}],[\"+1\",{\"1\":{\"3\":1}}],[\"+44\",{\"1\":{\"3\":1}}],[\"+41\",{\"1\":{\"3\":1}}],[\"+49\",{\"1\":{\"3\":3}}],[\"+\",{\"1\":{\"2\":2,\"3\":1,\"19\":3,\"70\":1,\"108\":1,\"114\":1,\"115\":1,\"116\":3,\"117\":1,\"120\":1,\"121\":1,\"122\":1,\"125\":1,\"126\":1,\"130\":2,\"157\":1,\"202\":6,\"220\":2,\"239\":4}}],[\"37\",{\"1\":{\"222\":1}}],[\"3755\",{\"1\":{\"59\":1}}],[\"35686c2\",{\"1\":{\"214\":1}}],[\"3668\",{\"1\":{\"188\":1,\"189\":1}}],[\"3374\",{\"1\":{\"179\":1}}],[\"33~126\",{\"1\":{\"53\":1}}],[\"3895\",{\"1\":{\"179\":2,\"180\":1}}],[\"3835\",{\"1\":{\"165\":1}}],[\"384\",{\"1\":{\"70\":1}}],[\"3422\",{\"1\":{\"222\":1}}],[\"3464\",{\"1\":{\"160\":1}}],[\"3403\",{\"1\":{\"156\":1,\"178\":2,\"180\":4,\"181\":2,\"183\":2}}],[\"3e\",{\"1\":{\"71\":1}}],[\"31\",{\"1\":{\"70\":1}}],[\"32\",{\"1\":{\"42\":1,\"46\":1,\"47\":1,\"49\":1,\"53\":1,\"58\":2,\"190\":1}}],[\"3f\",{\"1\":{\"37\":1,\"38\":1,\"39\":1,\"40\":1}}],[\"30mg\",{\"1\":{\"222\":1}}],[\"3014\",{\"1\":{\"171\":1,\"174\":1,\"175\":1}}],[\"30522\",{\"1\":{\"162\":1}}],[\"3072\",{\"1\":{\"162\":1}}],[\"3008个\",{\"1\":{\"59\":1}}],[\"30\",{\"1\":{\"6\":2,\"21\":1,\"223\":2,\"243\":1}}],[\"3\",{\"0\":{\"7\":1,\"8\":1,\"9\":1,\"15\":1,\"26\":1,\"39\":1,\"46\":1,\"57\":1,\"58\":1,\"59\":1,\"60\":2,\"61\":1,\"62\":1,\"63\":1,\"67\":1,\"71\":1,\"77\":1,\"89\":1,\"94\":1,\"97\":1,\"98\":1,\"99\":1,\"103\":1,\"113\":1,\"122\":1,\"127\":1,\"128\":1,\"129\":1,\"130\":1,\"131\":2,\"146\":1,\"147\":1,\"148\":1,\"149\":2,\"160\":1,\"166\":1,\"167\":1,\"168\":1,\"169\":1,\"170\":2,\"171\":1,\"172\":2,\"173\":2,\"174\":2,\"175\":1,\"176\":1,\"180\":1,\"186\":1,\"190\":1,\"194\":1,\"195\":1,\"196\":1,\"197\":1,\"198\":2,\"199\":1,\"200\":1,\"201\":2,\"202\":1,\"210\":1,\"212\":1,\"213\":1,\"214\":2,\"215\":1,\"224\":1,\"232\":1,\"239\":1,\"245\":1},\"1\":{\"2\":1,\"13\":1,\"16\":2,\"19\":6,\"21\":8,\"56\":1,\"61\":1,\"116\":3,\"117\":1,\"123\":1,\"160\":1,\"171\":2,\"172\":1,\"199\":2,\"202\":2,\"222\":1,\"232\":3,\"239\":2,\"241\":6}}],[\"29\",{\"1\":{\"162\":1}}],[\"2x2\",{\"1\":{\"159\":1}}],[\"2kn​\",{\"1\":{\"125\":2}}],[\"2×t\",{\"1\":{\"125\":2}}],[\"2n​\",{\"1\":{\"125\":2,\"126\":2}}],[\"2n1​\",{\"1\":{\"88\":1}}],[\"2n\",{\"1\":{\"85\":1,\"120\":2}}],[\"22\",{\"1\":{\"70\":2}}],[\"224\",{\"1\":{\"70\":1}}],[\"2443\",{\"1\":{\"171\":1,\"174\":1,\"175\":1}}],[\"240\",{\"1\":{\"70\":1,\"80\":1}}],[\"24\",{\"1\":{\"70\":3}}],[\"2个字节\",{\"1\":{\"66\":1}}],[\"2878\",{\"1\":{\"156\":1,\"178\":2,\"180\":4,\"181\":1,\"183\":2}}],[\"28\",{\"1\":{\"54\":1}}],[\"28=256\",{\"1\":{\"45\":1}}],[\"264−253+3\",{\"1\":{\"239\":1}}],[\"2607\",{\"1\":{\"156\":1,\"178\":2,\"180\":4,\"181\":1,\"183\":2}}],[\"26\",{\"1\":{\"53\":1}}],[\"2310\",{\"1\":{\"156\":1,\"178\":2,\"180\":4,\"181\":2,\"183\":2}}],[\"23\",{\"1\":{\"21\":2}}],[\"2034\",{\"1\":{\"189\":1}}],[\"2031\",{\"1\":{\"180\":4,\"181\":2}}],[\"2028\",{\"1\":{\"189\":1}}],[\"2023\",{\"1\":{\"156\":1,\"189\":2}}],[\"2026\",{\"1\":{\"156\":1,\"178\":2,\"180\":4,\"181\":1,\"183\":2}}],[\"2042\",{\"1\":{\"156\":1,\"178\":2,\"180\":4,\"181\":2,\"183\":2}}],[\"2048\",{\"1\":{\"65\":1}}],[\"2017\",{\"1\":{\"146\":1}}],[\"2061\",{\"1\":{\"156\":1,\"180\":4,\"181\":2}}],[\"206\",{\"1\":{\"106\":1}}],[\"2008\",{\"1\":{\"222\":1,\"239\":1}}],[\"2007\",{\"1\":{\"222\":1}}],[\"2006\",{\"1\":{\"222\":1}}],[\"2003\",{\"1\":{\"189\":2}}],[\"200\",{\"1\":{\"179\":20,\"180\":5}}],[\"2001\",{\"1\":{\"71\":1}}],[\"2005\",{\"1\":{\"61\":3,\"156\":1,\"178\":2,\"180\":4,\"181\":2,\"183\":2}}],[\"2000\",{\"1\":{\"61\":6,\"222\":1}}],[\"20\",{\"1\":{\"21\":2,\"192\":1}}],[\"27\",{\"1\":{\"21\":1,\"53\":1,\"70\":2}}],[\"2117\",{\"1\":{\"189\":1}}],[\"2172\",{\"1\":{\"156\":1}}],[\"21​\",{\"1\":{\"88\":1}}],[\"2163\",{\"1\":{\"179\":1}}],[\"2166\",{\"1\":{\"156\":1,\"178\":2,\"180\":4,\"181\":1,\"183\":2}}],[\"21600\",{\"1\":{\"80\":1}}],[\"216=65536\",{\"1\":{\"64\":1}}],[\"214\",{\"1\":{\"70\":1}}],[\"21003\",{\"1\":{\"60\":1}}],[\"21\",{\"1\":{\"19\":1,\"106\":1}}],[\"253−1\",{\"1\":{\"238\":1}}],[\"250\",{\"1\":{\"80\":1}}],[\"252\",{\"1\":{\"70\":1}}],[\"254\",{\"1\":{\"70\":1}}],[\"255\",{\"1\":{\"70\":26,\"75\":4,\"77\":4,\"80\":6}}],[\"256\",{\"1\":{\"54\":1,\"58\":1}}],[\"256位\",{\"1\":{\"42\":1}}],[\"25\",{\"1\":{\"16\":1}}],[\"2\",{\"0\":{\"3\":1,\"6\":1,\"9\":1,\"14\":1,\"21\":1,\"25\":1,\"29\":1,\"34\":1,\"38\":1,\"43\":1,\"44\":1,\"45\":2,\"46\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"53\":1,\"54\":1,\"55\":1,\"56\":2,\"59\":1,\"66\":1,\"70\":1,\"76\":1,\"88\":1,\"93\":1,\"96\":1,\"99\":1,\"102\":1,\"110\":1,\"121\":1,\"124\":1,\"125\":1,\"126\":2,\"127\":1,\"130\":1,\"143\":1,\"144\":1,\"145\":2,\"148\":1,\"152\":1,\"154\":1,\"157\":1,\"158\":1,\"159\":2,\"161\":1,\"162\":1,\"163\":1,\"164\":2,\"165\":2,\"169\":1,\"171\":1,\"174\":1,\"179\":1,\"184\":1,\"189\":1,\"191\":1,\"192\":1,\"193\":2,\"197\":1,\"200\":1,\"206\":1,\"207\":1,\"208\":1,\"209\":2,\"210\":1,\"211\":2,\"212\":1,\"213\":2,\"214\":1,\"220\":1,\"221\":1,\"222\":1,\"223\":2,\"224\":1,\"228\":1,\"238\":1,\"244\":1},\"1\":{\"2\":1,\"3\":2,\"13\":1,\"15\":1,\"19\":7,\"21\":16,\"49\":2,\"56\":1,\"58\":1,\"59\":2,\"70\":1,\"72\":4,\"85\":1,\"114\":8,\"116\":4,\"117\":3,\"125\":2,\"127\":1,\"133\":1,\"137\":1,\"139\":3,\"144\":1,\"150\":1,\"156\":2,\"157\":2,\"158\":1,\"159\":3,\"162\":1,\"165\":1,\"170\":1,\"178\":4,\"184\":1,\"187\":1,\"189\":1,\"193\":1,\"194\":1,\"197\":1,\"222\":1,\"229\":1,\"230\":2,\"232\":3,\"239\":2,\"243\":1}}],[\"但我们只传递来一个序列\",{\"1\":{\"178\":1}}],[\"但也因语言而异\",{\"1\":{\"169\":1}}],[\"但这种做法并不能完全解决问题\",{\"1\":{\"115\":1}}],[\"但采用的是单字节码元\",{\"1\":{\"58\":2}}],[\"但不包括生僻字\",{\"1\":{\"58\":1}}],[\"但不是\",{\"1\":{\"15\":1}}],[\"但实际上只有\",{\"1\":{\"56\":1}}],[\"但有时在一些通讯系统中也被用作奇偶校验位\",{\"1\":{\"53\":1}}],[\"但由于修改了数组本身\",{\"1\":{\"21\":1}}],[\"但是用\",{\"1\":{\"241\":1}}],[\"但是没它啥事\",{\"1\":{\"232\":1}}],[\"但是它没有办法处理\",{\"1\":{\"212\":1}}],[\"但是它不会告诉你这个模型表现得怎么样\",{\"1\":{\"192\":1}}],[\"但是它只涉及逻辑层面\",{\"1\":{\"46\":1}}],[\"但是也有一些不足\",{\"1\":{\"189\":1}}],[\"但是也不大可能出现每次分区点都选得很差的情况\",{\"1\":{\"133\":1}}],[\"但是我们需要传入句子对\",{\"1\":{\"189\":1}}],[\"但是模型看到了目标中的第4个单词\",{\"1\":{\"152\":1}}],[\"但是不允许它使用没有预测的词汇\",{\"1\":{\"152\":1}}],[\"但是不适用于数组\",{\"1\":{\"19\":1}}],[\"但是归并排序并没有快排那样应用广泛\",{\"1\":{\"125\":1}}],[\"但是从代码上看\",{\"1\":{\"123\":1}}],[\"但是插入排序更受欢迎\",{\"1\":{\"123\":1}}],[\"但是在计算\",{\"1\":{\"116\":1}}],[\"但是在没安装操作系统之前\",{\"1\":{\"80\":1}}],[\"但是可能会导致过多的请求排队等待\",{\"1\":{\"111\":1}}],[\"但是可以发送\",{\"1\":{\"80\":1}}],[\"但是锁粒度大并发度会比较低\",{\"1\":{\"110\":1}}],[\"但是能够支持双向遍历\",{\"1\":{\"94\":1}}],[\"但是抓包后可能看到的名称还是\",{\"1\":{\"75\":1}}],[\"但是无非就是\",{\"1\":{\"72\":1}}],[\"但是\",{\"1\":{\"72\":1,\"239\":1}}],[\"但是目的\",{\"1\":{\"72\":1}}],[\"但是配置的\",{\"1\":{\"72\":1}}],[\"但是通信范围比较小\",{\"1\":{\"71\":1}}],[\"但是要将一个网络包从一个地方传到另一个地方\",{\"1\":{\"71\":1}}],[\"但是这和它也没啥关系\",{\"1\":{\"232\":1}}],[\"但是这个代码页实际上并没有真正使用\",{\"1\":{\"61\":1}}],[\"但是这样的问题是\",{\"1\":{\"13\":1}}],[\"但是会给患者带来麻烦\",{\"1\":{\"40\":1}}],[\"但是返回的是元素的索引而不是元素本身\",{\"1\":{\"21\":1}}],[\"但是对于具体问题\",{\"1\":{\"147\":1}}],[\"但是对于\",{\"1\":{\"15\":1}}],[\"但\",{\"1\":{\"2\":1,\"60\":1}}],[\"变量名不能是保留字\",{\"1\":{\"2\":1}}],[\"full\",{\"1\":{\"216\":1}}],[\"func\",{\"1\":{\"21\":3}}],[\"functional\",{\"1\":{\"160\":1}}],[\"function\",{\"1\":{\"2\":1,\"13\":1,\"16\":1,\"21\":5,\"24\":1,\"28\":3,\"189\":2,\"190\":2,\"191\":2,\"194\":2,\"202\":2,\"222\":1}}],[\"f0f7783\",{\"1\":{\"214\":1}}],[\"folder>\",{\"1\":{\"213\":5,\"214\":2}}],[\"fortokenclassification\",{\"1\":{\"157\":1}}],[\"forsequenceclassification\",{\"1\":{\"157\":1}}],[\"forquestionanswering\",{\"1\":{\"157\":1}}],[\"forcausallm\",{\"1\":{\"157\":1}}],[\"formultiplechoice\",{\"1\":{\"157\":1}}],[\"formaskedlm\",{\"1\":{\"157\":1}}],[\"format\",{\"1\":{\"46\":1,\"47\":1,\"195\":1,\"218\":1}}],[\"form\",{\"0\":{\"46\":1}}],[\"forests\",{\"1\":{\"33\":1}}],[\"foreach\",{\"1\":{\"21\":1}}],[\"for\",{\"0\":{\"8\":1},\"1\":{\"2\":3,\"3\":1,\"4\":1,\"6\":2,\"8\":3,\"9\":2,\"11\":2,\"12\":5,\"13\":7,\"14\":4,\"17\":1,\"19\":6,\"20\":1,\"33\":1,\"34\":2,\"53\":1,\"87\":1,\"117\":1,\"120\":2,\"121\":2,\"122\":2,\"125\":1,\"126\":1,\"130\":6,\"144\":2,\"145\":2,\"156\":2,\"178\":3,\"180\":2,\"181\":2,\"183\":3,\"184\":1,\"190\":3,\"196\":2,\"200\":3,\"201\":2,\"202\":5,\"214\":1,\"215\":1,\"222\":6}}],[\"feet\",{\"1\":{\"222\":2}}],[\"feel\",{\"1\":{\"222\":2}}],[\"feels\",{\"1\":{\"151\":2}}],[\"felt\",{\"1\":{\"222\":1}}],[\"features\",{\"0\":{\"158\":1},\"1\":{\"34\":1,\"188\":5,\"189\":3,\"219\":3}}],[\"f\",{\"1\":{\"85\":2,\"114\":6,\"115\":2,\"116\":12,\"117\":1,\"239\":3}}],[\"flag\",{\"1\":{\"120\":3,\"123\":1}}],[\"flags\",{\"1\":{\"71\":1}}],[\"flatmap\",{\"1\":{\"21\":1}}],[\"flat\",{\"1\":{\"21\":1}}],[\"ffff\",{\"1\":{\"239\":6}}],[\"ff\",{\"1\":{\"71\":6}}],[\"fp16=true\",{\"1\":{\"193\":1}}],[\"fp\",{\"1\":{\"36\":1,\"40\":5}}],[\"f1−score=precision+recall2×precision×recall​\",{\"1\":{\"40\":1}}],[\"f1\",{\"0\":{\"40\":2},\"1\":{\"36\":1,\"40\":3,\"193\":2,\"201\":1}}],[\"fail\",{\"1\":{\"178\":1}}],[\"fast\",{\"1\":{\"71\":1}}],[\"fa\",{\"1\":{\"71\":1}}],[\"face\",{\"0\":{\"218\":1},\"1\":{\"30\":1,\"204\":1,\"208\":1,\"211\":1,\"216\":1,\"217\":1,\"222\":2}}],[\"false\",{\"1\":{\"5\":1,\"13\":2,\"20\":1,\"36\":2,\"40\":2,\"120\":1,\"241\":1}}],[\"fn=data\",{\"1\":{\"196\":2}}],[\"fn=<nlllossbackward0>\",{\"1\":{\"197\":1}}],[\"fn=<addmmbackward0>\",{\"1\":{\"178\":1,\"179\":3,\"180\":1}}],[\"fn=<addmmbackward>\",{\"1\":{\"160\":1}}],[\"fn=<softmaxbackward0>\",{\"1\":{\"160\":1}}],[\"fn\",{\"1\":{\"21\":4,\"36\":1,\"40\":4}}],[\"field=\",{\"1\":{\"219\":3,\"220\":1}}],[\"first\",{\"1\":{\"189\":3,\"214\":1}}],[\"finger\",{\"1\":{\"222\":1}}],[\"finetuned\",{\"1\":{\"156\":2,\"157\":2,\"159\":1,\"178\":2,\"184\":1,\"208\":2}}],[\"fine\",{\"1\":{\"147\":1,\"149\":1,\"186\":1,\"214\":1,\"217\":1}}],[\"findlastindex\",{\"1\":{\"21\":1}}],[\"findindex\",{\"1\":{\"21\":1}}],[\"find\",{\"1\":{\"21\":4,\"87\":1,\"103\":2}}],[\"file>\",{\"1\":{\"212\":1}}],[\"file\",{\"0\":{\"212\":1},\"1\":{\"209\":2,\"211\":1,\"212\":3,\"213\":1,\"214\":6,\"218\":3}}],[\"files=data\",{\"1\":{\"219\":2,\"220\":1,\"222\":1}}],[\"files=\",{\"1\":{\"218\":4,\"219\":2}}],[\"files\",{\"0\":{\"211\":1},\"1\":{\"209\":1,\"211\":1,\"213\":3,\"218\":1,\"219\":5,\"220\":3,\"222\":2}}],[\"filename\",{\"1\":{\"80\":2}}],[\"fill\",{\"1\":{\"21\":1,\"145\":1}}],[\"filter\",{\"1\":{\"21\":5,\"222\":2,\"223\":2}}],[\"front\",{\"0\":{\"256\":1}}],[\"from=\",{\"1\":{\"213\":1}}],[\"from\",{\"0\":{\"16\":1},\"1\":{\"12\":1,\"13\":4,\"16\":6,\"17\":1,\"21\":3,\"27\":1,\"28\":2,\"29\":8,\"37\":1,\"38\":1,\"39\":1,\"40\":1,\"144\":2,\"145\":1,\"156\":4,\"157\":3,\"159\":2,\"162\":1,\"163\":5,\"171\":5,\"172\":1,\"173\":2,\"178\":6,\"179\":1,\"184\":3,\"188\":1,\"189\":2,\"190\":1,\"191\":3,\"192\":4,\"193\":1,\"194\":3,\"196\":1,\"197\":2,\"198\":1,\"199\":1,\"200\":1,\"202\":7,\"208\":4,\"209\":2,\"212\":1,\"213\":1,\"214\":3,\"219\":1,\"222\":5}}],[\"fr\",{\"1\":{\"216\":1}}],[\"fruit\",{\"1\":{\"19\":2}}],[\"fruits\",{\"1\":{\"19\":23}}],[\"ai\",{\"0\":{\"248\":1}}],[\"after\",{\"1\":{\"222\":1}}],[\"ago\",{\"1\":{\"222\":1}}],[\"again\",{\"1\":{\"222\":1}}],[\"age\",{\"1\":{\"2\":6,\"6\":4,\"21\":8}}],[\"about\",{\"1\":{\"209\":1,\"222\":1}}],[\"abs\",{\"1\":{\"239\":1}}],[\"absolute\",{\"1\":{\"162\":1}}],[\"abstract\",{\"0\":{\"44\":1}}],[\"adam\",{\"1\":{\"198\":1}}],[\"adamw\",{\"1\":{\"198\":3,\"202\":4}}],[\"add\",{\"1\":{\"201\":2,\"213\":3,\"214\":1,\"223\":2}}],[\"addr\",{\"0\":{\"71\":1},\"1\":{\"71\":2}}],[\"additive\",{\"1\":{\"33\":2}}],[\"axis=\",{\"1\":{\"193\":2}}],[\"apache\",{\"1\":{\"217\":1}}],[\"api\",{\"0\":{\"182\":1,\"191\":1,\"208\":1},\"1\":{\"153\":1,\"154\":2,\"186\":1,\"204\":1,\"206\":1,\"208\":1}}],[\"apply\",{\"1\":{\"222\":1}}],[\"apples\",{\"1\":{\"151\":2}}],[\"apple\",{\"1\":{\"15\":1,\"19\":9}}],[\"approaches\",{\"1\":{\"33\":1}}],[\"automodelformaskedlm\",{\"1\":{\"208\":2,\"214\":2}}],[\"automodelforsequenceclassification\",{\"1\":{\"159\":3,\"178\":4,\"179\":1,\"184\":2,\"192\":2,\"193\":1,\"197\":2,\"202\":4}}],[\"automodel\",{\"1\":{\"157\":3,\"159\":1,\"161\":1,\"163\":3}}],[\"autotokenizer\",{\"1\":{\"156\":4,\"157\":1,\"171\":3,\"173\":2,\"178\":4,\"184\":2,\"189\":2,\"191\":2,\"194\":2,\"208\":2,\"214\":2}}],[\"auto\",{\"1\":{\"146\":2,\"150\":2,\"200\":1}}],[\"auth\",{\"1\":{\"29\":2,\"208\":1}}],[\"amount\",{\"1\":{\"222\":1}}],[\"amortized\",{\"0\":{\"89\":1}}],[\"am\",{\"1\":{\"222\":1}}],[\"amrozi\",{\"1\":{\"188\":2}}],[\"american\",{\"1\":{\"53\":2}}],[\"avoid\",{\"1\":{\"222\":1}}],[\"average\",{\"0\":{\"88\":1}}],[\"available\",{\"1\":{\"34\":1,\"200\":1,\"202\":1}}],[\"a类地址\",{\"1\":{\"70\":1}}],[\"aˋ\",{\"1\":{\"45\":1}}],[\"ached\",{\"1\":{\"222\":1}}],[\"acne\",{\"1\":{\"222\":1}}],[\"active\",{\"1\":{\"222\":1}}],[\"act\",{\"1\":{\"162\":1}}],[\"ack\",{\"0\":{\"78\":1},\"1\":{\"78\":1,\"79\":1}}],[\"acr\",{\"0\":{\"44\":1},\"1\":{\"45\":1}}],[\"access\",{\"0\":{\"229\":1}}],[\"accelerator\",{\"1\":{\"202\":11}}],[\"accelerate\",{\"0\":{\"202\":1},\"1\":{\"30\":1,\"186\":1,\"192\":4,\"202\":8,\"203\":1}}],[\"accused\",{\"1\":{\"188\":2}}],[\"accuracy=tp+tn+fp+fntp+tn​\",{\"1\":{\"37\":1}}],[\"accuracy\",{\"0\":{\"37\":1},\"1\":{\"36\":1,\"37\":3,\"193\":2,\"201\":1}}],[\"accumulator\",{\"1\":{\"21\":2}}],[\"a∈rk×s\",{\"1\":{\"34\":1}}],[\"a∈rk\",{\"1\":{\"34\":1}}],[\"a∈r\",{\"1\":{\"34\":1}}],[\"assertionerror\",{\"1\":{\"222\":1}}],[\"assert\",{\"1\":{\"222\":1}}],[\"assign\",{\"1\":{\"6\":2,\"11\":1}}],[\"ascii字符\",{\"1\":{\"62\":1}}],[\"ascii字符编码方案简介\",{\"0\":{\"53\":1}}],[\"ascii\",{\"0\":{\"51\":1},\"1\":{\"42\":1,\"46\":1,\"48\":1,\"53\":2,\"54\":3,\"55\":2,\"56\":2,\"58\":6,\"59\":3,\"66\":4}}],[\"as\",{\"0\":{\"26\":1},\"1\":{\"29\":2,\"145\":2,\"188\":1,\"193\":1}}],[\"a\",{\"1\":{\"21\":2,\"33\":1,\"34\":2,\"45\":1,\"61\":1,\"67\":1,\"103\":14,\"120\":7,\"121\":6,\"122\":7,\"123\":9,\"125\":4,\"126\":2,\"127\":1,\"130\":13,\"139\":2,\"144\":2,\"145\":2,\"151\":1,\"156\":2,\"168\":2,\"171\":1,\"173\":2,\"175\":1,\"178\":3,\"180\":1,\"181\":1,\"183\":3,\"184\":1,\"208\":1,\"222\":3,\"223\":2,\"224\":1,\"231\":4,\"232\":2,\"237\":1,\"238\":1}}],[\"architecture\",{\"1\":{\"142\":4,\"171\":1}}],[\"architectures\",{\"0\":{\"142\":1},\"1\":{\"142\":1}}],[\"arp\",{\"0\":{\"230\":1},\"1\":{\"72\":1,\"229\":1,\"230\":7,\"232\":3,\"233\":1}}],[\"area\",{\"1\":{\"65\":1,\"222\":2}}],[\"are\",{\"1\":{\"34\":1,\"181\":2}}],[\"army\",{\"1\":{\"21\":9}}],[\"argmax\",{\"1\":{\"193\":2,\"201\":1}}],[\"args\",{\"1\":{\"192\":3,\"193\":2,\"208\":1}}],[\"arg2\",{\"1\":{\"21\":1}}],[\"arg1\",{\"1\":{\"21\":1}}],[\"arrow\",{\"1\":{\"217\":1}}],[\"arrlength\",{\"1\":{\"21\":1}}],[\"arr\",{\"1\":{\"16\":2,\"19\":10,\"21\":42,\"125\":16,\"126\":13,\"127\":6}}],[\"arrays\",{\"1\":{\"178\":1}}],[\"arrayblockingqueue\",{\"1\":{\"108\":1}}],[\"arraylike\",{\"1\":{\"15\":2,\"21\":4}}],[\"array\",{\"0\":{\"15\":1,\"16\":1,\"18\":1},\"1\":{\"12\":3,\"15\":7,\"16\":8,\"17\":3,\"19\":1,\"21\":8,\"87\":3}}],[\"attribute\",{\"1\":{\"222\":1}}],[\"attributeerror\",{\"1\":{\"222\":1}}],[\"attack\",{\"1\":{\"222\":1}}],[\"attention\",{\"0\":{\"151\":1,\"180\":1},\"1\":{\"152\":1,\"156\":1,\"162\":2,\"171\":2,\"179\":3,\"180\":10,\"181\":2,\"185\":1,\"189\":5,\"190\":1,\"195\":1,\"196\":1}}],[\"at\",{\"1\":{\"19\":2,\"222\":1}}],[\"ankles\",{\"1\":{\"222\":1}}],[\"anxiety\",{\"1\":{\"222\":5}}],[\"annoy\",{\"1\":{\"170\":1}}],[\"annoyingly\",{\"1\":{\"170\":1}}],[\"ansi\",{\"1\":{\"54\":1}}],[\"and\",{\"0\":{\"222\":1},\"1\":{\"33\":3,\"110\":1,\"157\":1,\"209\":2,\"213\":1,\"215\":1,\"222\":20}}],[\"analysis\",{\"1\":{\"33\":3,\"144\":2,\"156\":3}}],[\"an\",{\"1\":{\"31\":1,\"222\":2}}],[\"any\",{\"1\":{\"12\":1,\"13\":1,\"17\":1}}],[\"another\",{\"1\":{\"6\":1}}],[\"alot\",{\"1\":{\"222\":1}}],[\"also\",{\"1\":{\"222\":1}}],[\"all\",{\"1\":{\"222\":1}}],[\"allergies\",{\"1\":{\"222\":1}}],[\"allergy\",{\"1\":{\"222\":1}}],[\"allow\",{\"1\":{\"80\":2}}],[\"albert\",{\"1\":{\"150\":1}}],[\"alter\",{\"1\":{\"2\":2}}],[\"alert\",{\"1\":{\"2\":6,\"3\":4,\"6\":2,\"8\":1,\"9\":3,\"14\":3,\"16\":1,\"19\":20,\"21\":11,\"28\":2,\"245\":1}}],[\"lh\",{\"1\":{\"214\":1}}],[\"lfs\",{\"1\":{\"206\":1,\"211\":1,\"212\":1,\"213\":2,\"214\":10}}],[\"lf换行\",{\"1\":{\"53\":1}}],[\"lr=3e\",{\"1\":{\"202\":2}}],[\"lr=5e\",{\"1\":{\"198\":1}}],[\"lr\",{\"1\":{\"199\":1,\"200\":1,\"202\":4}}],[\"lru\",{\"0\":{\"98\":1},\"1\":{\"98\":1}}],[\"ly\",{\"1\":{\"170\":1}}],[\"ls\",{\"1\":{\"164\":1,\"214\":2}}],[\"l+i\",{\"1\":{\"125\":1}}],[\"l+1\",{\"1\":{\"125\":2}}],[\"l\",{\"1\":{\"125\":7,\"126\":10}}],[\"l1\",{\"1\":{\"71\":1}}],[\"lan\",{\"1\":{\"232\":3}}],[\"languages\",{\"1\":{\"216\":1}}],[\"language\",{\"0\":{\"147\":1},\"1\":{\"216\":1}}],[\"lambda\",{\"1\":{\"222\":1,\"223\":2}}],[\"large\",{\"1\":{\"211\":1,\"213\":1}}],[\"launcher\",{\"1\":{\"202\":2}}],[\"launch\",{\"1\":{\"202\":1}}],[\"layer\",{\"1\":{\"162\":1,\"179\":1,\"222\":1}}],[\"layers\",{\"0\":{\"151\":1},\"1\":{\"157\":1,\"162\":1,\"179\":1,\"180\":1}}],[\"lawyer\",{\"1\":{\"145\":1}}],[\"labels=2\",{\"1\":{\"192\":1,\"193\":1,\"197\":1,\"202\":2}}],[\"labels\",{\"1\":{\"190\":1,\"193\":1,\"195\":3,\"196\":1,\"201\":1}}],[\"label\",{\"1\":{\"144\":3,\"160\":1,\"188\":7,\"189\":3,\"193\":3,\"195\":2}}],[\"latin\",{\"1\":{\"56\":1}}],[\"lasso\",{\"1\":{\"33\":1}}],[\"lastindexof\",{\"1\":{\"21\":1}}],[\"last\",{\"1\":{\"13\":2,\"158\":1}}],[\"lzw\",{\"1\":{\"48\":1}}],[\"license\",{\"1\":{\"216\":1}}],[\"libraries\",{\"1\":{\"216\":1}}],[\"limitations\",{\"1\":{\"215\":2}}],[\"life\",{\"1\":{\"144\":2,\"156\":2,\"178\":3,\"180\":1,\"181\":1,\"183\":3,\"184\":1,\"222\":2}}],[\"link\",{\"1\":{\"71\":1}}],[\"linux\",{\"1\":{\"71\":4,\"72\":3,\"81\":1,\"108\":1}}],[\"lines\",{\"1\":{\"218\":1}}],[\"line\",{\"1\":{\"178\":1}}],[\"liner\",{\"1\":{\"33\":1}}],[\"linear\",{\"1\":{\"33\":7,\"199\":1,\"202\":2}}],[\"list\",{\"1\":{\"12\":1,\"165\":1,\"209\":4,\"219\":1,\"223\":1}}],[\"like\",{\"0\":{\"15\":1},\"1\":{\"12\":1,\"15\":3,\"17\":1,\"146\":3,\"151\":3,\"222\":1}}],[\"likes\",{\"1\":{\"2\":2,\"15\":2,\"16\":1}}],[\"legs\",{\"1\":{\"222\":3}}],[\"lexapro\",{\"1\":{\"222\":2}}],[\"len\",{\"1\":{\"190\":1,\"199\":1,\"202\":2,\"222\":2,\"223\":1}}],[\"length=8\",{\"1\":{\"180\":1,\"181\":1}}],[\"length=30\",{\"1\":{\"144\":1}}],[\"length\",{\"1\":{\"12\":1,\"15\":2,\"17\":1,\"19\":6,\"21\":3,\"34\":2,\"158\":1,\"180\":5,\"181\":3,\"202\":1,\"223\":6,\"238\":1}}],[\"led\",{\"1\":{\"181\":1}}],[\"levels\",{\"1\":{\"222\":1}}],[\"level\",{\"1\":{\"170\":1,\"186\":1}}],[\"leave\",{\"1\":{\"222\":1}}],[\"least\",{\"1\":{\"98\":1}}],[\"lease\",{\"1\":{\"33\":1,\"80\":2}}],[\"learning\",{\"0\":{\"149\":1,\"199\":1},\"1\":{\"31\":1,\"33\":3,\"147\":1,\"199\":1}}],[\"lemon\",{\"1\":{\"19\":2}}],[\"let\",{\"1\":{\"2\":8,\"3\":2,\"5\":4,\"6\":10,\"8\":2,\"9\":3,\"13\":3,\"14\":5,\"15\":1,\"16\":2,\"19\":10,\"21\":11,\"222\":1,\"244\":1}}],[\"loop\",{\"0\":{\"200\":1,\"201\":1},\"1\":{\"195\":1,\"201\":1,\"203\":1}}],[\"loopback\",{\"1\":{\"71\":1}}],[\"loss\",{\"1\":{\"192\":2,\"193\":2,\"197\":1,\"200\":3,\"202\":7}}],[\"load\",{\"1\":{\"188\":2,\"191\":2,\"193\":3,\"194\":2,\"201\":1,\"218\":4,\"219\":4,\"220\":1,\"222\":2}}],[\"loading\",{\"1\":{\"25\":1,\"218\":1,\"219\":1}}],[\"longer\",{\"1\":{\"181\":2}}],[\"longest\",{\"1\":{\"180\":1}}],[\"longformer\",{\"1\":{\"181\":1}}],[\"lowercase\",{\"1\":{\"222\":2}}],[\"lower\",{\"1\":{\"71\":2,\"222\":3}}],[\"lo\",{\"1\":{\"71\":2}}],[\"local\",{\"1\":{\"9\":3}}],[\"logout\",{\"1\":{\"209\":1}}],[\"login\",{\"1\":{\"209\":2}}],[\"logits\",{\"1\":{\"159\":1,\"160\":3,\"178\":1,\"179\":3,\"180\":1,\"193\":4,\"197\":1,\"201\":3}}],[\"logistic\",{\"1\":{\"33\":1}}],[\"logn\",{\"1\":{\"85\":2}}],[\"log\",{\"1\":{\"5\":3,\"129\":1,\"244\":2,\"245\":1}}],[\"nthe\",{\"1\":{\"222\":1}}],[\"np\",{\"1\":{\"178\":1,\"193\":3}}],[\"night\",{\"1\":{\"222\":1}}],[\"ni\",{\"1\":{\"222\":1}}],[\"nice\",{\"1\":{\"165\":1}}],[\"nibble\",{\"1\":{\"42\":1}}],[\"nn\",{\"1\":{\"160\":1}}],[\"n>1时\",{\"1\":{\"125\":1}}],[\"n次冒泡\",{\"1\":{\"120\":1}}],[\"n−2\",{\"1\":{\"114\":1}}],[\"n−1\",{\"1\":{\"114\":1,\"120\":4}}],[\"n+k\",{\"1\":{\"132\":1}}],[\"n+2n​+4n​+8n​+\",{\"1\":{\"127\":1}}],[\"n+3\",{\"1\":{\"88\":1}}],[\"n+11+2+3+\",{\"1\":{\"88\":1}}],[\"n+1\",{\"1\":{\"88\":3}}],[\"nk\",{\"1\":{\"85\":1}}],[\"n3\",{\"1\":{\"85\":1}}],[\"n2\",{\"1\":{\"85\":2,\"118\":1,\"120\":4,\"121\":3,\"122\":2,\"123\":8,\"125\":1,\"126\":3,\"132\":4,\"133\":1}}],[\"nlisten\",{\"1\":{\"222\":1}}],[\"nlogn\",{\"1\":{\"85\":2,\"118\":1,\"125\":2,\"126\":4,\"129\":1,\"132\":3}}],[\"nlp\",{\"0\":{\"141\":1},\"1\":{\"30\":1,\"141\":2,\"153\":2,\"204\":1}}],[\"n=1时\",{\"1\":{\"125\":1}}],[\"n=1\",{\"1\":{\"56\":1}}],[\"n×p\",{\"1\":{\"34\":1}}],[\"n\",{\"1\":{\"34\":3,\"45\":2,\"56\":1,\"82\":1,\"85\":9,\"87\":3,\"88\":3,\"92\":1,\"103\":15,\"106\":1,\"108\":1,\"114\":11,\"115\":3,\"116\":8,\"117\":4,\"118\":1,\"120\":5,\"121\":6,\"122\":4,\"123\":2,\"125\":8,\"126\":6,\"127\":6,\"129\":4,\"130\":9,\"131\":2,\"132\":1,\"222\":4,\"230\":1}}],[\"norm\",{\"1\":{\"162\":1}}],[\"node\",{\"1\":{\"103\":3}}],[\"no\",{\"1\":{\"47\":1,\"201\":1,\"222\":2}}],[\"nonetype\",{\"1\":{\"222\":1}}],[\"none\",{\"1\":{\"222\":3}}],[\"non\",{\"1\":{\"33\":4}}],[\"notebook\",{\"1\":{\"202\":3}}],[\"notation\",{\"0\":{\"34\":1},\"1\":{\"32\":1}}],[\"not\",{\"1\":{\"6\":1,\"188\":2,\"190\":1,\"214\":1,\"222\":3}}],[\"nasty\",{\"1\":{\"222\":1}}],[\"national\",{\"1\":{\"53\":1}}],[\"nan\",{\"1\":{\"21\":1,\"239\":3}}],[\"name=\",{\"1\":{\"222\":2}}],[\"names\",{\"1\":{\"195\":1}}],[\"names=\",{\"1\":{\"188\":1}}],[\"name对应的\",{\"1\":{\"49\":1}}],[\"named\",{\"1\":{\"28\":1,\"29\":2}}],[\"name\",{\"1\":{\"2\":4,\"4\":3,\"6\":5,\"9\":4,\"11\":3,\"28\":4,\"208\":2,\"214\":1}}],[\"nurse\",{\"1\":{\"145\":1}}],[\"nul空\",{\"1\":{\"53\":1}}],[\"null\",{\"0\":{\"237\":1},\"1\":{\"20\":1,\"92\":1,\"103\":5,\"162\":1,\"236\":1}}],[\"numpy\",{\"1\":{\"178\":1,\"193\":1,\"223\":1}}],[\"numerical\",{\"1\":{\"33\":1}}],[\"num\",{\"0\":{\"244\":1},\"1\":{\"13\":2,\"16\":3,\"144\":1,\"162\":2,\"188\":3,\"189\":4,\"192\":1,\"193\":1,\"197\":1,\"199\":6,\"200\":1,\"202\":16,\"219\":3,\"223\":1}}],[\"numbertostring\",{\"0\":{\"244\":1}}],[\"number\",{\"0\":{\"239\":1,\"243\":1},\"1\":{\"3\":4,\"34\":2,\"200\":1,\"236\":1,\"239\":4,\"241\":6,\"244\":1}}],[\"netmask\",{\"1\":{\"80\":1}}],[\"netlink\",{\"1\":{\"71\":1}}],[\"net\",{\"1\":{\"71\":7}}],[\"network\",{\"1\":{\"33\":1,\"157\":2,\"171\":1,\"173\":2,\"175\":1}}],[\"negative\",{\"1\":{\"36\":2,\"40\":2,\"144\":1,\"159\":1,\"160\":3}}],[\"neighbor\",{\"1\":{\"33\":1}}],[\"nearest\",{\"1\":{\"33\":1}}],[\"neural\",{\"1\":{\"33\":1}}],[\"next\",{\"1\":{\"12\":2,\"13\":7,\"14\":1,\"17\":2,\"80\":2,\"94\":1,\"103\":7}}],[\"new\",{\"1\":{\"2\":1,\"19\":1,\"27\":1,\"103\":3,\"125\":1,\"130\":2,\"214\":6,\"222\":2,\"241\":5}}],[\"=nlogmn​\",{\"1\":{\"129\":1}}],[\"=cn+nlog2​n\",{\"1\":{\"125\":1}}],[\"=t\",{\"1\":{\"125\":2}}],[\"=2k×t\",{\"1\":{\"125\":1}}],[\"=2×\",{\"1\":{\"125\":1}}],[\"=2×t\",{\"1\":{\"125\":1,\"126\":1}}],[\"=2\",{\"1\":{\"114\":1}}],[\"=1\",{\"1\":{\"114\":1}}],[\"=f\",{\"1\":{\"114\":1}}],[\"=o\",{\"1\":{\"85\":1}}],[\"=>\",{\"1\":{\"16\":1,\"21\":2}}],[\"===\",{\"1\":{\"8\":1,\"19\":1,\"21\":1,\"241\":1,\"242\":1}}],[\"==\",{\"0\":{\"20\":1},\"1\":{\"5\":1,\"20\":5,\"87\":1,\"103\":7,\"108\":2,\"114\":2,\"115\":1,\"116\":2,\"117\":2,\"127\":1,\"222\":1,\"241\":1,\"242\":2}}],[\"=\",{\"1\":{\"2\":9,\"3\":1,\"5\":4,\"6\":10,\"8\":2,\"9\":3,\"13\":6,\"14\":4,\"15\":1,\"16\":2,\"19\":11,\"21\":11,\"28\":1,\"70\":1,\"85\":2,\"87\":3,\"103\":11,\"115\":1,\"116\":3,\"117\":7,\"120\":7,\"121\":5,\"122\":8,\"123\":5,\"125\":11,\"126\":5,\"129\":1,\"130\":15,\"144\":2,\"145\":3,\"156\":5,\"157\":2,\"158\":1,\"159\":3,\"160\":1,\"162\":2,\"163\":2,\"165\":4,\"168\":1,\"171\":2,\"173\":3,\"174\":1,\"175\":1,\"178\":21,\"179\":7,\"180\":7,\"181\":4,\"183\":4,\"184\":6,\"188\":2,\"189\":7,\"190\":4,\"191\":5,\"192\":3,\"193\":9,\"194\":5,\"195\":2,\"196\":2,\"197\":2,\"198\":1,\"199\":3,\"200\":5,\"201\":5,\"202\":22,\"208\":4,\"213\":1,\"214\":3,\"219\":5,\"220\":3,\"222\":5,\"223\":4,\"239\":3,\"244\":1}}],[\"创建新列\",{\"0\":{\"223\":1}}],[\"创建新数组\",{\"1\":{\"21\":1}}],[\"创建仓库\",{\"1\":{\"209\":1}}],[\"创建模型仓库\",{\"0\":{\"207\":1}}],[\"创建模型仓库的三种方法\",{\"1\":{\"206\":1}}],[\"创建好仓库后\",{\"1\":{\"206\":1}}],[\"创建分类器对象\",{\"1\":{\"144\":1}}],[\"创建一个能够用不同方式来编码的通用字符集\",{\"1\":{\"42\":1}}],[\"创建\",{\"0\":{\"162\":1},\"1\":{\"2\":1,\"4\":1,\"11\":1,\"156\":1}}],[\"1445\",{\"1\":{\"223\":1}}],[\"1444\",{\"1\":{\"222\":1}}],[\"1468\",{\"1\":{\"222\":1}}],[\"141\",{\"1\":{\"106\":1}}],[\"1377\",{\"1\":{\"199\":1}}],[\"1`\",{\"1\":{\"192\":1}}],[\"1e+25\",{\"1\":{\"244\":1}}],[\"1e3\",{\"1\":{\"243\":1}}],[\"1e\",{\"1\":{\"162\":1,\"243\":1}}],[\"1×2n1​+2×2n1​+3×2n1​+\",{\"1\":{\"88\":1}}],[\"1字符集\",{\"1\":{\"67\":1}}],[\"1个字符\",{\"1\":{\"66\":1}}],[\"170\",{\"1\":{\"171\":1,\"174\":1,\"175\":1}}],[\"17662\",{\"1\":{\"156\":1,\"178\":2,\"180\":4,\"181\":1,\"183\":2}}],[\"1725\",{\"1\":{\"188\":1,\"189\":1}}],[\"172\",{\"1\":{\"70\":1}}],[\"17\",{\"1\":{\"61\":1}}],[\"125\",{\"1\":{\"222\":1}}],[\"125mcg\",{\"1\":{\"222\":1}}],[\"1200\",{\"1\":{\"171\":1,\"174\":1,\"175\":1}}],[\"12172\",{\"1\":{\"156\":1,\"178\":2,\"180\":4,\"181\":1,\"183\":2}}],[\"12\",{\"1\":{\"56\":1,\"162\":3}}],[\"127\",{\"1\":{\"53\":1,\"59\":2,\"60\":1,\"71\":1}}],[\"128\",{\"1\":{\"53\":1,\"54\":2,\"70\":2}}],[\"123\",{\"1\":{\"6\":5}}],[\"1996\",{\"1\":{\"189\":2}}],[\"1998\",{\"1\":{\"45\":1}}],[\"19\",{\"1\":{\"106\":1}}],[\"192\",{\"1\":{\"70\":2,\"72\":7,\"80\":5}}],[\"1980\",{\"1\":{\"60\":1}}],[\"1972\",{\"1\":{\"53\":1}}],[\"1964年\",{\"1\":{\"52\":1}}],[\"1是一个8比特的编号空间\",{\"1\":{\"45\":1}}],[\"1的编号空间是256\",{\"1\":{\"45\":1}}],[\"18437736874454810627\",{\"1\":{\"239\":1}}],[\"180\",{\"1\":{\"80\":1}}],[\"18000\",{\"1\":{\"80\":1}}],[\"1894个\",{\"1\":{\"60\":1}}],[\"18\",{\"1\":{\"21\":1}}],[\"1500\",{\"1\":{\"71\":3,\"229\":1}}],[\"152\",{\"1\":{\"70\":1}}],[\"15个非汉字及80个汉字\",{\"1\":{\"60\":1}}],[\"15\",{\"1\":{\"21\":4,\"56\":4,\"65\":1,\"222\":1}}],[\"11303\",{\"1\":{\"171\":1,\"174\":1,\"175\":1}}],[\"1111\",{\"1\":{\"70\":1}}],[\"1110\",{\"1\":{\"70\":1,\"171\":1,\"174\":1,\"175\":1}}],[\"110\",{\"1\":{\"70\":1}}],[\"11\",{\"1\":{\"19\":1,\"239\":2}}],[\"1692\",{\"1\":{\"160\":1}}],[\"168\",{\"1\":{\"70\":2,\"72\":5,\"80\":5}}],[\"160~255\",{\"1\":{\"56\":1}}],[\"16\",{\"0\":{\"66\":1},\"1\":{\"16\":1,\"21\":1,\"46\":1,\"47\":1,\"49\":1,\"56\":1,\"58\":2,\"65\":2,\"66\":6,\"70\":6,\"71\":1,\"158\":1,\"238\":2}}],[\"1024\",{\"1\":{\"181\":1}}],[\"102\",{\"1\":{\"156\":2,\"165\":3,\"171\":1,\"178\":1,\"180\":8,\"181\":4,\"183\":1,\"189\":2}}],[\"1037\",{\"1\":{\"156\":1,\"178\":2,\"180\":4,\"181\":1,\"183\":2}}],[\"1045\",{\"1\":{\"156\":2,\"178\":2,\"180\":8,\"181\":4,\"183\":2}}],[\"1012\",{\"1\":{\"156\":1,\"165\":1,\"178\":2,\"180\":4,\"181\":1,\"183\":2,\"189\":2}}],[\"101\",{\"1\":{\"156\":2,\"165\":3,\"171\":1,\"178\":1,\"180\":8,\"181\":4,\"183\":1,\"189\":1}}],[\"1005\",{\"1\":{\"156\":1,\"178\":2,\"180\":4,\"181\":2,\"183\":2}}],[\"10000000000000000\",{\"1\":{\"244\":2}}],[\"1000\",{\"1\":{\"71\":1,\"115\":1,\"222\":3,\"224\":1}}],[\"1001\",{\"1\":{\"45\":1}}],[\"100\",{\"1\":{\"19\":1,\"179\":1}}],[\"10\",{\"1\":{\"2\":1,\"19\":1,\"70\":6,\"115\":1,\"187\":1,\"193\":1,\"222\":1}}],[\"1\",{\"0\":{\"2\":1,\"5\":1,\"8\":1,\"13\":1,\"19\":1,\"24\":1,\"33\":1,\"37\":1,\"41\":1,\"42\":1,\"44\":1,\"51\":1,\"52\":2,\"53\":1,\"55\":1,\"58\":1,\"64\":1,\"65\":2,\"66\":1,\"67\":1,\"69\":1,\"75\":1,\"87\":1,\"91\":1,\"92\":2,\"93\":1,\"94\":1,\"95\":1,\"98\":1,\"101\":1,\"109\":1,\"119\":1,\"120\":2,\"121\":1,\"122\":1,\"123\":1,\"125\":1,\"129\":1,\"140\":1,\"141\":1,\"142\":2,\"144\":1,\"147\":1,\"151\":1,\"155\":1,\"156\":2,\"157\":1,\"158\":2,\"159\":1,\"160\":1,\"162\":1,\"163\":2,\"164\":1,\"167\":1,\"168\":2,\"169\":1,\"170\":1,\"173\":1,\"178\":1,\"183\":1,\"187\":1,\"188\":2,\"189\":1,\"190\":1,\"192\":1,\"195\":1,\"196\":2,\"197\":1,\"198\":1,\"199\":1,\"205\":1,\"207\":1,\"208\":2,\"209\":1,\"210\":1,\"212\":1,\"218\":1,\"219\":2,\"220\":1,\"222\":1,\"226\":1,\"227\":2,\"228\":1,\"232\":1,\"237\":1,\"243\":1},\"1\":{\"2\":1,\"3\":4,\"13\":4,\"15\":1,\"16\":3,\"19\":14,\"21\":19,\"45\":2,\"55\":1,\"56\":2,\"58\":2,\"59\":1,\"67\":1,\"71\":1,\"72\":5,\"80\":6,\"82\":1,\"85\":3,\"87\":3,\"92\":1,\"94\":1,\"103\":12,\"108\":1,\"114\":8,\"115\":4,\"116\":3,\"117\":3,\"118\":1,\"120\":2,\"121\":3,\"122\":3,\"125\":3,\"126\":4,\"127\":3,\"130\":7,\"139\":4,\"144\":1,\"156\":24,\"160\":6,\"162\":3,\"165\":3,\"169\":1,\"171\":9,\"172\":1,\"178\":2,\"179\":6,\"180\":96,\"181\":36,\"188\":2,\"189\":30,\"193\":2,\"200\":1,\"201\":1,\"202\":2,\"222\":1,\"230\":1,\"232\":7,\"238\":1,\"239\":8}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
